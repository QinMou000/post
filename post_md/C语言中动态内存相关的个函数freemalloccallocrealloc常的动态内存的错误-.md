<p id="main-toc"><strong>目录</strong></p> <br><p id="-toc" style="margin-left:0px;"></p> <br><p id="free-toc" style="margin-left:0px;"><a href="#free" rel="nofollow">free</a></p> <br><p id="malloc-toc" style="margin-left:0px;"><a href="#malloc" rel="nofollow">malloc</a></p> <br><p id="calloc-toc" style="margin-left:0px;"><a href="#calloc" rel="nofollow">calloc</a></p> <br><p id="realloc-toc" style="margin-left:0px;"><a href="#realloc" rel="nofollow">realloc</a></p> <br><p id="%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E9%94%99%E8%AF%AF-toc" style="margin-left:0px;"><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E9%94%99%E8%AF%AF" rel="nofollow">常见的动态内存的错误</a></p> <br><p id="1.%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E2%BD%A4%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#1.%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E2%BD%A4%E6%93%8D%E4%BD%9C" rel="nofollow">1.对NULL指针的解引⽤操作</a></p> <br><p id="2.%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#2.%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE" rel="nofollow">2.对动态开辟空间的越界访问</a></p> <br><p id="3.%E5%AF%B9%E2%BE%AE%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#3.%E5%AF%B9%E2%BE%AE%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE" rel="nofollow">3.对⾮动态开辟内存使⽤free释放</a></p> <br><p id="4.%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E2%BC%80%E9%83%A8%E5%88%86-toc" style="margin-left:40px;"><a href="#4.%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E2%BC%80%E9%83%A8%E5%88%86" rel="nofollow">4.使⽤free释放⼀块动态开辟内存的⼀部分</a></p> <br><p id="5.%E5%AF%B9%E5%90%8C%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE-toc" style="margin-left:40px;"><a href="#5.%E5%AF%B9%E5%90%8C%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE" rel="nofollow">5.对同⼀块动态内存多次释放</a></p> <br><p id="6.%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89" rel="nofollow">6.动态开辟内存忘记释放（内存泄漏）</a></p> <br><p id="%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%87%A0%E6%AE%B5%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%87%A0%E6%AE%B5%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9A" rel="nofollow">下面有几段代码都是有问题的：</a></p> <br><p id="1.-toc" style="margin-left:40px;"><a href="#1." rel="nofollow">1.</a></p> <br><p id="2.-toc" style="margin-left:40px;"><a href="#2." rel="nofollow">2.</a></p> <br><p id="3.-toc" style="margin-left:40px;"><a href="#3." rel="nofollow">3.</a></p> <br><p id="4.-toc" style="margin-left:40px;"><a href="#4." rel="nofollow">4.</a></p> <br><hr id="hr-toc" /> <br><p></p> <br><h2 id="free">free</h2> <br><p>C语⾔提供了⼀个函数free，专⻔是⽤来做动态内存的释放和回收的，函数原型如下：</p> <br><pre><code class="language-cpp">void free (void* ptr);</code></pre> <br><p>free函数⽤来释放动态开辟的内存。<br /> • 如果参数 ptr 指向的空间不是动态开辟的，那free函数的⾏为是未定义的。<br /> • 如果参数 ptr 是NULL指针，则函数什么事都不做。</p> <br><h2 id="malloc">malloc</h2> <br><pre><code class="language-cpp">void* malloc (size_t size);</code></pre> <br><p>这个函数向内存申请⼀块连续可⽤的空间（size的单位是字节 ），并返回指向这块空间的指针。</p> <br><p>如果开辟成功，则返回⼀个指向开辟好空间的指针。</p> <br><p>如果开辟失败，则返回⼀个 NULL 指针，因此malloc的返回值⼀定要做检查。</p> <br><p>返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使⽤的时候使⽤者⾃<br /> ⼰来决定。</p> <br><p>如果参数 size 为0，malloc的⾏为是标准是未定义的，取决于编译器(在VS2022上malloc会象征性的给你一个地址，当你访问这个地址的时候就会造成越界访问）<br />  </p> <br><pre><code class="language-cpp">int main()<br>{<br>	int* p = NULL;<br>	p = malloc(3 * sizeof(int));<br>	if (p == NULL)<br>		perror("malloc");<br>	else<br>	{<br>		//......<br>	}<br>    free(p);<br>    p = NULL;<br>	return 0;<br>}</code></pre> <br><h2 id="calloc">calloc</h2> <br><pre><code class="language-cpp">void* calloc (size_t num, size_t size);</code></pre> <br><p>函数的功能是为 num 个⼤⼩为 size（单位也为字节） 的元素开辟⼀块空间，并且把空间的每个字节初始化为0。与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0</p> <br><pre><code class="language-cpp">int main()<br>{<br>	int* p = NULL;<br>	p = calloc(3, 4);<br>	if (p == NULL)<br>		perror("calloc");<br>	else<br>	{<br>		for (int j = 0; j < 3; j++)<br>		{<br>			printf("%d ",*(p+j));<br>		}<br>	}<br>    free(p);<br>    p = NULL;<br>	return 0;<br>}</code></pre> <br><h2 id="realloc">realloc</h2> <br><p>realloc函数的出现让动态内存管理更加灵活。</p> <br><p>有时会我们发现过去申请的空间太⼩了，有时候我们⼜会觉得申请的空间过⼤了，那为了合理的分配内存，我们⼀定会对内存的⼤⼩做灵活的调整。那 realloc 函数就可以做到对动态开辟内存⼤<br /> ⼩的调整。</p> <br><pre><code class="language-cpp">//函数原型如下：<br>void* realloc (void* ptr, size_t size);</code></pre> <br><p>ptr 是要调整的内存地址、</p> <br><p>size 调整之后新⼤⼩</p> <br><p>返回值为调整之后的内存起始位置。</p> <br><p>这个函数调整原内存空间⼤⼩的基础上，还会将原来内存中的数据移动到新的空间。</p> <br><p>realloc在调整内存空间的是存在两种情况：</p> <br><p>        <strong>情况1：原有空间之后有⾜够⼤的空间</strong></p> <br><p>这时直接在后面开辟空间，并返回起始地址（就是传过来的那个）。</p> <br><p>       <strong> 情况2：原有空间之后没有⾜够⼤的空间</strong></p> <br><p>这时编译器会在内存的另一块空间开辟size大小的地址，并将原空间的数据拷贝到新空间，返回新空间的起始地址。</p> <br><h2 id="%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E9%94%99%E8%AF%AF">常见的动态内存的错误</h2> <br><h3 id="1.%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E2%BD%A4%E6%93%8D%E4%BD%9C">1.对NULL指针的解引⽤操作</h3> <br><pre><code class="language-cpp">void test()<br>{<br>    int *p = (int *)malloc(INT_MAX/4);<br>    *p = 20;//如果p的值是NULL，就会有问题<br>    free(p);<br>}</code></pre> <br><h3 id="2.%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE">2.对动态开辟空间的越界访问</h3> <br><pre><code class="language-cpp">void test()<br>{<br>    int i = 0;<br>    int *p = (int *)malloc(10*sizeof(int));<br>    if(NULL == p)<br>    {<br>        exit(EXIT_FAILURE);<br>    }<br>    for(i=0; i<=10; i++)<br>    {<br>        *(p+i) = i;//当i是10的时候越界访问<br>    }<br>    free(p);<br>}</code></pre> <br><h3 id="3.%E5%AF%B9%E2%BE%AE%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE">3.对⾮动态开辟内存使⽤free释放</h3> <br><pre><code class="language-cpp">void test()<br>{<br>    int a = 10;<br>    int *p = &a;<br>    free(p);//ok?<br>}</code></pre> <br><h3 id="4.%E4%BD%BF%E2%BD%A4free%E9%87%8A%E6%94%BE%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E2%BC%80%E9%83%A8%E5%88%86">4.使⽤free释放⼀块动态开辟内存的⼀部分</h3> <br><pre><code class="language-cpp">void test()<br>{<br>    int *p = (int *)malloc(100);<br>    p++;<br>    free(p);//p不再指向动态内存的起始位置<br>}</code></pre> <br><h3 id="5.%E5%AF%B9%E5%90%8C%E2%BC%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE">5.对同⼀块动态内存多次释放</h3> <br><pre><code class="language-cpp">void test()<br>{<br>    int *p = (int *)malloc(100);<br>    free(p);<br>    free(p);//重复释放<br>}</code></pre> <br><h3 id="6.%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89">6.动态开辟内存忘记释放（内存泄漏）</h3> <br><pre><code class="language-cpp">void test()<br>{<br>    int *p = (int *)malloc(100);<br>    if(NULL != p)<br>    {<br>        *p = 20;<br>    }<br>}<br>int main()<br>{<br>    test();<br>    while(1);<br>}</code></pre> <br><p>忘记释放不再使⽤的动态开辟的空间会造成内存泄漏。<br /><strong>切记：动态开辟的空间⼀定要释放，并且正确释放</strong></p> <br><h2 id="%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%87%A0%E6%AE%B5%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9A">下面有几段代码都是有问题的：</h2> <br><h3 id="1.">1.</h3> <br><pre><code class="language-cpp">void GetMemory(char* p)<br>{<br>	p = (char*)malloc(100);<br>}<br>void Test(void)<br>{<br>	char* str = NULL;<br>	GetMemory(str);//这里str并没有改变，p是在函数内部创建的变量，在出函数的时候就会被销毁，<br>                   //这里应该传二级指针。<br>	strcpy(str, "hello world");<br>	printf(str);<br>}<br>main()<br>{<br>	Test();<br>	return 0;<br>}</code></pre> <br><h3 id="2.">2.</h3> <br><pre><code class="language-cpp">char* GetMemory(void)<br>{<br>	char p[] = "hello world";<br>	return p;<br>}<br>void Test(void)<br>{<br>	char* str = NULL;<br>	str = GetMemory();//在这个函数被调用之后，在函数内部创建的串"hello world"的空间就会被操作系 <br>                      //统回收，最后打印出：烫烫烫......<br>	printf(str);//这里打印是没有问题的！<br>}<br><br>int main()<br>{<br>	Test();<br><br>	return 0;<br>}</code></pre> <br><h3 id="3.">3.</h3> <br><pre><code class="language-cpp">void GetMemory(char** p, int num)<br>{<br>	*p = (char*)malloc(num);<br>}<br>void Test(void)<br>{<br>	char* str = NULL;<br>	GetMemory(&str, 100);<br>	strcpy(str, "hello");<br>	printf(str);<br>        //在使用完了空间后没有free！<br>}<br><br>int main()<br>{<br>	Test();<br>	return 0;<br>}</code></pre> <br><h3 id="4.">4.</h3> <br><pre><code class="language-cpp">void Test(void)<br>{<br>	char* str = (char*)malloc(100);<br>	strcpy(str, "hello");<br>	free(str);<br>	if (str != NULL)//这里str已经被free掉了，按理来说就不能使用了<br>	{<br>		strcpy(str, "world");//编译器会报警告：C6001使用未初始化的内存“str”<br>		printf(str);<br>	}<br>}<br>int main()<br>{<br>	Test();<br>	return 0;<br>}</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>