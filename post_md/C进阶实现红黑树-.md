<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/9e66b67c73ef431f887a88a78f972ea7.png" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2 style="background-color:transparent;"> 红⿊树的概念</h2> <br><p>红⿊树是⼀棵⼆叉搜索树，他的每个结点增加⼀个存储位来表示结点的颜⾊，可以是红⾊或者⿊⾊。 通过对任何⼀条从根到叶⼦的路径上各个结点的颜⾊进⾏约束，红⿊树确保没有⼀条路径会⽐其他路径⻓出2倍，因⽽是接近平衡的。</p> <br><h3>红⿊树的规则</h3> <br><blockquote> <br> <p><span style="color:#be191c;"><strong>1. 每个结点不是红⾊就是⿊⾊ </strong></span></p> <br> <p><span style="color:#be191c;"><strong>2. 根结点是⿊⾊的 </strong></span></p> <br> <p><span style="color:#be191c;"><strong>3. 如果⼀个结点是红⾊的，则它的两个孩⼦结点必须是⿊⾊的，也就是说任意⼀条路径不会有连续的红⾊结点。 </strong></span></p> <br> <p><span style="color:#be191c;"><strong>4. 对于任意⼀个结点，从该结点到其所有NULL结点的简单路径上，均包含相同数量的⿊⾊结点</strong></span></p> <br></blockquote> <br><p><img alt="" height="186" src="https://i-blog.csdnimg.cn/direct/63fabd679c914e98b2eedae742bc071d.png" width="339" /><img alt="" height="186" src="https://i-blog.csdnimg.cn/direct/929b29a1645e4b35b7f0cd2e73ef3ac5.jpeg" width="338" /></p> <br><p> <img alt="" height="170" src="https://i-blog.csdnimg.cn/direct/dc5027d12357444c81ad60d5622b2da4.png" width="325" /><img alt="" height="161" src="https://i-blog.csdnimg.cn/direct/7b7c04642f2048e7a877cdfa3800274a.png" width="346" /></p> <br><p> 思考⼀下，红⿊树如何确保最⻓路径不超过最短路径的2倍的？</p> <br><blockquote> <br> <p>• 由规则4可知，从根到NULL结点的每条路径都有相同数量的⿊⾊结点，所以<span style="color:#be191c;"><strong>极端场景下，最短路径就就是全是⿊⾊结点的路径，假设最短路径⻓度为bh(black height)</strong></span>。</p> <br> <p>• 由规则2和规则3可知，任意⼀条路径不会有连续的红⾊结点，所以<span style="color:#be191c;"><strong>极端场景下，最⻓的路径就是⼀⿊⼀红间隔组成，那么最⻓路径的⻓度为2*bh。</strong></span></p> <br> <p>• 综合红⿊树的4点规则⽽⾔，理论上的全⿊最短路径和⼀⿊⼀红的最⻓路径并不是在每棵红⿊树都存在的。假设任意⼀条从根到NULL结点路径的⻓度为x，那么bh <= h <= 2*bh。</p> <br></blockquote> <br><h3>红⿊树的效率</h3> <br><p>假设N是红⿊树树中结点数量，h最短路径的⻓度，那么 , <span style="color:#be191c;"><strong>由此推出 ，也就是意味着红⿊树增删查改最坏也就是⾛最⻓路径 ，那么时间复杂度还是 。 2^h − 1 <= N < 2^(2∗h) − 1 由此推出h ≈ logN 也就是意味着红黑树增删查改最坏也就是走最长路径2 ∗ logN 那么时间复杂度还是O(logN)</strong></span></p> <br><p>红⿊树的表达相对AVL树要抽象⼀些，AVL树通过⾼度差直观的控制了平衡。红⿊树通过4条规则的颜⾊约束，间接的实现了<span style="color:#be191c;"><strong>近似平衡</strong></span>，他们效率都是同⼀档次，但是相对⽽⾔，插⼊相同数量的结点，<span style="color:#be191c;"><strong>红⿊树的旋转次数是更少的</strong></span>，因为他对平衡的控制没那么严格。</p> <br><p><img alt="" height="394" src="https://i-blog.csdnimg.cn/direct/45291a67bc3a47c09aed997ef55f8b08.png" width="749" /></p> <br><h2>红黑树的实现</h2> <br><h3>红黑树的结构</h3> <br><pre><code class="language-cpp">enum color<br>{<br>	RED,<br>	BLACK<br>};<br>template<class K,class V><br>struct RBNode<br>{<br>public:<br>	RBNode(const pair<K, V>& kv)<br>		:_kv(kv),<br>		_parent(nullptr),<br>		_left(nullptr),<br>		_right(nullptr),<br>		_col(RED)<br>	{}<br>	struct RBNode<K, V>* _parent;<br>	struct RBNode<K, V>* _left;<br>	struct RBNode<K, V>* _right;<br>	pair<K, V> _kv;<br>	color _col;<br>};<br><br>template<class K,class V><br>class RBTree<br>{<br>	typedef struct RBNode<K, V> Node;<br>public:<br>    //...<br>private:<br>	Node* _root = nullptr;<br>};</code></pre> <br><h3 style="background-color:transparent;">红⿊树的插⼊</h3> <br><p>红⿊树树插⼊⼀个值的⼤概过程</p> <br><p>1. 插⼊⼀个值按⼆叉搜索树规则进⾏插⼊，插⼊后我们只需要观察是否符合红⿊树的4条规则。</p> <br><p>2. 如果是空树插⼊，新增结点是⿊⾊结点。如果是⾮空树插⼊，新增结点必须红⾊结点，因为⾮空树插⼊，新增⿊⾊结点就破坏了规则4，规则4是很难维护的。</p> <br><p>3. ⾮空树插⼊后，新增结点必须红⾊结点，如果⽗亲结点是⿊⾊的，则没有违反任何规则，插⼊结束</p> <br><p>4. ⾮空树插⼊后，新增结点必须红⾊结点，如果⽗亲结点是红⾊的，则违反规则3。进⼀步分析，c是红⾊，p为红，g必为⿊，这三个颜⾊都固定了，关键的变化看u的情况，需要<span style="color:#be191c;"><strong>根据u分为以下⼏种情况分别处理。</strong></span></p> <br><blockquote> <br> <p>说明：下图中假设我们把新增结点标识为c (cur)，c的⽗亲标识为p(parent)，p的⽗亲标识为 g(grandfather)，p的兄弟标识为u（uncle）。 </p> <br></blockquote> <br><h4><span style="color:#0d0016;">情况1：变⾊</span></h4> <br><p><strong><span style="color:#0d0016;">c为红，p为红，g为⿊，u存在且为红，则将p和u变⿊，g变红。在把g当做新的c，继续往上更新。 </span></strong></p> <br><p><strong><span style="color:#0d0016;">分析：因为p和u都是红⾊，g是⿊⾊，把p和u变⿊，左边⼦树路径各增加⼀个⿊⾊结点，g再变红，相 当于保持g所在⼦树的⿊⾊结点的数量不变，同时解决了c和p连续红⾊结点的问题，需要继续往上更新 是因为，g是红⾊，如果g的⽗亲还是红⾊，那么就还需要继续处理；如果g的⽗亲是⿊⾊，则处理结束 了；如果g就是整棵树的根，再把g变回⿊⾊。 </span></strong></p> <br><p><strong><span style="color:#0d0016;">情况1只变⾊，不旋转。所以⽆论c是p的左还是右，p是g的左还是右，都是上⾯的变⾊处理⽅式。 </span></strong></p> <br><figure class="image"> <br> <img alt="" height="227" src="https://i-blog.csdnimg.cn/direct/0f103deab1104289a497ef0fcc9874b4.png" width="687" /> <br> <figcaption> <br>  <strong>图0</strong> <br> </figcaption> <br></figure> <br><p><strong><span style="color:#0d0016;">• 跟AVL树类似，图0我们展示了⼀种具体情况，但是实际中需要这样处理的有很多种情况。 </span></strong></p> <br><p><strong><span style="color:#0d0016;">• 图1将以上类似的处理进⾏了抽象表达，d/e/f代表每条路径拥有hb个⿊⾊结点的⼦树，a/b代表每 条路径拥有hb-1个⿊⾊结点的根为红的⼦树，hb>=0。 </span></strong></p> <br><p><strong><span style="color:#0d0016;">• 图2/图3/图4，分别展示了hb == 0/hb == 1/hb == 2的具体情况组合分析，当hb等于2时，这⾥组合情况上百亿种，这些样例是帮助我们理解，不论情况多少种，多么复杂，处理⽅式⼀样的，变⾊再继续往上处理即可，所以我们只需要看抽象图即可。</span></strong></p> <br><figure class="image"> <br> <img alt="" height="412" src="https://i-blog.csdnimg.cn/direct/1ddb7b5a541745ea813ffa3733969c97.png" width="671" /> <br> <figcaption> <br>  <strong>图1</strong> <br> </figcaption> <br></figure> <br><figure class="image"> <br> <img alt="" height="334" src="https://i-blog.csdnimg.cn/direct/d77eafd8191c4ae4b6f01856503eb4be.png" width="884" /> <br> <figcaption> <br>  <strong>图2</strong> <br> </figcaption> <br></figure> <br><figure class="image"> <br> <img alt="" height="627" src="https://i-blog.csdnimg.cn/direct/1b005c7df8a74bfd9df61f5b008c2de8.png" width="897" /> <br> <figcaption> <br>  <strong>图3</strong> <br> </figcaption> <br></figure> <br><figure class="image"> <br> <img alt="" height="809" src="https://i-blog.csdnimg.cn/direct/dbebd10e2db74a2faa3f50fd4d05f8c1.png" width="885" /> <br> <figcaption> <br>  <strong>图4</strong> <br> </figcaption> <br></figure> <br><h4><strong><span style="color:#0d0016;"> 情况2：单旋+变⾊</span></strong></h4> <br><p><strong><span style="color:#0d0016;">c为红，p为红，g为⿊，u不存在或者u存在且为⿊，u不存在，则c⼀定是新增结点，u存在且为⿊，则 c⼀定不是新增，c之前是⿊⾊的，是在c的⼦树中插⼊，符合情况1，变⾊将c从⿊⾊变成红⾊，更新上 来的。 </span></strong></p> <br><p><strong><span style="color:#0d0016;">分析：p必须变⿊，才能解决，连续红⾊结点的问题，u不存在或者是⿊⾊的，这⾥单纯的变⾊⽆法解 决问题，需要旋转+变⾊。</span></strong></p> <br><p><strong><span style="color:#0d0016;"><img alt="" height="442" src="https://i-blog.csdnimg.cn/direct/0976121f60ec40098425648bb7236fd4.png" width="725" />如果p是g的左，c是p的左，那么以g为旋转点进⾏右单旋，再把p变⿊，g变红即可。p变成课这颗树新 的根，这样⼦树⿊⾊结点的数量不变，没有连续的红⾊结点了，且不需要往上更新，因为p的⽗亲是⿊⾊还是红⾊或者空都不违反规则。 </span></strong></p> <br><p><strong><span style="color:#0d0016;"><img alt="" height="417" src="https://i-blog.csdnimg.cn/direct/6e36289fe95440dc94b7f5693e0d36aa.png" width="704" />如果p是g的右，c是p的右，那么以g为旋转点进⾏左单旋，再把p变⿊，g变红即可。p变成课这颗树新 的根，这样⼦树⿊⾊结点的数量不变，没有连续的红⾊结点了，且不需要往上更新，因为p的⽗亲是⿊ ⾊还是红⾊或者空都不违反规则。</span></strong></p> <br><p><strong><span style="color:#0d0016;"><img alt="" height="1010" src="https://i-blog.csdnimg.cn/direct/078d7ca9fec8467d91ea23381fecfa56.png" width="898" /></span></strong></p> <br><p><strong><span style="color:#0d0016;">情况3：双旋+变⾊ </span></strong></p> <br><p><strong><span style="color:#0d0016;">c为红，p为红，g为⿊，u不存在或者u存在且为⿊，u不存在，则c⼀定是新增结点，u存在且为⿊，则 c⼀定不是新增，c之前是⿊⾊的，是在c的⼦树中插⼊，符合情况1，变⾊将c从⿊⾊变成红⾊，更新上 来的。 </span></strong></p> <br><p><strong><span style="color:#0d0016;">分析：p必须变⿊，才能解决，连续红⾊结点的问题，u不存在或者是⿊⾊的，这⾥单纯的变⾊⽆法解 决问题，需要旋转+变⾊。 </span></strong></p> <br><p><strong><span style="color:#0d0016;"><img alt="" height="469" src="https://i-blog.csdnimg.cn/direct/30bcd035aa8047ed9f317f4f07f9fd55.png" width="737" /></span></strong></p> <br><p><strong><span style="color:#0d0016;">如果p是g的左，c是p的右，那么先以p为旋转点进⾏左单旋，再以g为旋转点进⾏右单旋，再把c变 ⿊，g变红即可。c变成课这颗树新的根，这样⼦树⿊⾊结点的数量不变，没有连续的红⾊结点了，且 不需要往上更新，因为c的⽗亲是⿊⾊还是红⾊或者空都不违反规则。</span></strong></p> <br><p><strong><span style="color:#0d0016;"><img alt="" height="465" src="https://i-blog.csdnimg.cn/direct/fb5721072d774fb78064e93c92a0ac39.png" width="786" /></span></strong></p> <br><p><strong><span style="color:#0d0016;">如果p是g的右，c是p的左，那么先以p为旋转点进⾏右单旋，再以g为旋转点进⾏左单旋，再把c变 ⿊，g变红即可。c变成课这颗树新的根，这样⼦树⿊⾊结点的数量不变，没有连续的红⾊结点了，且 不需要往上更新，因为c的⽗亲是⿊⾊还是红⾊或者空都不违反规则。</span></strong></p> <br><p><strong><span style="color:#0d0016;"><img alt="" height="1020" src="https://i-blog.csdnimg.cn/direct/313e239509e34d34a889246faa65c59a.png" width="900" /></span></strong></p> <br><h2>红黑树插入代码</h2> <br><pre><code class="language-cpp">	bool insert(const pair<K, V>& kv)<br>	{<br>		if (_root == nullptr)<br>		{<br>			_root = new Node(kv);<br>			return true;<br>		}<br>		else<br>		{<br>			Node* parent = nullptr;<br>			Node* cur = _root;<br>			while (cur)<br>			{<br>				if (cur->_kv.first > kv.first)<br>				{<br>					parent = cur;//先更新parent<br>					cur = cur->_left;<br>				}<br>				else if (cur->_kv.first < kv.first)<br>				{<br>					parent = cur;<br>					cur = cur->_right;<br>				}<br>				else<br>					return false;<br>			}<br>			cur = new Node(kv);<br><br>			if (parent->_kv.first < cur->_kv.first)<br>				parent->_right = cur;<br>			else<br>				parent->_left = cur;<br>			cur->_parent = parent;<br>			<br>			// 插入新节点，其父节点存在且为红，不符合规则，需要调整<br>			while (parent && parent->_col == RED)<br>			{<br>				Node* gradfather = parent->_parent;<br>				if (parent == gradfather->_left)<br>				{<br>					Node* uncle = gradfather->_right;<br>					if (uncle && uncle->_col == RED)// 叔叔存在且为红<br>					{<br>						parent->_col = uncle->_col = BLACK;<br>						gradfather->_col = RED;<br>						// 往上处理<br>						cur = gradfather;<br>						parent = cur->_parent;<br>					}<br>					else// 叔叔不存在，或者叔叔存在且为黑<br>					{<br>						if (cur = parent->_left)<br>						{<br>							//      g<br>							//    p   u<br>							//  c<br>							RotateR(gradfather);<br>							parent->_col = BLACK;<br>							gradfather->_col = RED;<br>						}<br>						else<br>						{<br>							//      g<br>							//    p   u<br>							//     c<br>							RotateL(parent);<br>							RotateR(gradfather);<br>							gradfather->_col = RED;<br>							cur->_col = BLACK;<br>						}<br>						break;<br>					}<br>				}<br>				else<br>				{<br>					Node* uncle = gradfather->_left;<br>					if (uncle && uncle->_col == RED)// 叔叔存在且为红<br>					{<br>						parent->_col = uncle->_col = BLACK;<br>						gradfather->_col = RED;<br>						// 往上处理<br>						cur = gradfather;<br>						parent = cur->_parent;<br>					}<br>					else// 叔叔不存在，或者叔叔存在且为黑<br>					{<br>						if (cur == parent->_right)<br>						{<br>							//      g<br>							//    u   p<br>							//          c<br>							RotateL(gradfather);<br>							parent->_col = BLACK;<br>							gradfather->_col = RED;<br>						}<br>						else<br>						{<br>							//      g<br>							//    u   p<br>							//       c<br>							RotateR(parent);<br>							RotateL(gradfather);<br>							parent->_col = BLACK;<br>							gradfather->_col = RED;<br>						}<br>						break;<br>					}<br>				}<br>			}<br>			_root->_col = BLACK;<br><br>			return true;<br>		}<br>	}<br></code></pre> <br><h2 style="background-color:transparent;">红⿊树的验证</h2> <br><p>这⾥获取最⻓路径和最短路径，检查最⻓路径不超过最短路径的2倍是不可⾏的，因为就算满⾜这个条件，红⿊树也可能颜⾊不满⾜规则，当前暂时没出问题，后续继续插⼊还是会出问题的。<span style="color:#be191c;"><strong>所以我们还是去检查4点规则，满⾜这4点规则，⼀定能保证最⻓路径不超过最短路径的2倍。</strong></span></p> <br><blockquote> <br> <p>1. 规则1枚举颜⾊类型，天然实现保证了颜⾊不是⿊⾊就是红⾊。</p> <br> <p>2. 规则2直接检查根即可</p> <br> <p>3. 规则3前序遍历检查，遇到红⾊结点查孩⼦不太⽅便，因为孩⼦有两个，且不⼀定存在，<span style="color:#be191c;"><strong>反过来检查⽗亲的颜⾊就⽅便多了。</strong></span></p> <br> <p><span style="color:#be191c;"><strong>4. 规则4前序遍历，遍历过程中⽤形参记录跟到当前结点的blackNum(⿊⾊结点数量)，前序遍历遇到⿊⾊结点就++blackNum，⾛到空就计算出了⼀条路径的⿊⾊结点数量。再任意⼀条路径⿊⾊结点数量作为参考值，依次⽐较即可 </strong></span></p> <br></blockquote> <br><p> <strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong> </p>