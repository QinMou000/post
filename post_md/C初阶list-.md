<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/a1e2fd8531ae4fbab004f1ecd1a2c8b1.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><p><span style="color:#be191c;"> <strong>学习STL要多看文档</strong></span><a href="https://legacy.cplusplus.com/reference/list/list/?kw=list" rel="nofollow" title="list - C++ Reference (cplusplus.com)">list - C++ Reference (cplusplus.com)</a></p> <br><h2>list的介绍</h2> <br><p>list的 底层结构和我们之前学的双向带头循环链表的结构是差不多的，封装一个节点包含数据和前后节点的指针。迭代器就是指向这个节点的指针，只不过由于原生指针不支持随机访问，所以对这个指针进行了封装。</p> <br><h2>list的使用</h2> <br><h3>constructor</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>构造函数(constructor)</td><td>接口说明</td></tr><tr><td>list()</td><td>默认构造</td></tr><tr><td>list(size_type n,const value_type& val = value_type())</td><td>构造的list中包含n个值为val的与元素</td></tr><tr><td>list(const list& x)</td><td>拷贝构造</td></tr><tr><td>list(InputIterator first , InputItertor last)</td><td>用迭代器[first , last)区间中的元素构造list</td></tr></tbody></table> <br><h3> list iterator</h3> <br><blockquote> <br> <p><strong>（1）这里的list迭代器的实现不再是简单的原生指针，而是对原生指针进行了一层封装，使它更符合迭代器的行为</strong></p> <br> <p><strong>（2）这里多加两个模板参数，主要是 * -> 两个操作符重载访问Node里面的内容。如果调的是const_iterator，那么返回的就是const指针（<u>const修饰指针指向的内容不可修改</u>）或引用如果调用普通的iterator，返回普通指针或引用。</strong></p> <br> <p><strong>（3）这样通过模板编译器其实还是会生成两个类，减少了重复的代码</strong></p> <br> <p><strong>（4）list的迭代器不是随机迭代器，而是双向迭代器。</strong></p> <br></blockquote> <br><blockquote> <br> <p>输入迭代器（Input Iterators）：允许读取和遍历容器中的元素，只能单向移动，每个元素只能被访问一次。<br /> 输出迭代器（Output Iterators）：允许向容器中写入元素，只能单向移动，每个位置只能被写入一次。<br /> 前向迭代器（Forward Iterators）：允许读写容器中的元素，可以多次读写同一个元素，只能单向移动。<br /> 双向迭代器（Bidirectional Iterators）：具有前向迭代器的所有功能，同时允许在容器中双向移动。<br /> 随机访问迭代器（Random Access Iterators）：具有双向迭代器的所有功能，同时提供了快速随机访问容器中任意元素的能力，如指针算术运算。 </p> <br></blockquote> <br><pre><code class="language-cpp">template<class T,class Ref,class Ptr><br>struct list_iterator<br>{<br>	typedef list_iterator<T, Ref, Ptr> self;<br>	typedef list_iterator<T, T&, T*> iterator;<br>	typedef list_iterator<T, const T&, const T*> const_iterator;<br><br>	typedef struct Node<T> Node;<br><br>	list_iterator(Node* node = nullptr)<br>		:_node(node)<br>	{}<br>	list_iterator(const self& lf)<br>	{<br>		_node = lf._node;<br>	}<br>	Ref operator*()<br>	{<br>		return _node->data;<br>	}<br>	Ptr operator->()<br>	{<br>		return &_node->data;<br>	}<br>	self& operator++()<br>	{<br>		_node = _node->next;<br>		return *this;<br>	}<br>	self operator++(int)<br>	{<br>		self tmp(_node);<br>		//Node* tmp = new Node(_node->data);//自己想出来的写法哟~but有点复杂了<br>		_node = _node->next;<br>		return tmp;<br>	}<br>	self& operator--()<br>	{<br>		_node = _node->prev;<br>		return *this;<br>	}<br>	self operator--(int)<br>	{<br>		self tmp(_node);<br>		//Node* tmp = new Node(_node->data);//自己想出来的写法哟~but有点复杂了<br>		_node = _node->prev;<br>		return tmp;<br>	}<br>	bool operator==(const self& it)<br>	{<br>		return _node == it._node;<br>	}<br>	bool operator!=(const self& it)<br>	{<br>		return _node != it._node;<br>	}<br>	Node* _node;<br>};</code></pre> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/begin/" rel="nofollow" title="begin()">begin()</a></td><td>返回第一个元素的迭代器</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/end/" rel="nofollow" title="end()">end()</a></td><td>返回最后一个元素的下一个位置的迭代器</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/rbegin/" rel="nofollow" title="rbegin()">rbegin()</a></td><td>返回第一个元素的reverse_iterator,即end位置</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/rend/" rel="nofollow" title="rend()">rend()</a></td><td>返回最后一个元素下一个位 置的reverse_iterator,即begin位置</td></tr></tbody></table> <br><blockquote> <br> <p><u><strong>【注意】 </strong></u></p> <br> <p><u><strong>（1）begin与end为正向迭代器，对迭代器执行++操作，迭代器向后移动 </strong></u></p> <br> <p><u><strong>（2）rbegin(end)与rend(begin)为反向迭代器，对迭代器执行++操作，迭代器向前移动 </strong></u></p> <br></blockquote> <br><p><img alt="" height="717" src="https://i-blog.csdnimg.cn/direct/6ef01c57dc134474a3a084b6e44e8c56.png" width="1200" /></p> <br><h3>list capacity</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数声明</td><td>接口说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/empty/" rel="nofollow" title="empty()">empty()</a></td><td>检测list是否为空，是返回true，否则返回false</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/size/" rel="nofollow" title="size()">size()</a></td><td> <p>返回list中有效节点的个数</p> </td></tr></tbody></table> <br><h3>list element access</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数声明</td><td>接口说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/front/" rel="nofollow" title="front()">front()</a></td><td>返回list的第一个节点中值的引用</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/back/" rel="nofollow" title="back()">back()</a></td><td>返回list的最后一个节点中值的引用</td></tr></tbody></table> <br><h3>list modifiers</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数声明</td><td>接口说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/push_front/" rel="nofollow" title="push_front()">push_front()</a></td><td>在list首元素前插入值为val的元素</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/pop_front/" rel="nofollow" title="pop_front()">pop_front()</a></td><td>删除list中第一个元素</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/push_back/" rel="nofollow" title="push_back()">push_back()</a></td><td>在list尾部插入值为val的元素</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/pop_back/" rel="nofollow" title="pop_back()">pop_back()</a></td><td>删除list中最后一个元素</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/insert/" rel="nofollow" title="insert()">insert()</a></td><td>在list position 位置中插入值为val的元素</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/erase/" rel="nofollow" title="erase()">erase()</a></td><td>删除list position位置的元素</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/swap/" rel="nofollow" title="swap()">swap()</a></td><td>交换两个list中的元素</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/list/list/clear/" rel="nofollow" title="clear()">clear()</a></td><td>清空list中的有效元素</td></tr></tbody></table> <br><h2> list的迭代器失效</h2> <br><p>此处大家可将迭代器<em>暂时</em>理解成类似于指针，迭代器失效即迭代器所指向的节点的无效，即该节点被删除了。因为list的底层结构为带头结点的双向循环链表，因此<u><strong>在list中进行插入时是不会导致list的迭代器失效的，只有在删除时才会失效，并且失效的只是指向被删除节点的迭代器，其他迭代器不会受到影响。</strong></u></p> <br><p><img alt="" height="701" src="https://i-blog.csdnimg.cn/direct/82e962e5ae7a4d4095f14bf5af42b00e.png" width="1200" /></p> <br><blockquote> <br> <p><u><strong> 随机插入完成后会返回新插入节点的迭代器，随机删除完成后会返回删除节点的下一个节点的迭代器，若删除了最后一个元素，则返回头节点的迭代器。</strong></u></p> <br></blockquote> <br><pre><code class="language-cpp">iterator insert(iterator pos,const T& val)<br>{<br>	Node* cur = pos._node;<br>	Node* prev = cur->prev;<br>	Node* newnode = new Node(val);<br><br>	prev->next = newnode;<br>	newnode->prev = prev;<br>	cur->prev = newnode;<br>	newnode->next = cur;<br><br>	++_size;<br><br>	return newnode;<br>}<br>iterator erase(iterator pos)<br>{<br>	assert(pos != end());<br>	Node* next = pos._node->next;<br>	Node* prev = next->prev;<br><br>	delete pos._node;<br><br>	prev->next = next;<br>	next->prev = prev;<br>	--_size;<br>	return next;<br>}</code></pre> <br><h2> 模拟实现list</h2> <br><p><a href="https://gitee.com/wang-qin928/c-learning/blob/master/function/list%E7%B1%BB/list.h" rel="nofollow" title="function/list类/list.h · 钦某/C++learning - 码云 - 开源中国 (gitee.com)">function/list类/list.h · 钦某/C++learning - 码云 - 开源中国 (gitee.com)</a></p> <br><h2>对比list和vector</h2> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td></td><td>vector</td><td>list</td></tr><tr><td>底 层 结 构</td><td>动态顺序表，一段连续空间</td><td>带头结点的双向循环链表</td></tr><tr><td>随 机 访 问</td><td>支持随机访问，访问某个元素效率O(1)</td><td>不支持随机访问，访问某个元素效率O(N)</td></tr><tr><td>插 入 和 删 除</td><td>任意位置插入和删除效率低，需要搬移元素，时间 复杂度为O(N)，插入时有可能需要增容，增容： 开辟新空间，拷贝元素，释放旧空间，导致效率更低</td><td>任意位置插入和删除效率高， 不需要搬移元素，时间复杂度 为O(1)</td></tr><tr><td>空 间 利 用 率</td><td>底层为连续空间，不容易造成内存碎片，空间利用 率高，缓存利用率高</td><td>底层节点动态开辟，小节点容 易造成内存碎片，空间利用率 低，缓存利用率低</td></tr><tr><td>迭 代 器</td><td>原生态指针</td><td>对原生态指针(节点指针)进行封装</td></tr><tr><td>迭 代 器 失 效</td><td>在插入元素时，要给所有的迭代器重新赋值，因为 插入元素有可能会导致重新扩容，致使原来迭代器 失效，删除时，当前迭代器需要重新赋值否则会失 效</td><td>插入元素不会导致迭代器失 效，删除元素时，只会导致当 前迭代器失效，其他迭代器不 受影响</td></tr><tr><td>使 用 场 景</td><td>需要高效存储，支持随机访问，不关心插入删除效 率</td><td>大量插入和删除操作，不关心 随机访问</td></tr></tbody></table> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>