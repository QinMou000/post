<blockquote> <br> <p style="text-align:center;"><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6f2b920cd38b273e9349974209147fee.png" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12634416.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>排序的概念</h2> <br><p>排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p> <br><p>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p> <br><blockquote> <br> <p>内部排序：数据元素全部放在内存中的排序。<br /> 外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不断地在内外存之间移动数据的排序</p> <br></blockquote> <br><p><a href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" rel="nofollow" title="function/数据结构-排序算法 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)">function/数据结构-排序算法 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</a></p> <br><h2>常见排序算法 </h2> <br><p><img alt="" height="847" src="https://i-blog.csdnimg.cn/blog_migrate/975d21eb500c5bcb0d382d19cde68324.png" width="1127" /></p> <br><h2>插入排序 </h2> <br><h3>示意图：</h3> <br><p><img alt="" height="505" src="https://i-blog.csdnimg.cn/blog_migrate/e9e4ffe7a8ac76c39b1ec825a2c79ed4.gif" width="811" /></p> <br><h3> 排序过程：</h3> <br><ul><li><strong>从第一个元素开始，该元素可以认为已经被排序；</strong></li><li><strong>取出下一个元素，在已经排序的元素序列中从后向前扫描；</strong></li><li><strong>如果该元素（已排序）大于新元素，将该元素移到下一位置；</strong></li><li><strong>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</strong></li><li><strong>将新元素插入到该位置后；</strong></li><li><strong>重复步骤2~5。</strong></li></ul> <br><h3> <span style="color:#be191c;"><strong>时间复杂度：</strong></span></h3> <br><p><span style="color:#be191c;"><strong>O(n^2)</strong></span> </p> <br><h3>代码实现： </h3> <br><pre><code class="language-cpp">//插入排序<br>void InsertSort(int* a, int n)<br>{<br>	for (int i = 0; i < n - 1; i++)//注意i的取值<br>	{<br>		int end = i;<br>		int tmp = a[end + 1];<br>		while (end >= 0)<br>		{<br>			if (a[end] > tmp)//这里只能写tmp不能写成a[end+1](每一次循环都要改变)<br>			{<br>				a[end + 1] = a[end];<br>				end--;<br>			}<br>			else<br>				break;<br>		}<br>		a[end + 1] = tmp;<br>	}<br>}</code></pre> <br><h2>希尔排序</h2> <br><h3>示意图：</h3> <br><p><img alt="" height="290" src="https://i-blog.csdnimg.cn/blog_migrate/46e091ee21897033cf570fd0a63a07cc.gif" width="665" /></p> <br><p></p> <br><h3>排序过程：</h3> <br><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p> <br><ul><li><strong>选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；</strong></li><li><strong>按增量序列个数k，对序列进行k 趟排序；</strong></li><li><strong>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</strong></li></ul> <br><p> 随着增量因子(gap)的减少，这其实是一个使数组逐渐变有序的过程。那么有个问题，gap如何变化才能使算法得到最大的优化呢？</p> <br><p>gap越大，大的数可以越快跳到后面，小的数可以越快跳到前面，越不接近有序；gap越小，跳的越慢，但是越接近有序。当 gap == 1时就相当于插入排序。</p> <br><p>这个算法的发明者用的是gap /= 2，有人曾今算过（这里需要很高的数学水平，我还是算了）gap = gap / 3 + 1，为最优解。加一是为了让最后一趟排序的gap为1。</p> <br><h3><span style="color:#be191c;"><strong>时间复杂度：</strong></span></h3> <br><p><span style="color:#b95514;"><strong>第一趟排序分为gap = n / 3组（忽略+1），每组三个数据，最坏情况就是逆序，向前调整（1+2）次，第一趟就的消耗是 n。第二趟gap = n / 9 组每组 9 个数据，最坏情况调整（1+2+......+7+8）次，第二趟的消耗是 4n。</strong></span></p> <br><p><span style="color:#b95514;"><strong>但是，第二趟以后的每一趟都不是最坏的情况，所以第二趟的消耗到不了4n，具体是多少？这里需要加一些概率的公式</strong></span></p> <br><p><span style="color:#b95514;"><strong>最后一趟gap = 1，直接就是插入排序，消耗是n，根据这个我们大概画出了下图。</strong></span></p> <br><p><img alt="" height="778" src="https://i-blog.csdnimg.cn/blog_migrate/468153d8db34cf29b2b5f951361929de.png" width="1200" /></p> <br><p><span style="color:#956fe7;"><strong> </strong></span><span style="color:#be191c;"><strong>最后这个排序的时间复杂度大约为：n^(1.3)</strong></span></p> <br><h3>代码实现： </h3> <br><pre><code class="language-cpp">// 希尔排序<br>void ShellSort(int* a, int n)<br>{<br>	int gap = n;<br>	while (gap > 1)<br>	{<br>		gap = gap / 3 + 1;//决定了时间复杂度，保证最后一次gap为1<br>		for (int i = 0; i < n - gap; i++)//一个个组分开排<br>		{<br>			int end = i;<br>			int tmp = a[end + gap];<br>			while (end >= 0)//等于零也要排一次<br>			{<br>				if (a[end] > tmp)<br>				{<br>					a[end + gap] = a[end];//换位子<br>					end -= gap;<br>				}<br>				else<br>					break;<br>			}<br>			a[end + gap] = tmp;//插入<br>		}<br>	}<br>}</code></pre> <br><h2>选择排序</h2> <br><h3>示意图：</h3> <br><p><img alt="" height="248" src="https://i-blog.csdnimg.cn/blog_migrate/e8a78a4aa35f0340b314676bbbf65853.gif" width="811" /></p> <br><h3>排序过程：</h3> <br><p><strong>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</strong></p> <br><ul><li><strong>初始状态：无序区为R[1..n]，有序区为空；</strong></li><li><strong>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</strong></li><li><strong>n-1趟结束，数组有序化了。</strong></li></ul> <br><p>另外我们在遍历时可以同时将无序区中最大的数和最小的数的下标分别记录，将最大数放在无序区的末尾，将最小数放在无序区的开头。</p> <br><p>注意这里有个坑 ：当一趟排序记录的mini == end时，将max处的数交换到end处，这是end处的数就是最大的数了，之后再将mini处的数交换到start处（这时mini处的数是最大的），这样就没有完成任务。</p> <br><p>解决办法是：在交换之前，做一个判断更新mini的值。</p> <br><h3><span style="color:#be191c;">时间复杂度：</span></h3> <br><p><strong><span style="color:#be191c;">O(n^2) </span></strong></p> <br><h3>代码实现：</h3> <br><pre><code class="language-cpp">//选择排序<br>void SelectSort(int* a, int n)<br>{<br>	int start = 0;<br>	int end = n - 1;<br>	while (end > start)<br>	{<br>		int mini = start;<br>		int maxi = end;<br>		for (int i = start; i <= end; i++)<br>		{<br>			if (a[mini] > a[i])<br>				mini = i;<br>			if (a[maxi] < a[i])<br>				maxi = i;<br>		}<br>		if (mini == end)<br>		{<br>			Swap(&a[maxi], &a[end]);<br>			mini = maxi;<br>			Swap(&a[mini], &a[start]);<br>		}<br>		else<br>		{<br>			Swap(&a[maxi], &a[end]);<br>			Swap(&a[mini], &a[start]);<br>		}<br>		end--;<br>		start++;<br>	}<br>}</code></pre> <br><h2>堆排序</h2> <br><h3>示意图：</h3> <br><p><img alt="" height="364" src="https://i-blog.csdnimg.cn/blog_migrate/bed0bf7f81bc6d3957317c77fc5c56f2.gif" width="547" /></p> <br><h3>排序过程：</h3> <br><p>这里参考下数据结构_堆的代码：<a href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86" rel="nofollow" title="function/数据结构-堆 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)">function/数据结构-堆 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</a></p> <br><ul><li><strong>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</strong></li><li><strong>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；</strong></li><li><strong>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆（堆的元素个数减一），然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</strong></li></ul> <br><h3><span style="color:#be191c;">时间复杂度：</span></h3> <br><p><strong><span style="color:#b95514;">O(n*log(n))</span></strong></p> <br><h3>代码实现： </h3> <br><pre><code class="language-cpp">void AdjustDown(int* a, int n, int parent)<br>{<br>	int child = parent * 2 + 1;<br>	while (child < n)<br>	{<br>		if (a[child] < a[child + 1] && child + 1 < n)<br>			child++;<br>		if (a[child] > a[parent])<br>		{<br>			Swap(&a[child], &a[parent]);<br>			parent = child;<br>			child = parent * 2 + 1;<br>		}<br>		else<br>			break;<br>	}<br>}<br><br>//堆排序<br>void HeapSort(int* a, int n)<br>{<br>	for (int i = (n - 2) / 2; i >= 0; i--)<br>		AdjustDown(a, n, i);<br><br>	for (int i = n - 1; i > 0; i--)<br>	{<br>		Swap(&a[0], &a[i]);<br>		AdjustDown(a, i, 0);<br>	}<br>}</code></pre> <br><h2>冒泡排序 </h2> <br><h3>示意图：</h3> <br><p><img alt="" height="257" src="https://i-blog.csdnimg.cn/blog_migrate/232bdfa758125e154c29c01147a94f21.gif" width="826" /></p> <br><h3>排序过程：</h3> <br><ul><li><strong>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</strong></li><li><strong>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</strong></li><li><strong>针对所有的元素重复以上的步骤，除了最后一个；</strong></li><li><strong>重复步骤1~3，直到排序完成。</strong></li></ul> <br><h3>时间复杂度：</h3> <br><p><span style="color:#be191c;"><strong>O(n^2)</strong></span></p> <br><h3>代码实现： </h3> <br><pre><code class="language-cpp">//冒泡排序<br>void BubbleSort(int* a, int n)<br>{<br>	for (int i = n; i > 0; i--)<br>	{<br>		int prev = 0;<br>		int cur = 1;<br>		int falg = 1;<br>		while (cur < i)<br>		{<br>			if (a[prev] > a[cur])<br>			{<br>				falg = 0;<br>				Swap(&a[prev], &a[cur]);<br>			}<br>			prev = cur;<br>			cur++;<br>		}<br>		if (falg == 1)<br>			break;<br>	}<br>}</code></pre> <br><h2>快速排序</h2> <br><h3>示意图：</h3> <br><p><img alt="" height="252" src="https://i-blog.csdnimg.cn/blog_migrate/6e4df33acb0bf317f4564e330d6c046c.gif" width="811" /></p> <br><h3>排序过程：</h3> <br><p><strong>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</strong></p> <br><ul><li><strong>从数列中挑出一个元素，称为 “基准”（pivot）；</strong></li><li><strong>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</strong></li><li><strong>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</strong></li></ul> <br><p><span style="color:#ad720d;">hoare： </span></p> <br><p> 单趟：我们定义一个key = left，右边先走，右边end--找小（比a[key]小），左边begin++找大，都找到了就交换，当begin > end跳出循环，再将a[key]和a[begin]交换。</p> <br><p><strong>为什么这里要右边先走？为什么相遇时位置比key小？</strong></p> <br><p><span style="color:#be191c;">左边做key，右边先走，可以保证相遇位置比key小</span></p> <br><p><span style="color:#be191c;">场景：</span></p> <br><p><span style="color:#be191c;">L遇R：R先走，停下来，R停下条件是遇到比key小的值，一定比key小，L没有找大的，遇到R停下了</span></p> <br><p><span style="color:#be191c;">R遇L：R先走，找小，没有找到比key小的，直接跟L相遇了。L停留的位置是上一轮交换的位置，上一轮交换，把比key小的值换到L的位置了</span></p> <br><p><span style="color:#38d8f0;">相反:如果让右边做key，左边先走，i可以保证相遇位置比key要大</span></p> <br><p><span style="color:#ad720d;">双指针：</span></p> <br><p>单趟：定义一个prev，一个cur，cur找小，找不到小的prev和cur一起加加，找到了就把cur位置和prev++位置的值交换，prev和cur中间的值都是大的，将大的值一起往后挪。最后prev位置的值一定比key位置的值小，将prev和key位置的值交换。</p> <br><p>每次递归分别传begin两侧的区间。</p> <br><h3>算法优化：</h3> <br><h4>小区间优化</h4> <br><p>我们知道，递归定义的快排随着区间的越来越小，需要递归的次数越来越多，如果次数很多，每次调用函数都要压栈，有可能导致栈溢出。类似二叉树，最后一次递归占总递归次数的50%，倒数第二次占了25%，倒数第三次占12.5%。如果我们能将这部分递归占用缓解，就能使算法优化。所以当区间小于10的时候，我们调用选择排序。</p> <br><pre><code class="language-cpp">void QuickSort(int* a, int left, int right)<br>{<br>	if (left >= right)<br>		return;<br>	if (right - left + 1 < 10)<br>	{<br>		InsertSort(a + left, right - left + 1);//小区间优化<br>		return;<br>	}<br><br>	int keyi = partsort3(a, left, right);<br><br>	QuickSort(a, left, keyi - 1);<br>	QuickSort(a, keyi + 1, right);<br>}</code></pre> <br><h4>三数取中</h4> <br><p>当数组已经有序，或者第一个数很小，或者很大时，时间复杂度就会退化为O(n^2)，这时我们可以改变key值，从第一个值，中间的值和末尾值，三个值中选出中间的那个作为key值，保证每次的key都接近中间数。除了三数取中，还可以产生随机值来改变基准值。</p> <br><pre><code class="language-cpp">int Midofthree(int* a,int x, int y, int z)<br>{<br>	if (a[x] > a[y])<br>		if (a[x] > a[z])<br>			if (a[y] > a[z])<br>				return y;<br>			else<br>				return z;<br>		else<br>			return y;<br>	else//a<b<br>		if (a[x] < a[z])<br>			if (a[y] < a[z])<br>				return y;<br>			else//b>c<br>				return z;<br>		else//a>c<br>			return x;<br>}</code></pre> <br><h4>随机数取key </h4> <br><pre><code class="language-cpp">int GetRanNum(int*a, int left, int right)<br>{<br>	srand(time(0));//给时间为种子生成伪随机数<br>	int key = rand() % (right - left) + left;//在right到left中间的随机数<br>	return key;<br>}<br></code></pre> <br><h3>时间复杂度：</h3> <br><p><span style="color:#be191c;"><strong>O(n*log(n))</strong></span></p> <br><h3>代码实现：</h3> <br><h4>（1）hoare版本：</h4> <br><p><img alt="" height="546" src="https://i-blog.csdnimg.cn/blog_migrate/40e262e727398dde1a14835054c0ffd6.gif" width="1145" /></p> <br><pre><code class="language-cpp">//hoare版本<br>int partsort1(int* a, int left, int right)<br>{<br>	int x = Midofthree(a, left, right, (left + right) / 2);//防止时间复杂度退化<br>	Swap(&a[x], &a[left]);<br>	int key = a[left];<br>	int begin = left, end = right;<br>	while (begin < end)<br>	{<br>		while (begin < end && key <= a[end])//先右边找小<br>			end--;<br><br>		while (begin < end && key >= a[begin])//再左边找大<br>			begin++;<br><br>		Swap(&a[end], &a[begin]);//交换<br>	}<br>	Swap(&a[left], &a[begin]);//把key换到中间<br>	return begin;<br>}</code></pre> <br><h4>（2）双指针版本：</h4> <br><p><img alt="" height="546" src="https://i-blog.csdnimg.cn/blog_migrate/84dc2a5a5a4ce88fcdee069a469e734d.gif" width="1145" /></p> <br><pre><code class="language-cpp">//双指针版本<br>int partsort2(int* a, int left, int right)<br>{<br>	int x = Midofthree(a, left, right, (right + left) / 2);<br>	Swap(&a[x], &a[left]);<br>	int keyi = left;<br>	int prev = left;<br>	int cur = prev + 1;<br>	while (cur <= right)<br>	{<br>		if (a[cur] < a[keyi] && ++prev != cur)<br>			Swap(&a[cur], &a[prev]);<br><br>		cur++;<br>	}<br>	Swap(&a[prev],&a[keyi]);<br>	return prev;<br>}</code></pre> <br><h4> （3）挖坑版本：</h4> <br><p><img alt="" height="546" src="https://i-blog.csdnimg.cn/blog_migrate/9b395b22f96cddfefb76762c8f7d941e.gif" width="1145" /></p> <br><pre><code class="language-cpp">//挖坑版本<br>int partsort3(int* a, int left, int right)<br>{<br>	int x = Midofthree(a, left, right, (right + left) / 2);<br>	Swap(&a[x], &a[left]);<br>	int key = a[left];<br>	int pit = left;<br>	int begin = left;<br>	int end = right;<br>	while (begin < end)<br>	{<br>		while (a[end] >= key && begin < end)<br>			end--;<br><br>		a[pit] = a[end];<br>		pit = end;<br><br>		while (a[begin] <= key && begin < end)<br>			begin++;<br>		<br>		a[pit] = a[begin];<br>		pit = begin;<br>	}<br>	a[pit] = key;<br>	return pit;<br>}</code></pre> <br><h4>递归：</h4> <br><pre><code class="language-cpp">void QuickSort(int* a, int left, int right)<br>{<br>	if (left >= right)<br>		return;<br>	if (right - left + 1 < 10)<br>	{<br>		InsertSort(a + left, right - left + 1);//小区间优化<br>		return;<br>	}<br><br>	int keyi = partsort1(a, left, right);<br><br>	QuickSort(a, left, keyi - 1);<br>	QuickSort(a, keyi + 1, right);<br>}</code></pre> <br><h4>非递归： </h4> <br><p>这里不一定要用栈，也可以用队列来存储，如果你想，甚至可以用顺序表。栈只是为了更好的模拟递归的过程。</p> <br><p><a href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88" rel="nofollow" title="function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)">function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</a></p> <br><pre><code class="language-cpp">void QuickSortNonR(int* a, int left, int right)<br>{<br>	ST s;<br>	STInit(&s);<br>	STPush(&s, right);<br>	STPush(&s, left);<br><br> 	while (!STEmpty(&s))<br>	{<br>		int begin = STTop(&s);<br>		STPop(&s);<br>		int end = STTop(&s);<br>		STPop(&s);<br><br>		int mid = partsort1(a, begin, end);<br>		if (mid + 1 < end)//注意这里需判断<br>		{<br>			STPush(&s, end);<br>			STPush(&s, mid + 1);<br>		}<br>		if (begin < mid - 1)//注意这里需判断<br>		{<br>			STPush(&s, mid - 1);<br>			STPush(&s, begin);<br>		}<br>	}<br>}</code></pre> <br><h2>归并排序</h2> <br><h3>示意图：</h3> <br><p><img alt="" height="505" src="https://i-blog.csdnimg.cn/blog_migrate/ecbf7472e657c8c37687429d84d84e0c.gif" width="811" /></p> <br><h3><strong>排序过程：</strong></h3> <br><h3><img alt="" height="442" src="https://i-blog.csdnimg.cn/blog_migrate/840e9b8db3903be8ac9ddf07e6656198.png" width="1200" /></h3> <br><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p> <br><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul> <br><h3><strong>时间复杂度：</strong></h3> <br><p><span style="color:#be191c;"><strong>O(n*log(n))</strong></span></p> <br><h3><strong>代码实现： </strong></h3> <br><p>递归：</p> <br><pre><code class="language-cpp">void _MergeSort(int* a, int* tmp, int left, int right)<br>{<br>	if (left >= right)<br>		return;<br>	int mid = (left + right) / 2;<br>	_MergeSort(a, tmp, left, mid);<br>	_MergeSort(a, tmp, mid + 1, right);<br><br>	int begin1 = left, end1 = mid;<br>	int begin2 = mid + 1, end2 = right;<br>	int i = left;<br>	while (begin1 <= end1 && begin2 <= end2)<br>	{<br>		if(a[begin1] < a[begin2])<br>			tmp[i++] = a[begin1++];<br>		else<br>			tmp[i++] = a[begin2++];<br>	}<br>	while (begin1 <= end1)<br>		tmp[i++] = a[begin1++];<br><br>	while (begin2 <= end2)<br>		tmp[i++] = a[begin2++];<br>	<br>	memcpy(a + left, tmp + left, sizeof(int) * (right - left + 1));<br>}<br><br><br>void MergeSort(int* a, int n)<br>{<br>	int* tmp = (int*)malloc(sizeof(int) * n);<br>	if (tmp == NULL)<br>	{<br>		perror("malloc is fail");<br>		return;<br>	}<br>	_MergeSort(a, tmp, 0, n - 1);<br><br>	free(tmp);<br>	tmp = NULL;<br>}</code></pre> <br><p>非递归</p> <br><pre><code class="language-cpp">void MergeSortNonR(int* a, int n)<br>{<br>	int* tmp = (int*)malloc(sizeof(int) * n);<br>	if (tmp == NULL)<br>	{<br>		perror("malloc is fail");<br>		return;<br>	}<br>	int gap = 1;<br>	while (gap < n)<br>	{<br>		for (int i = 0; i < n; i += 2 * gap)<br>		{<br>			int begin1 = i, end1 = i + gap - 1;<br>			int begin2 = i + gap, end2 = i + 2 * gap - 1;<br>			int j = i;<br>			if (begin2 >= n)<br>				break;<br>			if (end2 >= n)<br>				end2 = n - 1;<br>			while (begin1 <= end1 && begin2 <= end2)<br>			{<br>				if (a[begin1] <= a[begin2])<br>					tmp[j++] = a[begin1++];<br>				else<br>					tmp[j++] = a[begin2++];<br>			}<br>			while (begin1 <= end1)<br>				tmp[j++] = a[begin1++];<br><br>			while (begin2 <= end2)<br>				tmp[j++] = a[begin2++];<br><br>			memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1));<br>		}<br>		gap *= 2;<br>	}<br>	free(tmp);<br>	tmp = NULL;<br>}<br></code></pre> <br><h2><strong>计数排序</strong></h2> <br><h3><strong>示意图：</strong></h3> <br><p><img alt="" height="557" src="https://i-blog.csdnimg.cn/blog_migrate/c12f96bab150ceb656315d1846678afd.gif" width="1012" /></p> <br><h3>排序过程：</h3> <br><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<span style="color:#be191c;"><strong>确定范围的整数</strong></span>。这就导致了这个排序算法</p> <br><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul> <br><h3><span style="color:#be191c;">时间复杂度：</span></h3> <br><p> 在理想情况下，这个排序算法的时间复杂度能达到O(n)，非常的快。</p> <br><h3>代码实现：</h3> <br><pre><code class="language-cpp">void CountSort(int* a, int n)<br>{<br>	int min = a[0];<br>	int max = a[0];<br>	for (int i = 0; i < n; i++)<br>	{<br>		if (a[i] > max)<br>			max = a[i];<br>		if (a[i] < min)<br>			min = a[i];<br>	}<br>	int range = max - min + 1;<br>	int* x = (int*)calloc(range, sizeof(int));<br>	if (x == NULL)<br>	{<br>		perror("calloc is fail");<br>		return;<br>	}<br>	for (int i = 0; i < n; i++)<br>		x[a[i] - min]++;<br><br>	int j = 0;<br>	for (int i = 0; i < n; i++)<br>		while (x[i]--)<br>			a[j++] = i + min;<br><br>	free(x);<br>}</code></pre> <br><h2>总结： </h2> <br><p>上面的排序分别对同样的十万个随机数进行排序，所消耗的时间如下图：（ps:仅供参考）</p> <br><p><img alt="" height="293" src="https://i-blog.csdnimg.cn/blog_migrate/56c58182cdd25d4eb418e98633c04c37.png" width="339" /></p> <br><p><img alt="" height="510" src="https://i-blog.csdnimg.cn/blog_migrate/2ea32a45dd8c6fb993170866cb836e6e.png" width="1092" /></p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>