<blockquote> <br> <p style="text-align:center"><img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/a46182e6318c4593a5c674f2bf9439d4.jpeg" width="1024" /></p> <br> <p style="text-align:center">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12799988.html" title="Linux">Linux</a>✨✨</p> <br> <p style="text-align:center">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2 style="background-color:transparent"> 理解硬件</h2> <br><h3 style="background-color:transparent">磁盘</h3> <br><p>磁盘，顾名思义就是用磁性来存储信息的。磁盘是一种永久性存储介质，在计算机中，磁盘几乎是唯一的机械设备。与磁盘相对应的就是内存，但是内存是掉电易失存储介质，所以目前所有的普通文件都是在磁盘中存储的。</p> <br><h3 style="background-color:transparent">基本结构</h3> <br><p class="img-center"><img alt="" height="596" src="https://i-blog.csdnimg.cn/direct/24468427d542408685cbb16edc7f96de.png" width="1097" /></p> <br><ul><li>磁盘是一个块（block）设备，<span style="color:#1f2329">扇区是从磁盘读出和写⼊信息的最⼩单位，通常⼤⼩为 512 字节。 </span></li><li><span style="color:#1f2329">磁头（head）数：每个盘⽚⼀般有上下两⾯，分别对应1个磁头，共2个磁头 </span></li><li><span style="color:#1f2329">磁道（track）数：磁道是从盘⽚外圈往内圈编号0磁道，1磁道...，靠近主轴的同⼼圆⽤于停靠磁</span><span style="color:#1f2329">头，不存储数据</span></li><li><span style="color:#1f2329">柱⾯（cylinder）数：磁道构成柱⾯，数量上等同于磁道个数 </span></li><li><span style="color:#1f2329">扇区（sector）数：每个磁道都被切分成很多扇形区域，每道的扇区数量相同 </span></li><li><span style="color:#1f2329">圆盘（platter）数：就是盘⽚的数量 </span></li><li><span style="color:#1f2329">磁盘容量=磁头数 × 磁道(柱⾯)数 × 每道扇区数 × 每扇区字节数 </span></li><li><span style="color:#1f2329">细节：</span><span style="color:#b95514"><strong>传动臂上的磁头是共进退的</strong></span></li></ul> <br><h3>CHS寻址 </h3> <br><p>那么我们如何定位一个扇区呢？<span style="color:#b95514"><strong>（CHS地址定位）</strong></span></p> <br><ol><li>定位磁头（head）</li><li>确定磁头要访问哪一个柱面（磁道）（cylinder）</li><li>定位扇区（sector）</li></ol> <br><p>对于CHS寻址，系统用8bit来存储磁头地址，用10bit来存储柱面地址，用6bit来存储扇区地址，一个扇区的容量为512Byte，那么用CHS寻址一块硬盘的最大容量为（256*1024*63*512B）/（1024*1024）=8064MB（若1MB=<span style="color:#1f2329">1000000B就是8.4GB</span>）这显然不满足当今计算机对硬盘的要求。</p> <br><h3>LBA寻址（Logical Block Addressing）</h3> <br><p>我们知道，一个磁道上有很多扇区，我们把一个磁道的扇区从1编号然后把它们展开：</p> <br><p class="img-center"><img alt="" height="307" src="https://i-blog.csdnimg.cn/direct/c65ea31864e440948f19903f29226425.png" width="1677" /></p> <br><p>然后磁盘的一个柱面有许多个盘面，也就有许多的磁道，我们把这<span style="color:#b95514"><strong>一个柱面的所有磁道里的扇区全部展开排列，其实就是一个二维数组。</strong></span></p> <br><p class="img-center"><img alt="" height="442" src="https://i-blog.csdnimg.cn/direct/a355b529f4734ae48bb345993c5d4561.png" width="705" /></p> <br><p class="img-center"><img alt="" height="560" src="https://i-blog.csdnimg.cn/direct/5024c56355e14cecb39d2bdfb1fb4deb.png" width="1091" /></p> <br><p>之后，在每一个盘面上不止有一圈磁道，尽管是内外圈，但是它们的扇区数量一般是一样的。我们把所有柱面的所有磁道里面的所有扇区全部展开：</p> <br><p class="img-center"><img alt="" height="1196" src="https://i-blog.csdnimg.cn/direct/200c99fa70534449ba80f926118537ab.png" width="772" /></p> <br><p> </p> <br><p>这就是一个三维数组，所以CHS寻址寻找一个扇区就是找到这个三维数组的三个下标。</p> <br><p>我们有了C/C++的基础，在我们看来，多维数组其本质就是一维数组，在这个一维数组里，每一个扇区都有且只有一个独立编号，这个编号就是LBA地址。操作系统只需要知道LBA地址，然后由磁盘转化为CHS地址</p> <br><h3>CHS和LBA的转化</h3> <br><h4>CHS->LBA</h4> <br><ul><li>磁头数*每磁道扇区数 = 单个柱⾯的扇区总数</li><li>LBA = 柱⾯号C*单个柱⾯的扇区总数 + 磁头号H*每磁道扇区数 + 扇区号S - 1</li><li>即：LBA = 柱⾯号C*(磁头数*每磁道扇区数) + 磁头号H*每磁道扇区数 + 扇区号S - 1</li><li>扇区号通常是从1开始的，⽽在LBA中，地址是从0开始的</li><li>柱⾯和磁道都是从0开始编号的</li><li>总柱⾯，磁道个数，扇区总数等信息，在磁盘内部会⾃动维护，上层开机的时候，会获取到这些参数。</li></ul> <br><h4>LBA->CHS</h4> <br><ul><li><span style="color:#1f2329">柱⾯号C = LBA // (磁头数*每磁道扇区数)【就是单个柱⾯的扇区总数】 </span></li><li><span style="color:#1f2329">磁头号H = (LBA % (磁头数*每磁道扇区数)) // 每磁道扇区数 </span></li><li><span style="color:#1f2329">扇区号S = (LBA % 每磁道扇区数) + 1 </span></li><li><span style="color:#1f2329">"//": 表示除取整</span></li></ul> <br><p><span style="color:#1f2329">其实这和三维数组和一维数组的转化原理一样。</span></p> <br><p> <span style="color:#1f2329">所以：从此往后，在磁盘使⽤者看来，根本就不关⼼CHS地址，⽽是直接使⽤LBA地址，磁盘内部⾃⼰转换。所以：从现在开始，磁盘就是⼀个元素为扇区的⼀维数组，数组的下标就是每⼀个扇区的LBA地址。OS使⽤磁盘，就可以⽤⼀个数字访问磁盘扇区了。</span>   </p> <br><h2 style="background-color:transparent"> EXT2文件系统</h2> <br><h3>“块”</h3> <br><p>其实磁盘是典型的块设备，操作系统与磁盘的IO其实不是以扇区为单位的，而是以一个“块”（block）为单位。常见的是以8个扇区为一个“块”，也就是4KB，“块”是文件存取的最小单位。</p> <br><ul><li><span style="color:#0d0016"><strong>磁盘是一个三维数组，我们把它看作一维数组，数组的下标就是LBA地址，每个元素就是扇区。</strong></span></li><li><span style="color:#0d0016"><strong>每个扇区都有LBA地址，那么8个扇区一个“块”，每一个块的地址也能算出来。</strong></span></li><li><span style="color:#0d0016"><strong>LBA = 快号 * 8 + n(块内部的第n个扇区)</strong></span></li></ul> <br><h3>“分区” </h3> <br><p>磁盘是可以被分成多个区域的，在windows中，我们把磁盘分为C、D、E盘。C、D、E各个盘就是分区。分区其实就是对磁盘的一种格式化。那么在Linux下是怎么分区的嘞？</p> <br><p>其实柱面是分区的最小单位，我们利用参考柱面号码的方式来分区。其实就是设置每个分区的开始和结束柱面号。柱面大小一致，柱面里的扇区大小、个数一致。只需要知道起始柱面号和结束柱面号，知道一个柱面多少扇区，每个扇区多大，那么分区的大小和LBA也就清楚了。</p> <br><h3 style="background-color:transparent">“inode”</h3> <br><p>之前我们说，文件 = 属性 + 数据，我们使用ls -l 的时候除了看到文件名，还能看到文件属性：</p> <br><pre><code class="language-cpp">ubuntu@VM-4-4-ubuntu:~$ ls -l<br>total 4<br>drwxrwxr-x 12 ubuntu ubuntu 4096 Jan 18 23:32 Code<br>   |       |     |     |     |        |         |<br>   |       |     |     |     |        |         |<br>  权限 硬链接数 所有者  所属组  大小   最后修改时间  文件名</code></pre> <br><p>这个过程是读取磁盘上的信息然后显示出来</p> <br><p class="img-center"><img alt="" height="449" src="https://i-blog.csdnimg.cn/direct/0358221e95cc49e39f8fa6ffa23c5c66.png" width="561" /></p> <br><p>还有一个命令能够看到更多文件属性信息：stat</p> <br><pre><code class="language-cpp">ubuntu@VM-4-4-ubuntu:~$ stat Code<br>  File: Code<br>  Size: 4096      	Blocks: 8          IO Block: 4096   directory<br>Device: 253,2	Inode: 524305      Links: 12<br>Access: (0775/drwxrwxr-x)  Uid: ( 1000/  ubuntu)   Gid: ( 1000/  ubuntu)<br>Access: 2025-01-18 23:32:28.245182658 +0800<br>Modify: 2025-01-18 23:32:19.021839203 +0800<br>Change: 2025-01-18 23:32:19.021839203 +0800<br> Birth: 2024-11-08 22:16:06.255019588 +0800</code></pre> <br><p><span style="color:#0d0016">那么，文件数据都储存在“块”中，那么文件的属性（创建者、创建日期、文件大小）存储在哪里呢？</span><strong><span style="color:#be191c">inode </span></strong><span style="color:#0d0016">中文译为“索引节点”，通过ls -li查看inode编号：</span></p> <br><pre><code class="language-cpp">ubuntu@VM-4-4-ubuntu:~$ ls -il<br>total 4<br>524305 drwxrwxr-x 12 ubuntu ubuntu 4096 Jan 18 23:32 Code<br>   |<br>   |<br>inode_number</code></pre> <br><ul><li>每个文件都有对应的inode，里面包含了与该文件有关的一些信息。</li><li>Linux下文件的存储时属性和内容分离的。</li><li>Linux下，保存文件属性的集合叫inode，一个文件，一个inode，inode内部由一个唯一标识符，叫inode号（inode_number）【其实这个号码只在当前分区是唯一的】</li></ul> <br><pre><code class="language-cpp">/*<br> * Structure of an inode on the disk<br> */<br>struct ext2_inode {<br>	__u16	i_mode;		/* File mode */<br>	__u16	i_uid;		/* Owner Uid */<br>	__u32	i_size;		/* Size in bytes */<br>	__u32	i_atime;	/* Access time */<br>	__u32	i_ctime;	/* Creation time */<br>	__u32	i_mtime;	/* Modification time */<br>	__u32	i_dtime;	/* Deletion Time */<br>	__u16	i_gid;		/* Group Id */<br>	__u16	i_links_count;	/* Links count */<br>	__u32	i_blocks;	/* Blocks count */<br>	__u32	i_flags;	/* File flags */<br>	union {<br>		struct {<br>			__u32  l_i_reserved1;<br>		} linux1;<br>		struct {<br>			__u32  h_i_translator;<br>		} hurd1;<br>		struct {<br>			__u32  m_i_reserved1;<br>		} masix1;<br>	} osd1;				/* OS dependent 1 */<br>	__u32	i_block[EXT2_N_BLOCKS];/* Pointers to blocks */<br>	__u32	i_version;	/* File version (for NFS) */<br>	__u32	i_file_acl;	/* File ACL */<br>	__u32	i_dir_acl;	/* Directory ACL */<br>	__u32	i_faddr;	/* Fragment address */<br>	union {<br>		struct {<br>			__u8	l_i_frag;	/* Fragment number */<br>			__u8	l_i_fsize;	/* Fragment size */<br>			__u16	i_pad1;<br>			__u32	l_i_reserved2[2];<br>		} linux2;<br>		struct {<br>			__u8	h_i_frag;	/* Fragment number */<br>			__u8	h_i_fsize;	/* Fragment size */<br>			__u16	h_i_mode_high;<br>			__u16	h_i_uid_high;<br>			__u16	h_i_gid_high;<br>			__u32	h_i_author;<br>		} hurd2;<br>		struct {<br>			__u8	m_i_frag;	/* Fragment number */<br>			__u8	m_i_fsize;	/* Fragment size */<br>			__u16	m_pad1;<br>			__u32	m_i_reserved2[2];<br>		} masix2;<br>	} osd2;				/* OS dependent 2 */<br>};</code></pre> <br><ul><li><span style="color:#b95514"><strong>文件名并未储存在inode内部。(文件名大小不定，不方便inode的统一管理)</strong></span></li><li><span style="color:#b95514"><strong>inode大小一般是128字节或256字节，我们统一认为是128字节。</strong></span></li><li><span style="color:#b95514"><strong>任何文件的内容大小可以不同，但是属性大小一定是相同的。</strong></span></li></ul> <br><h3 style="background-color:transparent">宏观认识</h3> <br><p class="img-center"><img alt="" height="1251" src="https://i-blog.csdnimg.cn/direct/8466299f2a0d4b78ab28f6b0e96e227d.png" width="1678" /></p> <br><h3> 超级块（Super block）</h3> <br><p>存放文件系统本身的结构信息，<span style="color:#b95514"><strong>描述整个分区的文件系统信息。</strong></span>主要信息有：block和inode的总量，未使用的block和inode数量，一个block和inode的大小，最近一次挂载时间，最近一次写入数据时间，最近一次检验磁盘的时间等其他文件系统相关的信息。Super Block的信息被破坏了，可以说整个文件系统就被破坏了。</p> <br><p>Super Block在每个块组的开头都有一份拷<span style="color:#646a73">⻉（第⼀个块组必须有，后⾯的块组可以没有）。 为了保证⽂件系统在磁盘部分扇区出现物理问题的情况下还能正常⼯作，就必须保证⽂件系统的</span>Super Block<span style="color:#646a73">信息在这种情况下也能正常访问。所以⼀个⽂件系统的</span>Super Block<span style="color:#646a73">会在多个Block Group中进⾏备份，这些</span>Super Block<span style="color:#646a73">区域的数据保持⼀致。</span></p> <br><pre><code class="language-cpp">/*<br> * Structure of the super block<br> */<br>struct ext2_super_block {<br>	__u32	s_inodes_count;		/* Inodes count */<br>	__u32	s_blocks_count;		/* Blocks count */<br>	__u32	s_r_blocks_count;	/* Reserved blocks count */<br>	__u32	s_free_blocks_count;	/* Free blocks count */<br>	__u32	s_free_inodes_count;	/* Free inodes count */<br>	__u32	s_first_data_block;	/* First Data Block */<br>	__u32	s_log_block_size;	/* Block size */<br>	__s32	s_log_frag_size;	/* Fragment size */<br>	__u32	s_blocks_per_group;	/* # Blocks per group */<br>	__u32	s_frags_per_group;	/* # Fragments per group */<br>	__u32	s_inodes_per_group;	/* # Inodes per group */<br>	__u32	s_mtime;		/* Mount time */<br>	__u32	s_wtime;		/* Write time */<br>	__u16	s_mnt_count;		/* Mount count */<br>	__s16	s_max_mnt_count;	/* Maximal mount count */<br>	__u16	s_magic;		/* Magic signature */<br>	__u16	s_state;		/* File system state */<br>	__u16	s_errors;		/* Behaviour when detecting errors */<br>	__u16	s_minor_rev_level; 	/* minor revision level */<br>	__u32	s_lastcheck;		/* time of last check */<br>	__u32	s_checkinterval;	/* max. time between checks */<br>	__u32	s_creator_os;		/* OS */<br>	__u32	s_rev_level;		/* Revision level */<br>	__u16	s_def_resuid;		/* Default uid for reserved blocks */<br>	__u16	s_def_resgid;		/* Default gid for reserved blocks */<br>	/*<br>	 * These fields are for EXT2_DYNAMIC_REV superblocks only.<br>	 *<br>	 * Note: the difference between the compatible feature set and<br>	 * the incompatible feature set is that if there is a bit set<br>	 * in the incompatible feature set that the kernel doesn't<br>	 * know about, it should refuse to mount the filesystem.<br>	 * <br>	 * e2fsck's requirements are more strict; if it doesn't know<br>	 * about a feature in either the compatible or incompatible<br>	 * feature set, it must abort and not try to meddle with<br>	 * things it doesn't understand...<br>	 */<br>	__u32	s_first_ino; 		/* First non-reserved inode */<br>	__u16   s_inode_size; 		/* size of inode structure */<br>	__u16	s_block_group_nr; 	/* block group # of this superblock */<br>	__u32	s_feature_compat; 	/* compatible feature set */<br>	__u32	s_feature_incompat; 	/* incompatible feature set */<br>	__u32	s_feature_ro_compat; 	/* readonly-compatible feature set */<br>	__u32	s_reserved[230];	/* Padding to the end of the block */<br>};</code></pre> <br><h3>GDT（Group Descr

iptor Table）</h3> <br><p>块<span style="color:#1f2329">块组描述符表，</span><span style="color:#b95514"><strong>描述块组属性信息</strong></span><span style="color:#1f2329">，整个分区分成多个块组就对应有多少个块组描述符。每个块组描述符存储⼀个块组的描述信息，如在这个块组中从哪⾥开始是inode Table，从哪⾥开始是Data Blocks，空闲的inode和数据块还有多少个等等。块组描述符在每个块组的开头都有⼀份拷⻉。</span></p> <br><pre><code class="language-cpp">/*<br> * Structure of a blocks group descriptor<br> */<br>struct ext2_group_desc<br>{<br>	__u32	bg_block_bitmap;		/* Blocks bitmap block */<br>	__u32	bg_inode_bitmap;		/* Inodes bitmap block */<br>	__u32	bg_inode_table;		/* Inodes table block */<br>	__u16	bg_free_blocks_count;	/* Free blocks count */<br>	__u16	bg_free_inodes_count;	/* Free inodes count */<br>	__u16	bg_used_dirs_count;	/* Directories count */<br>	__u16	bg_pad;<br>	__u32	bg_reserved[3];<br>};</code></pre> <br><h3 style="background-color:transparent">块位图（Block Bitmap）</h3> <br><ul><li>Block Bitmap中记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用</li></ul> <br><h3>inode位图（Inode Bitmap）</h3> <br><ul><li>每个bit表示一个inode是否闲置可用。</li></ul> <br><h3>i节点表（inode Table）</h3> <br><ul><li>存放文件属性，如文件大小，所有者，最近修改时间等。</li><li>当前分组的所有inode属性的集合。</li><li><span style="color:#b95514">inode编号以分区为单位，整体划分，不可跨分区。</span></li></ul> <br><h3>Data Block</h3> <br><ul><li>数据区，存放文件内容，也就是一个一个的Block。根据不同的文件类型有以下几种情况：</li><li>对于普通文件文件的数据存储在数据块中。</li><li>对于目录，该目录下的所有文件名和目录名就相当于这个目录的数据存储在所在目录的数据块中，除了文件名外，ls -l命令看到的其他信息保存在该文件的inode中。</li><li>Block号按照分区划分，不可跨分区。</li></ul> <br><h3 style="background-color:transparent"> inode与Data Block映射</h3> <br><p>inode内部存在 __u32    i_block[EXT2_N_BLOCKS]<span style="color:#1f2329">]; /* Pointers to blocks */</span></p> <br><p><span style="color:#1f2329">这个就是用来进行inode和Data block映射的，这样找到了文件属性就能找到文件内容。</span></p> <br><p class="img-center"><img alt="" height="796" src="https://i-blog.csdnimg.cn/direct/e85fde37dcb24cda88418a8b2c6a0f2c.png" width="1234" /></p> <br><p>分区之后<strong><span style="color:#b95514">的格式化操作</span></strong>，就是对分区进行分组，在每个分组中写入SB、GDT、Block、Bitmap、Inode Bitmap等管理信息，<span style="color:#b95514"><strong>这些管理信息统称为：文件系统</strong></span></p> <br><p>知道了inode号，<span style="color:#1f2329">就能在指定分区中确定是哪⼀个分组，进⽽在哪⼀个分组确定是哪⼀个inode，之后文件的属性和内容就全都有了。</span></p> <br><h3>目录与文件名</h3> <br><p><span style="color:#b95514"><strong>目录也是文件，磁盘上根本没有目录的概念，只有文件属性+文件内容。目录的属性就是那些，内容保存的是文件名和inode号的映射关系。</strong></span></p> <br><p>用户在访问文件时不会用inode号，都是用的文件名。访问文件，先打开当前目录，根据文件名，获得inode号，进行文件访问。所以知道当前的工作目录是很重要的。</p> <br><h3>路径解析</h3> <br><p>那么要访问当前目录也需要知道inode号呀。当前目录的inode号在上级目录里，上级的在上上级里面。递归下去，就到了根目录“/”</p> <br><p><strong>实际上任何文件都有路径，访问一个 /home/ubuntu/Code/test.c 文件都要从根目录开始，依次打开每个目录，根据目录名，依次访问每个目录下指定的目录，直到访问到 test.c 这个过程叫做Liunx路径解析。</strong></p> <br><p>所以访问文件必须要路径（ = 目录+文件名）的原因</p> <br><p><strong>用户访问文件，本质都是进程在访问，进程都有 cwd 进程提供路径。我们open文件时也提供了路径。那么最开始的路径从哪里来？根目录 根目录固定文件名、inode号，无需查找，系统开机后就知道。</strong></p> <br><p>我们新建目录，其实就是在磁盘文件系统中新建目录文件。我们新建的目录或者文件都是在系统指定的目录下新建的，所以路径就是这么来的。系统 + 用户共同构建Linux的路径结构。</p> <br><h3>路径缓存</h3> <br><p>Linux下根本不存在目录，只有文件属性+文件内容。</p> <br><p>访问任何文件都要从根目录开始解析吗？这未免也太慢了吧？</p> <br><p>Linux会缓存历史路径结构，如果打开的文件时目录，OS会在内存中进行路径维护</p> <br><p>维护树状的路径结构的内核结构体：<span style="color:#b95514"><strong>struct dentry</strong></span></p> <br><pre><code class="language-cpp">struct dentry {<br>	atomic_t d_count;<br>	unsigned int d_flags;		/* protected by d_lock */<br>	spinlock_t d_lock;		/* per dentry lock */<br>	struct inode *d_inode;		/* Where the name belongs to - NULL is<br>					 * negative */<br>	/*<br>	 * The next three fields are touched by __d_lookup.  Place them here<br>	 * so they all fit in a cache line.<br>	 */<br>	struct hlist_node d_hash;	/* lookup hash list */<br>	struct dentry *d_parent;	/* parent directory */<br>	struct qstr d_name;<br><br>	struct list_head d_lru;		/* LRU list */<br>	/*<br>	 * d_child and d_rcu can share memory<br>	 */<br>	union {<br>		struct list_head d_child;	/* child of parent list */<br>	 	struct rcu_head d_rcu;<br>	} d_u;<br>	struct list_head d_subdirs;	/* our children */<br>	struct list_head d_alias;	/* inode alias list */<br>	unsigned long d_time;		/* used by d_revalidate */<br>	struct dentry_operations *d_op;<br>	struct super_block *d_sb;	/* The root of the dentry tree */<br>	void *d_fsdata;			/* fs-specific data */<br>#ifdef CONFIG_PROFILING<br>	struct dcookie_struct *d_cookie; /* cookie, if any */<br>#endif<br>	int d_mounted;<br>	unsigned char d_iname[DNAME_INLINE_LEN_MIN];	/* small names */<br>};</code></pre> <br><ul><li><span style="color:#0d0016"><strong>每个文件其实都要有对应的dentry结构，包括普通文件。这样被打开的文件，就可以在内存中形成整个树形结构</strong></span></li><li><span style="color:#0d0016"><strong>整个树形节点也同时会⾪属于LRU(Least Recently Used，最近最少使⽤)结构中，进⾏节点淘汰</strong></span></li><li><span style="color:#0d0016"><strong>整个树形节点也同时会⾪属于Hash，⽅便快速查找</strong></span></li><li><span style="color:#0d0016"><strong>更重要的是，这个树形结构，整体构成了Linux的路径缓存结构，打开访问任何⽂件，都在先在这棵树下根据路径进⾏查找，找到就返回属性inode和内容，没找到就从磁盘加载路径，添加dentry结构，缓存新路径</strong></span></li></ul> <br><h3 style="background-color:transparent">挂载分区</h3> <br><p>我们能根据inode在指定分区找文件，能根据目录文件内容找到指定的inode，在分区内为所欲为。</p> <br><p>但是Linux可能有多个分区，Block_Group_number和inode_number直在一个分区内唯一。我怎么知道我要找的文件在哪个分区？</p> <br><p><span style="color:#b95514"><strong>分区写⼊⽂件系统，⽆法直接使⽤，需要和指定的⽬录关联，进⾏挂载才能使用。所以，可以根据访问⽬标⽂件的"路径前缀"准确判断我在哪⼀个分区。  </strong></span></p> <br><h2>软硬链接</h2> <br><h3>硬链接</h3> <br><p><span style="color:#1f2329">我们看到，真正找到磁盘上⽂件的并不是⽂件名，⽽是inode。其实在linux中可以让多个⽂件名对应于同⼀个inode。</span></p> <br><pre><code class="language-cpp">[root@localhost linux]# touch abc<br>[root@localhost linux]# ln abc def<br>[root@localhost linux]# ls -li abc def<br>263466 abc<br>263466 def</code></pre> <br><ul><li><span style="color:#b95514">abc和def的链接状态完全相同，他们被称为指向⽂件的硬链接。内核记录了这个连接数，inode 263466 的硬连接数为2。 </span></li><li><span style="color:#b95514">我们在删除⽂件时⼲了两件事情：1.在⽬录中将对应的记录删除，2.将硬连接数-1，如果为0，则 将对应的磁盘释放。</span></li><li><span style="color:#b95514"> . 和 .. 就是硬链接，硬链接可以做文件备份。</span></li></ul> <br><h3>软连接</h3> <br><div> <br> <span style="color:#1f2329">硬链接是通过inode引⽤另外⼀个⽂件，软链接是通过名字引⽤另外⼀个⽂件，</span> <br> <span style="color:#b95514"><strong>但实际上，新的⽂件和被引⽤的⽂件的inode不同，应⽤常⻅上可以想象成⼀个快捷⽅式。</strong></span> <br> <span style="color:#1f2329">在shell中的做法。</span> <br></div> <br><div> <br> <pre><code class="language-cpp">[root@localhost linux]# ln -s abc.s abc<br>[root@localhost linux]# ls -li<br>263563 -rw-r--r--. 2 root root 0 9⽉ 15 17:45 abc<br>261678 lrwxrwxrwx. 1 root root 3 9⽉ 15 17:53 abc.s -> abc<br>263563 -rw-r--r--. 2 root root 0 9⽉ 15 17:45 def</code></pre> <br> <h2>文件时间（ACM）</h2> <br> <ul><li><code>Access</code>： 文件最后被访问的时间。</li><li><code>Modify</code>： 文件内容最后的修改时间。</li><li><code>Change</code>： 文件属性最后的修改时间。</li></ul> <br> <h2>Linux下一切皆文件</h2> <br> <p class="img-center"><img alt="" height="415" src="https://i-blog.csdnimg.cn/direct/4b6582965ec74ba2a4ccf129309ec88a.png" width="1059" /></p> <br></div> <br><p><span style="color:#0d0016"><strong>上图中的外设，每个设备都可以有⾃⼰的read、write，但⼀定是对应着不同的操作⽅法！！但通过 struct file 下 file_operation 中的各种函数回调，让我们开发者只⽤file便可调取 Linux 系统中绝⼤部分的资源！！这便是“linux下⼀切皆⽂件”的核⼼理解。</strong></span></p> <br><p><span style="color:#0d0016"><strong>这种实现方式与C++中的多态类似。在 C++中，父类指针指向谁，调用的就是谁的方法。在 C 语言中，可以通过函数指针做到指向不同的对象时执行不同的方法，实现多态的性质。在Linux中，每个struct file中包含很多函数指针，这样在struct file上层看来，所有的文件都是调用统一的接口，而在底层则通过函数指针指向不同硬件的方法，实现与具体硬件对应的逻辑。</strong></span></p> <br><p style="text-align:center"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>

