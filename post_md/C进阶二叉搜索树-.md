<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/9e66b67c73ef431f887a88a78f972ea7.png" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2> ⼆叉搜索树的概念</h2> <br><p>⼆叉搜索树⼜称⼆叉排序树，它或者是⼀棵空树，或者是具有以下性质的⼆叉树:  </p> <br><blockquote> <br> <p>• 若它的左⼦树不为空，则左⼦树上所有结点的值都⼩于等于根结点的值</p> <br> <p>• 若它的右⼦树不为空，则右⼦树上所有结点的值都⼤于等于根结点的值</p> <br> <p>• 它的左右⼦树也分别为⼆叉搜索树</p> <br></blockquote> <br><pre><code class="language-cpp">template<class K><br>struct BSNode<br>{<br>	BSNode(const K& key)<br>	{<br>		_key = key;<br>		_left = nullptr;<br>		_right = nullptr;<br>	}<br>	struct BSNode* _left;<br>	struct BSNode* _right;<br>	K _key;<br>};</code></pre> <br><pre><code class="language-cpp">template<class K><br>class BSTree<br>{<br>	typedef struct BSNode<K> Node;<br>public:<br>    // 函数<br>private:<br>	Node* _root = nullptr;<br>};</code></pre> <br><p>⼆叉搜索树中可以⽀持插⼊相等的值，也可以不⽀持插⼊相等的值，具体看使⽤场景定义，后续学习map/set/multimap/multiset系列容器底层就是⼆叉搜索树，其中map/set不⽀持插⼊相等值，multimap/multiset⽀持插⼊相等值。</p> <br><p><img alt="" height="491" src="https://i-blog.csdnimg.cn/direct/2a823e5b6f314333b0431644a8e038e0.png" width="781" /></p> <br><h2>⼆叉搜索树的性能分析</h2> <br><blockquote> <br> <p>最优情况下，⼆叉搜索树为完全⼆叉树(或者接近完全⼆叉树)，其⾼度为： O(lgN) </p> <br> <p>最差情况下，⼆叉搜索树退化为单⽀树(或者类似单⽀)，其⾼度为： O(N/2) </p> <br> <p>所以综合⽽⾔⼆叉搜索树增删查改时间复杂度为： O(N)</p> <br></blockquote> <br><p>那么这样的效率显然是⽆法满⾜我们需求的，后续需要继续了解⼆叉搜索树的变形，平衡⼆叉搜索树AVL树和红⿊树，才能适⽤于我们在内存中存储和搜索数据。</p> <br><p>另外，⼆分查找也可以实现O(logN) 级别的查找效率，但是⼆分查找有两⼤缺陷：</p> <br><p>1. 需要存储在<span style="color:#be191c;"><strong>⽀持下标随机访问</strong></span>的结构中，并且<span style="color:#be191c;"><strong>有序</strong></span>。</p> <br><p>2. <span style="color:#be191c;"><strong>插⼊和删除数据效率很低</strong></span>，因为存储在下标随机访问的结构中，插⼊和删除数据⼀般需要挪动数 据。 这⾥也就体现出了平衡⼆叉搜索树的价值。 </p> <br><p><img alt="" height="546" src="https://i-blog.csdnimg.cn/direct/a63a17313feb4c429488a133423dc67f.png" width="664" /></p> <br><p>⼆叉搜索树的插⼊</p> <br><p>插⼊的具体过程如下：</p> <br><blockquote> <br> <p>1. 树为空，则直接新增结点，赋值给root指针</p> <br> <p>2. 树不空，按⼆叉搜索树性质，插⼊值⽐当前结点⼤往右⾛，插⼊值⽐当前结点⼩往左⾛，找到空位置，插⼊新结点。</p> <br> <p>3. 如果⽀持插⼊相等的值，插⼊值跟当前结点相等的值可以往右⾛，也可以往左⾛，找到空位置，插 ⼊新结点。（要注意的是要保持逻辑⼀致性，插⼊相等的值不要⼀会往右⾛，⼀会往左⾛） </p> <br></blockquote> <br><pre><code class="language-cpp">bool Insert(const K& key)<br>	{<br>		Node* newnode = new Node(key);<br>		if (_root == nullptr)<br>		{<br>			_root = newnode;<br>			return true;<br>		}<br>		else<br>		{<br>			Node* parent = nullptr;<br>			Node* cur = _root;<br>			while (cur)<br>			{<br>				if (cur->_key > newnode->_key)<br>				{<br>					parent = cur;<br>					cur = cur->_left;<br>				}<br>				else if (cur->_key < newnode->_key)<br>				{<br>					parent = cur;<br>					cur = cur->_right;<br>				}<br>				else<br>					return false;<br>			}<br>			if (parent->_key > newnode->_key)<br>				parent->_left = newnode;<br>			if (parent->_key < newnode->_key)<br>				parent->_right = newnode;<br>			return true;<br>		}<br>	}</code></pre> <br><h2>⼆叉搜索树的查找</h2> <br><blockquote> <br> <p>1. 从根开始⽐较，查找x，x⽐根的值⼤则往右边⾛查找，x⽐根值⼩则往左边⾛查找。</p> <br> <p>2. 最多查找⾼度次，⾛到到空，还没找到，这个值不存在。</p> <br> <p>3. 如果不⽀持插⼊相等的值，找到x即可返回</p> <br> <p>4. 如果⽀持插⼊相等的值，意味着有多个x存在，⼀般要求查找<span style="color:#be191c;"><strong>中序的第⼀个x</strong></span>。如下图，查找3，要找到1的右孩⼦的那个3返回 </p> <br></blockquote> <br><p><img alt="" height="471" src="https://i-blog.csdnimg.cn/direct/f3062c1926a04a12a0981aa95ead5dc7.png" width="746" /></p> <br><pre><code class="language-cpp">Node* Find(const K& key)<br>	{<br>		assert(_root);<br>		Node* cur = _root;<br>		while (cur)<br>		{<br>			if (cur->_key > key)<br>			{<br>				cur = cur->_left;<br>			}<br>			else if (cur->_key < key)<br>			{<br>				cur = cur->_right;<br>			}<br>			else<br>				return cur;<br>		}<br>		return nullptr;<br>	}</code></pre> <br><p> ⼆叉搜索树的删除</p> <br><p>⾸先查找元素是否在⼆叉搜索树中，如果不存在，则返回false。 如果查找元素存在则分以下四种情况分别处理：（假设要删除的结点为N）</p> <br><p>1. 要删除结点N左右孩⼦均为空</p> <br><p><img alt="" height="466" src="https://i-blog.csdnimg.cn/direct/75914af74bfb4083a03c337f253c78aa.png" width="740" /></p> <br><p>2. 要删除的结点N左孩⼦为空，右孩⼦结点不为空</p> <br><p>3. 要删除的结点N右孩⼦为空，左孩⼦结点不为空</p> <br><p><img alt="" height="464" src="https://i-blog.csdnimg.cn/direct/3fd561d8768140dd841c342736644658.png" width="732" /></p> <br><p>注意还有这种情况：</p> <br><p><img alt="" height="484" src="https://i-blog.csdnimg.cn/direct/0e38f414f675489a9f31b3748c63ead2.png" width="699" /></p> <br><p>4. 要删除的结点N左右孩⼦结点均不为空</p> <br><p><img alt="" height="474" src="https://i-blog.csdnimg.cn/direct/83d2c034403244519fa1990503298057.png" width="754" /></p> <br><p><img alt="" height="475" src="https://i-blog.csdnimg.cn/direct/26013fcf1b8f4e08bb470bc488fa1bb2.png" width="773" /></p> <br><p>对应以上四种情况的解决⽅案：</p> <br><blockquote> <br> <p>1. 把N结点的⽗亲对应孩⼦指针指向空，直接删除N结点（情况1可以当成2或者3处理，效果是⼀样的）</p> <br> <p>2. 把N结点的⽗亲对应孩⼦指针指向N的右孩⼦，直接删除N结点</p> <br> <p>3. 把N结点的⽗亲对应孩⼦指针指向N的左孩⼦，直接删除N结点</p> <br> <p>4. ⽆法直接删除N结点，因为N的两个孩⼦⽆处安放，只能⽤<span style="color:#be191c;"><strong>替换法</strong></span>删除。<span style="color:#be191c;"><strong>找N左⼦树的值最⼤结点 R(最右结点)或者N右⼦树的值最⼩结点R(最左结点)替代N</strong></span>，因为这两个结点中任意⼀个，放到N的位置，都满⾜⼆叉搜索树的规则。替代N的意思就是N和R的两个结点的值交换，转⽽变成删除R结点，R结点符合情况2或情况3，可以直接删除。</p> <br></blockquote> <br><p><span style="color:#ff9900;"><strong>注意：删除的代码逻辑较为复杂，复习的时候最好再写一遍~ </strong></span></p> <br><pre><code class="language-cpp">bool Erase(const K& key)<br>	{<br>		assert(_root);<br>		Node* cur = _root;<br>		Node* parent = nullptr;<br>		while (cur)<br>		{<br>			if (cur->_key > key)<br>			{<br>				parent = cur;<br>				cur = cur->_left;<br>			}<br>			else if (cur->_key < key)<br>			{<br>				parent = cur;<br>				cur = cur->_right;<br>			}<br>			else<br>			{<br>				// 删除<br>				if (cur->_left == nullptr)<br>				{<br>					if (cur == _root)//如果删除没有左子树的根节点<br>					{<br>						_root = cur->_right;<br>					}<br>					// 左子树为空and左右子树都为空<br>					else if (parent->_left == cur)<br>					{<br>						parent->_left = cur->_right;<br>					}<br>					else if (parent->_right == cur)<br>					{<br>						parent->_right = cur->_right;<br>					}<br>					delete cur;<br>				}<br>				else if (cur->_right == nullptr)<br>				{<br>					if (cur == _root)//如果删除没有右子树的根节点<br>					{<br>						_root = cur->_left;<br>					}<br>					// 右子树为空<br>					else if (parent->_left == cur)<br>					{<br>						parent->_left = cur->_left;<br>					}<br>					else if (parent->_right == cur)<br>					{<br>						parent->_right = cur->_left;<br>					}<br>					delete cur;<br>				}<br>				else<br>				{<br>					//左右子树都不为空<br>					Node* replaceparent = cur;<br>					Node* replace = cur->_right;<br>					while (replace->_left)<br>					{<br>						replaceparent = replace;<br>						replace = replace->_left;<br>					}<br>					cur->_key = replace->_key;<br><br>					if (replaceparent->_left == replace)<br>					{<br>						replaceparent->_left = replace->_right;<br>					}<br>					else if (replaceparent->_right == replace)<br>					{<br>						replaceparent->_right = replace->_right;<br>					}<br>					delete replace;<br>				}<br>				return true;<br>			}<br>		}<br>		return false;<br>	}</code></pre> <br><h2> ⼆叉搜索树key和key/value使⽤场景</h2> <br><h3> key搜索场景：</h3> <br><p>只有key作为关键码，结构中只需要存储key即可，关键码即为需要搜索到的值，搜索场景只需要判断key在不在。key的搜索场景实现的⼆叉树搜索树⽀持增删查，但是不⽀持修改，修改key破坏搜索树结构了。</p> <br><p>场景1：⼩区⽆⼈值守⻋库，⼩区⻋库买了⻋位的业主⻋才能进⼩区，那么物业会把买了⻋位的业主的⻋牌号录⼊后台系统，⻋辆进⼊时扫描⻋牌在不在系统中，在则抬杆，不在则提示⾮本⼩区⻋辆，⽆法进⼊。</p> <br><p>场景2：检查⼀篇英⽂⽂章单词拼写是否正确，将词库中所有单词放⼊⼆叉搜索树，读取⽂章中的单词，查找是否在⼆叉搜索树中，不在则波浪线标红提示。</p> <br><h3>key/value搜索场景：</h3> <br><p>每⼀个关键码key，都有与之对应的值value，value可以任意类型对象。树的结构中(结点)除了需要存储key还要存储对应的value，增/删/查还是以key为关键字⾛⼆叉搜索树的规则进⾏⽐较，可以快速查找到key对应的value。key/value的搜索场景实现的⼆叉树搜索树⽀持修改，但是不⽀持修改key，修改key破坏搜索树结构了，可以修改value。</p> <br><p>场景1：简单中英互译字典，树的结构中(结点)存储key(英⽂)和vlaue(中⽂)，搜索时输⼊英⽂，则同时查找到了英⽂对应的中⽂。</p> <br><p>场景2：商场⽆⼈值守⻋库，⼊⼝进场时扫描⻋牌，记录⻋牌和⼊场时间，出⼝离场时，扫描⻋牌，查找⼊场时间，⽤当前时间-⼊场时间计算出停⻋时⻓，计算出停⻋费⽤，缴费后抬杆，⻋辆离场。</p> <br><p>场景3：统计⼀篇⽂章中单词出现的次数，读取⼀个单词，查找单词是否存在，不存在这个说明第⼀次出现，（单词，1），单词存在，则++单词对应的次数。 </p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>