<h2>1.语言结构体类型</h2> <br><p>结构是⼀些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。</p> <br><h3>声明</h3> <br><pre><code class="language-cpp">struct tag<br>{<br>    member-list;<br>}variable-list;</code></pre> <br><p>例如声明一本书：</p> <br><pre><code class="language-cpp">struct Book<br>{<br>	char name[20]; //书名<br>	char author[20]; //作者<br>	int price; //定价<br>    int id[12] //编号<br>};//别忘了分号！！！</code></pre> <br><h3>创建和初始化 </h3> <br><pre><code class="language-cpp">#include <stdio.h><br>struct Stu<br>{<br>    char name[20];//名字<br>    int age;//年龄<br>    char sex[5];//性别<br>    char id[20];//学号<br>};<br>int main()<br>{<br>    //按照结构体成员的顺序初始化<br><br>    struct Stu s = { "张三", 20, "男", "20230818001" };<br><br>    printf("name: %s\n", s.name);<br>    printf("age : %d\n", s.age);<br>    printf("sex : %s\n", s.sex);<br>    printf("id : %s\n", s.id);<br>    //按照指定的顺序初始化<br><br>    struct Stu s2 = { .age = 18, .name = "lisi", .id = "20230818002", .sex = "⼥};<br><br>    printf("name: %s\n", s2.name);<br>    printf("age : %d\n", s2.age);<br>    printf("sex : %s\n", s2.sex);<br>    printf("id : %s\n", s2.id);<br>    return 0;<br>}</code></pre> <br><h3>结构体的特殊声明</h3> <br><pre><code class="language-cpp">//匿名结构体类型<br>struct<br>{<br>    int a;<br>    char b;<br>    float c;<br>}x;<br><br>struct<br>{<br>    int a;<br>    char b;<br>    float c;<br>}a[20], *p;<br></code></pre> <br><p>在上面的代码的基础上  *p = &x;  是不合法的。</p> <br><p><span style="color:#fe2c24;">警告：</span><br /> 编译器会把上⾯的两个声明当成完全不同的两个类型，所以是⾮法的。<br /> 匿名的结构体类型，如果没有对结构体类型重命名的话，基本上只能使⽤⼀次。</p> <br><h3>结构体的自引用</h3> <br><p>在结构中是否可以包含一个该结构体本身的类型呢？</p> <br><p>比如在链表中：</p> <br><pre><code class="language-cpp">struct Node<br>{<br>    int data;<br>    struct Node next;<br>};</code></pre> <br><p>这样定义是不行的，因为⼀个结构体中再包含⼀个同类型的结构体变量，这样结构体变量的⼤<br /> ⼩就会⽆穷的⼤，是不合理的。<br /> 正确的⾃引⽤⽅式：</p> <br><pre><code class="language-cpp">struct Node<br>{<br>    int data;<br>    struct Node* next;<br>};</code></pre> <br><p>在结构体⾃引⽤使⽤的过程中，夹杂了 typedef 对匿名结构体类型重命名，也容易引⼊问题，看看<br /> 下⾯的代码，可⾏吗？</p> <br><pre><code class="language-cpp">typedef struct<br>{<br>    int data;<br>    Node* next;<br>}Node;</code></pre> <br><p><br /> 答案是不⾏的，因为Node是对前⾯的匿名结构体类型的重命名产⽣的，但是在匿名结构体内部提前使⽤Node类型来创建成员变量，这是不⾏的。</p> <br><p>解决⽅案如下：定义结构体不要使⽤匿名结构体了</p> <br><pre><code class="language-cpp">typedef struct Node<br>{<br>    int data;<br>    struct Node* next;<br>}Node;</code></pre> <br><h2>2.结构体内存对⻬</h2> <br><h3> 对⻬规则</h3> <br><p>⾸先得掌握结构体的对⻬规则：<br /> 1.结构体的第⼀个成员对⻬到和结构体变量起始位置偏移量为0的地址处<br /> 2.其他成员变量要对⻬到某个数字（对⻬数）的整数倍的地址处。<br /> 对⻬数 = 编译器默认的⼀个对⻬数与该成员变量⼤⼩的较⼩值。</p> <br><p>VS 中默认的值为 8 ，Linux中gcc没有默认对⻬数，对⻬数就是成员⾃⾝的⼤⼩<br /> 3.结构体总⼤⼩为最⼤对⻬数（结构体中每个成员变量都有⼀个对⻬数，所有对⻬数中最⼤的）的<br /> 整数倍。<br /> 4.如果嵌套了结构体的情况，嵌套的结构体成员对⻬到⾃⼰的成员中最⼤对⻬数的整数倍处，结构<br /> 体的整体⼤⼩就是所有最⼤对⻬数（含嵌套结构体中成员的对⻬数）的整数倍。</p> <br><p>下面来有几道例题：（后附参考答案）</p> <br><pre><code class="language-cpp">//练习1<br>struct S1<br>{<br>    char c1;<br>    int i;<br>    char c2;<br>};<br>    printf("%d\n", sizeof(struct S1));// 12<br>//练习2<br>struct S2<br>{<br>    char c1;<br>    char c2;<br>    int i;<br>};<br>    printf("%d\n", sizeof(struct S2));// 8<br>//练习3<br>struct S3<br>{<br>    double d;<br>    char c;<br>    int i;<br>};<br>    printf("%d\n", sizeof(struct S3));// 16<br>//练习4-结构体嵌套问题<br>struct S4<br>{<br>    char c1;<br>    struct S3 s3;<br>    double d;<br>};<br>    printf("%d\n", sizeof(struct S4));// 32</code></pre> <br><h3>为什么存在内存对⻬?</h3> <br><p>1. 平台原因（移植原因）<br /> 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。<br /> 2. 性能原因：<br /> 数据结构(尤其是栈)应该尽可能地在⾃然边界上对⻬。原因在于，为了访问未对⻬的内存，处理器需要作两次内存访问；⽽对⻬的内存访问仅需要⼀次访问。假设⼀个处理器总是从内存中取8个字节，则地址必须是8的倍数。如果我们能保证将所有的double类型的数据的地址都对⻬成8的倍数，那么就可以⽤⼀个内存操作来读或者写值了。否则，我们可能需要执⾏两次内存访问，因为对象可能被分放在两个8字节内存块中。<br /><strong>总体来说：结构体的内存对⻬是拿空间来换取时间的做法。</strong></p> <br><p>那在设计结构体的时候，我们既要满⾜对⻬，⼜要节省空间，如何做到：  <strong>让占⽤空间⼩的成员尽量集中在⼀起</strong></p> <br><pre><code class="language-cpp">//例如：<br>struct S1<br>{<br>    char c1;<br>    int i;<br>    char c2;<br>};<br>struct S2<br>{<br>    char c1;<br>    char c2;<br>    int i;<br>};<br>//S1和S2类型的成员⼀模⼀样，但是S1和S2所占空间的⼤⼩有了⼀些区别。</code></pre> <br><h3>修改默认对⻬数</h3> <br><p>#pragma  这个预处理指令，可以改变编译器的默认对⻬数。</p> <br><pre><code class="language-cpp">#include <stdio.h><br>#pragma pack(1)//设置默认对⻬数为1<br>struct S<br>{<br>    char c1;<br>    int i;<br>    char c2;<br>};<br>#pragma pack()//取消设置的对⻬数，还原为默认<br>int main()<br>{<br>    printf("%d\n", sizeof(struct S));//输出 6<br>    return 0;<br>}</code></pre> <br><p>结构体在对⻬⽅式不合适的时候，我们可以⾃⼰更改默认对⻬数</p> <br><h2>3.结构体传参</h2> <br><pre><code class="language-cpp">struct S<br>{<br>    int data[1000];<br>    int num;<br>};<br>struct S s = {<!-- -->{1,2,3,4}, 1000};<br>//结构体传参<br>void print1(struct S s)<br>{<br>    printf("%d\n", s.num);<br>}<br>//结构体地址传参<br>void print2(struct S* ps)<br>{<br>    printf("%d\n", ps->num);<br>}<br>int main()<br>{<br>    print1(s); //传结构体<br>    print2(&s); //传地址（优）<br>    return 0;<br>}</code></pre> <br><p>为什么我们说结构传参的时候传地址比较好呢？在传结构体的时候相当于将原结构拷贝了一次，重新放在了一个地址上，占用了额外的空间。</p> <br><p>那么，当我们传地址的时候为了防止原结构被修改，可以加上const修饰。</p> <br><h2>4.结构体实现位段</h2> <br><h3>什么是位段？</h3> <br><p>位段的声明和结构是类似的，有两个不同：<br /> 1. 位段的成员必须是 int、unsigned int 或signed int ，在C99中位段成员的类型也可以<br /> 选择其他类型。<br /> 2. 位段的成员名后边有⼀个冒号和⼀个数字</p> <br><pre><code class="language-cpp">#include<stdio.h><br>struct A<br>{<br>    int _a : 2;<br>    int _b : 5;<br>    int _c : 10;<br>    int _d : 30;<br>};<br><br>int main()<br>{<br>    printf("%zd\n",sizeof(struct A));//输出 8<br>}</code></pre> <br><h3>位段的内存分配</h3> <br><p>1. 位段的成员可以是 int  unsigned int  signed int 或者是 char 等类型<br /> 2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的⽅式来开辟的。<br /> 3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使⽤位段。</p> <br><pre><code class="language-cpp">//⼀个例⼦<br>struct S<br>{<br>    char a:3;<br>    char b:4;<br>    char c:5;<br>    char d:4;<br>};<br>struct S s = {0};<br>    s.a = 10;<br>    s.b = 12;<br>    s.c = 3;<br>    s.d = 4;<br>//空间是如何开辟的？</code></pre> <br><h3><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/34192674724fa75542432a05d2adb083.png" /><br /> 位段的跨平台问题</h3> <br><p>1. int 位段被当成有符号数还是⽆符号数是不确定的。<br /> 2. 位段中最⼤位的数⽬不能确定。（16位机器最⼤16，32位机器最⼤32，写成27，在16位机器会<br /> 出问题。<br /> 3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。<br /> 4. 当⼀个结构包含两个位段，第⼆个位段成员⽐较⼤，⽆法容纳于第⼀个位段剩余的位时，是舍弃<br /> 剩余的位还是利⽤，这是不确定的。<br /><strong>总结：<br /> 跟结构相⽐，位段可以达到同样的效果，并且可以很好的节省空间，但是有跨平台的问题存在。</strong></p> <br><h3>位段使⽤的注意事项</h3> <br><p>位段的⼏个成员共有同⼀个字节，这样有些成员的起始位置并不是某个字节的起始位置，那么这些位置处是没有地址的。内存中每个字节分配⼀个地址，⼀个字节内部的bit位是没有地址的。<br /><strong>所以不能对位段的成员使⽤&操作符</strong>，这样就不能使⽤scanf直接给位段的成员输⼊值，只能是先输⼊放在⼀个变量中，然后赋值给位段的成员。</p> <br><pre><code class="language-cpp">struct A<br>{<br>    int _a : 2;<br>    int _b : 5;<br>    int _c : 10;<br>    int _d : 30;<br>};<br>int main()<br>{<br>    struct A sa = { 0 };<br>    /*<br>        scanf("%d", &sa._b);//这是错误的<br>    */<br>    //正确的⽰范<br>    int b = 0;<br>    scanf("%d", &b);<br>    sa._b = b;<br>    return 0;<br>}</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>