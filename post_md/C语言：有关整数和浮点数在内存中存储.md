# C语言：有关整数和浮点数在内存中存储

# 1. 整数在内存中的存储

整数的2进制表⽰⽅法有三种，即**原码、反码和补码**

三种表⽰⽅法均有符号位和数值位两部分，符号位都是⽤0表⽰“正”，⽤1表⽰“负”，⽽数值位最
 ⾼位的⼀位是被当做符号位，剩余的都是数值位。

**正整数的原、反、补码都相同。负整数的三种表⽰⽅法各不相同。**

原码：直接将数值按照正负数的形式翻译成⼆进制得到的就是原码。

反码：将原码的符号位不变，其他位依次按位取反就可以得到反码。

补码：反码+1就得到补码。

对于整形来说：数据存放**内存中其实存放的是补码**。

为什么呢？

在计算机系统中，数值⼀律⽤补码来表⽰和存储。原因在于，使⽤补码，可以将符号位和数值域统⼀处理；同时，加法和减法也可以统⼀处理（**CPU只有加法器**）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
 

# 2. ⼤⼩端字节序和字节序判断

我们先来看一个细节：

![img](https://raw.githubusercontent.com/QinMou000/pic/main/9ec13d9b6b258a82b2887e341d5d431d.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

调试的时候，我们可以看到在a中的 0x11223344 这个数字是按照字节为单位，倒着存储的。这是为什么呢？

## 2.1 什么是大小端？

其实超过⼀个字节的数据在内存中存储的时候，就有存储顺序的问题，按照不同的存储顺序，我们分为⼤端字节序存储和⼩端字节序存储，下⾯是具体的概念：
 ⼤端（存储）模式：是指数据的低位字节内容保存在内存的⾼地址处，⽽数据的⾼位字节内容，保存在内存的低地址处。
 ⼩端（存储）模式：是指数据的低位字节内容保存在内存的低地址处，⽽数据的⾼位字节内容，保存在内存的⾼地址处。

## 2.2 为什么有⼤⼩端?

这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着⼀个字节，⼀个字节为8bit位，但是在C语⾔中除了8bit的 char 之外，还有16bit的 short 型，32bit的 long 型（要看具体的编译器），另外，对于位数⼤于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度⼤于⼀个字节，那么必然存在着⼀个如何将多个字节安排的问题。因此就导致了⼤端存储模式和⼩端存
 储模式。

例如：⼀个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么0x11 为⾼字节， 0x22 为低字节。对于⼤端模式，就将 0x11 放在低地址中，即 0x0010 中，0x22 放在⾼地址中，即 0x0011 中。⼩端模式，刚好相反。我们常⽤的 X86 结构是⼩端模式，⽽**KEIL C51** 则为⼤端模式。很多的ARM，DSP都为⼩端模式。有些ARM处理器还可以由硬件来选择是⼤端模式还是⼩端模式。

# 3. 浮点数在内存中的存储

在了解浮点数在内存中的存储之前先看一下这段代码的输出：

```cpp
#include <stdio.h>
int main()
{
    int n = 9;
    float *pFloat = (float *)&n;

    printf("n的值为：%d\n",n);
    printf("*pFloat的值为：%f\n",*pFloat);

    *pFloat = 9.0;

    printf("num的值为：%d\n",n);
    printf("*pFloat的值为：%f\n",*pFloat);

    return 0;
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

结果： 

![img](https://raw.githubusercontent.com/QinMou000/pic/main/cb117f7a454ca0ba1e7902d548fa65bd.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 直接看肯定是看不懂的，我们先了解浮点数是如何在内存存储的。

根据国际标准IEEE（电⽓和电⼦⼯程协会）754，任意⼀个⼆进制浮点数V可以表⽰成下⾯的形式：
 ![img](https://raw.githubusercontent.com/QinMou000/pic/main/01590aade7ae7421107b66f88a663465.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)​编辑

• (-1)S 表⽰符号位，当S=0，V为正数；当S=1，V为负数
 • M表⽰有效数字，M是⼤于等于1，⼩于2的
 • 2E 表⽰指数位
 举例来说：
 ⼗进制的5.0，写成⼆进制是 101.0 ，相当于 1.01×2^2 。那么，按照上⾯V的格式，可以得出S=0，M=1.01，E=2。
 ⼗进制的-5.0，写成⼆进制是 -101.0 ，相当于 -1.01×2^2 。那么，S=1，M=1.01，E=2

IEEE754规定：
 对于32位的浮点数，最⾼的1位存储符号位S，接着的8位存储指数E，剩下的23位存储有效数字M
 对于64位的浮点数，最⾼的1位存储符号位S，接着的11位存储指数E，剩下的52位存储有效数字M

## 3.1 具体存储过程：

IEEE754对有效数字M和指数E，还有⼀些特别规定。
 前⾯说过， 1≤M<2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中 xxxxxx 表⽰⼩数部IEEE754规定，在计算机内部保存M时，默认这个数的第⼀位总是1，因此可以被舍去，只保存后⾯xxxxxx部分。⽐如保存1.01的时候，只保存01，等到读取的时候，再把第⼀位的1加上去。这样做的⽬
 的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，**将第⼀位的1舍去**以后，等于可以保存24位有效数字。

⾄于指数E，情况就⽐较复杂
 ⾸先，E为⼀个⽆符号整数（unsigned int）
 这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE754规定，存⼊内存时E的真实值必须再加上⼀个中间数，**对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023**。⽐如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

## 3.2 浮点数读取过程

指数E从内存中取出还可以再分成三种情况：

### E不全为0或不全为1

这时，浮点数就采⽤下⾯的规则表⽰，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第⼀位的1。
 ⽐如：0.5的⼆进制形式为0.1，由于规定正数部分必须为1，即将⼩数点右移1位，则为1.0*2^(-1)，其
 阶码为-1+127(中间值)=126，表⽰为01111110，⽽尾数1.0去掉整数部分为0，补⻬0到23位
 00000000000000000000000

则其⼆进制表⽰形式为:
 1 0 01111110 00000000000000000000000

### E全为0

这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第⼀位的1，⽽是还原为0.xxxxxx的⼩数。这样做是为了表⽰±0，以及接近于0的很⼩的数字。

0 00000000 00100000000000000000000

### E全为1

这时，如果有效数字M全为0，表⽰±⽆穷⼤（正负取决于符号位s）

0 11111111 00010000000000000000000

**本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！**