<blockquote> <br> <p style="text-align:center"><img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/a46182e6318c4593a5c674f2bf9439d4.jpeg" width="1024" /></p> <br> <p style="text-align:center">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12799988.html" title="Linux">Linux</a>✨✨</p> <br> <p style="text-align:center">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2 style="background-color:transparent"> 什么是库</h2> <br><p>库是写好的现有的，成熟的可以复用的代码。现实中每个程序都需要依赖很多基础的底层库。世界上有很多大佬为了实现某一个功能，写了很多很NB的代码。他们把代码封装成一个库，这样我们不必写出像他们一样厉害的代码，只需要使用它们分享的库，也能使用对应的功能了。</p> <br><p> 本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。</p> <br><ul><li><strong><span style="color:#0d0016">静态库 .a[Linux/macOS]、.lib[windows]</span></strong></li><li><strong><span style="color:#0d0016">动态库 .so[Linux]、.dll[windows]、.dylib[macOS]</span></strong></li></ul> <br><h2 style="background-color:transparent">静态库</h2> <br><ul><li>程序在编译链接的时候把库的代码链接到可执行文件中，程序运行的时候将不再需要静态库。</li><li>一个<span style="color:#646a73">⼀个可执⾏程序可能⽤到许多的库，这些库运⾏有的是静态库，有的是动态库，⽽我们的编译默认为动态链接库，只有在该库下找不到动态.so的时候才会采⽤同名静态库。我们也可以使⽤ gcc的 -static </span><span style="color:#646a73">强转设置链接静态库。</span></li></ul> <br><h3>制作静态库</h3> <br><p><a href="https://gitee.com/wang-qin928/cpp/tree/master/25/2_5" rel="nofollow" title="25/2_5 · 钦某/Code - 码云 - 开源中国 (gitee.com)">25/2_5 · 钦某/Code - 码云 - 开源中国 (gitee.com)</a></p> <br><pre><code class="language-bash">// Makefile<br><br>libmyfile.a:File.o<br>	@ar -rc $@ $^<br>	@echo "bulid $^ to $@ ... done"<br>%.o:%.c<br>	@gcc -c $<<br>	@echo "compling $< to $@ ... done"<br><br>.PHONY:output<br>output:<br>	mkdir -p ../lib/include<br>	mkdir -p ../lib/mylib<br>	cp -f *.h ../lib/include<br>	cp -f *.a ../lib/mylib<br>	tar czf lib.tgz lib<br><br>.PNOLY:clean<br>clean:<br>	@rm -rf *.a *.o *tgz<br>	@echo "clean ... done"</code></pre> <br><p>ar是gun归档工具，rc表示(replace and create)</p> <br><p><img alt="" height="52" src="https://i-blog.csdnimg.cn/direct/b993c15b47df4299bbd33e859d3977d6.png" width="717" /></p> <br><ul><li>t：列出静态库中的文件</li><li>v：verbose详细信息 </li></ul> <br><h3> 使用静态库</h3> <br><pre><code class="language-cpp">// 任意目录下新建<br>// test.c,引入库头文件<br><br>#include "File.h"<br>#include <stdio.h><br><br>int main()<br>{<br>    MYFILE* file = my_openfile("log.txt","w");<br>    char* str = "abcdef";<br>    my_fwrite(file, str, strlen(str));<br>    my_closefile(file);<br><br>    return 0;<br>}<br><br>// 场景1：头文件和库文件安装到系统路径下<br>$ gcc main.c -lmyfile<br><br>// 场景2：头文件和库文件和我们自己的源文件在同⼀个路径下<br>$ gcc main.c -L. -lmyfile<br><br>// 场景3：头文件和库文件有自己的独立路径<br>$ gcc main.c -I头文件路径 -L库文件路径 -lmyfile</code></pre> <br><ul><li>-L(library头字母大写)：指定库路径</li><li>-I(include头字母大写)：指定头文件搜索路径</li><li>-l(library头字母小写)：指定库名</li><li>测试目标文件生成后，静态库删掉，程序照样可以运行</li><li>库名称 = 库文件名去掉前缀lib，去掉后缀.so，.a</li></ul> <br><pre><code class="language-bash">ubuntu@VM-4-4-ubuntu:~/Code/25/2_5$ tree .<br>.<br>├── a.out<br>├── include<br>│   ├── File.c<br>│   ├── File.h<br>│   ├── File.o<br>│   ├── libmyfile.a<br>│   ├── lib.tgz<br>│   └── Makefile<br>├── lib<br>│   ├── include<br>│   │   └── File.h<br>│   └── mylib<br>│       └── libmyfile.a<br>├── Makefile<br>└── test.c<br><br>5 directories, 11 files</code></pre> <br><h2>动态库</h2> <br><ul><li> <br>  <div> <br>   <span style="color:#1f2329">动态库（.so）：程序在运⾏的时候才去链接动态库的代码，多个程序共享使⽤库的代码。</span> <br>  </div> </li><li> <br>  <div> <br>   <span style="color:#1f2329">⼀</span> <br>   <span style="color:#1f2329">个与动态库链接的可执⾏⽂件仅仅包含它⽤到的函数⼊⼝地址的⼀个表，⽽不是外部函数所在⽬标⽂件的整个机器码</span> <br>  </div> </li><li> <br>  <div> <br>   <span style="color:#1f2329">在可执⾏⽂件开始运⾏以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制到内存中，这个过程称为动态链接（dynamic linking） </span> <br>  </div> </li><li> <br>  <div> <br>   <span style="color:#1f2329">动态库可以在多个程序间共享，所以动态链接使得可执⾏⽂件更⼩，节省了磁盘空间。操作系统采⽤虚拟内存机制允许物理内存中的⼀份动态库被要⽤到该库的所有进程共⽤，节省了内存和磁盘空间。</span> <br>  </div> </li></ul> <br><h3>生成动态库</h3> <br><pre><code class="language-bash">// Makefile<br><br>libmyfile.so:File.o<br>	gcc -o $@ $^ -shared<br><br>%.o:%.c<br>	gcc -fPIC -c $<<br><br>.PHONY:output<br>output:<br>	mkdir -p ../lib/include<br>	mkdir -p ../lib/mylib<br>	cp -f *.h ../lib/include<br>	cp -f *.so ../lib/mylib<br>	tar czf lib.tgz lib<br><br>.PHONY:clean<br>clean:<br>	rm -rf *.o *.so lib.tgz</code></pre> <br><ul><li>shared：表示生成共享库格式</li><li><span style="color:#b95514"><strong>fPIC：产生位置无关码（position independent code）</strong></span></li><li>库名规则：libxxx.so</li></ul> <br><h3>使用动态库</h3> <br><pre><code class="language-bash">// 场景1：头文件和库文件安装到系统路径下<br>$ gcc main.c -lmyfile<br><br>// 场景2：头文件和库文件和我们自己的源文件在同⼀个路径下<br>$ gcc main.c -L. -lmyfile // 从左到右搜索-L指定的⽬录<br><br>// 场景3：头文件和库文件有自己的独立路径<br>$ gcc main.c -I头文件路径 -L库文件路径 -lmyfile<br><br>$ ldd libmystdio.so // 查看库或者可执⾏程序的依赖<br>linux-vdso.so.1 => (0x00007fffacbbf000)<br>libc.so.6 => /lib64/libc.so.6 (0x00007f8917335000)<br>/lib64/ld-linux-x86-64.so.2 (0x00007f8917905000)</code></pre> <br><pre><code class="language-bash">ubuntu@VM-4-4-ubuntu:~/Code/25/2_6$ tree .<br>.<br>├── a.out<br>├── include<br>│   ├── File.c<br>│   ├── File.h<br>│   ├── File.o<br>│   ├── libmyfile.so<br>│   ├── lib.tgz<br>│   └── Makefile<br>├── lib<br>│   ├── include<br>│   │   └── File.h<br>│   └── mylib<br>│       └── libmyfile.so<br>├── Makefile<br>└── test.c<br><br>5 directories, 11 files</code></pre> <br><h3>库运行搜索路径</h3> <br><h4>问题</h4> <br><pre><code class="language-bash">ubuntu@VM-4-4-ubuntu:~/Code/25/2_6$ ldd a.out<br>        linux-vdso.so.1 (0x00007ffcbe5ab000)<br>        libmyfile.so => not found<br>        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x000077eea6a00000)<br>        /lib64/ld-linux-x86-64.so.2 (0x000077eea6cf5000)</code></pre> <br><ul><li> <h4>解决方案</h4> </li><li>拷贝 .so 文件到系统共享路径下，一般指/usr/lib、usr/local/lib、/lib64或者其他的默认库路径</li><li>向系统共享库路径下建立同名软连接</li><li>更改环境变量：LD_LIBRARY_PATH</li><li>ldconfig方案：配置/etc/ld.so.conf.d/，ldconfig更新</li></ul> <br><p>在系统<code>/etc/ld.so.conf/</code>目录下新建文件<code>my_library.conf</code>，并在文件里写入库文件路径，关闭保存后使用<code>sudo ldconfig</code>命令，这将扫描 <code>/etc/ld.so.conf</code> 文件以及 <code>/etc/ld.so.conf.d/</code> 目录下的所有配置文件，并更新 <code>/etc/ld.so.cache</code> 缓存文件。</p> <br><p style="text-align:center"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>