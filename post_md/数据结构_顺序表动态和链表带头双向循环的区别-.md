<blockquote> <br> <p><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6f2b920cd38b273e9349974209147fee.png" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12634416.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>储存空间</h2> <br><p>我们知道顺序表的实质就是一个数组，数组的物理地址是连续的；而链表是由一个个的节点组成的，物理地址不一定连续、因为在malloc空间的时候不能保证，每次开辟的空间都与上次开辟的空间相邻。</p> <br><p><img alt="" height="363" src="https://i-blog.csdnimg.cn/blog_migrate/e740f7c89140fba0ff1fa2b80d08a138.png" width="988" /></p> <br><h2>随机访问（排序）</h2> <br><p>在随机访问的时候，顺序表可以直接使用数组的下标访问O(1)；而链表在随机访问时必须遍历链表O(n)。这导致了在排序的时候顺序表比链表便捷的多。（如果要用链表排序还不如copy到数组那排完了在copy过来）</p> <br><h2>任意位置插入删除</h2> <br><p>链表在插入删除的时候只需要删除对应的节点就行，</p> <br><pre><code class="language-cpp">void LTPopBack(LTNode* phead)//尾删<br>{<br>	assert(phead && phead->next != phead);//第二个很容易忽视！<br>	LTNode* del = phead->prev;<br>	del->prev->next = phead;<br>	phead->prev = del->prev;<br>	free(del);<br>	del = NULL;<br>}<br><br>void LTPopFront(LTNode* phead)//头删<br>{<br>	assert(phead && phead->next != phead);<br>	LTNode* del = phead->next;<br>	del->next->prev = phead;<br>	phead->next = del->next;<br>	free(del);<br>	del = NULL;<br>}<br><br>void LTErase(LTNode* pos)//任意位置删除<br>{<br>	assert(pos);<br>	pos->next->prev = pos->prev;<br>	pos->prev->next = pos->next;<br>	free(pos);<br>	pos = NULL;<br>}<br></code></pre> <br><p>但是顺序表在插入删除时可能需要将整体元素向前或向后移动，就非常麻烦。</p> <br><pre><code class="language-cpp">void SeqListPushFront(SLT* ps, SQDataType x)<br>{<br>	SeqListCheckCapacity(ps);<br><br>	int end = ps->size - 1;<br>	while (end >= 0)<br>	{<br>		ps->data[end + 1] = ps->data[end];//整体移动<br>		end--;<br>	}<br>	ps->data[0] = x;<br>	ps->size++;<br>}</code></pre> <br><h2>插入扩容</h2> <br><p>顺序表经常会有空间不够的时候，这时候就需要扩容了，每次扩容的时候都会产生一定的消耗，有时扩容还有可能会多扩（原来有100个空间，扩到了200个，但最终只使用了120个空间）这就导致了空间的浪费。</p> <br><p>而链表几乎没有空间的概念，每一个元素都是独善其身的，只有prev和next指针与其他元素有联系，插入元素时只需要新malloc一块空间即可。</p> <br><h2>缓存利用率</h2> <br><p><a class="has-card" href="https://coolshell.cn/articles/20793.html" rel="nofollow" title="https://coolshell.cn/articles/20793.html"><span class="link-card-box"><span class="link-title">https://coolshell.cn/articles/20793.html</span><span class="link-link"><img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.7/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=O83A" alt="icon-default.png?t=O83A" />https://coolshell.cn/articles/20793.html</span></span></a></p> <br><p>上面链接的文章提到了缓存的命中这个概念，由于顺序表是连续的，在访问一个数据时，计算机会将这个数据后面地址的元素一起拖到CPU，万一后面的元素我们之后恰好也要访问，这就省去了不少CPU的负担。</p> <br><p>但链表每个元素的地址不一定连续，所以当计算机连同后面的信息一起拖过去，但CPU不访问后面的元素，这就为CPU增加了负担。</p> <br><p>缓存命中本是为了减少CPU的负担，但由于链表的特殊结构适得其反。</p> <br><table><tbody><tr><td>不同点</td><td>顺序表</td><td>链表</td></tr><tr><td>存储空间上</td><td>物理上一定连续</td><td>逻辑上连续，但物理上不一定连<br /> 续</td></tr><tr><td>随机访问</td><td>支持O(1)</td><td>不支持：O(N)</td></tr><tr><td>任意位置插入或者删除元<br /> 素</td><td>可能需要搬移元素，效率低O(N)</td><td>只需修改指针指向</td></tr><tr><td>插入</td><td>动态顺序表，空间不够时需要扩<br /> 容</td><td>没有容量的概念</td></tr><tr><td>应用场景</td><td>元素高效存储+频繁访问</td><td>任意位置插入和删除频繁</td></tr><tr><td>缓存利用率</td><td>高</td><td>低</td></tr></tbody></table> <br><p style="text-align:center;">  <strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>