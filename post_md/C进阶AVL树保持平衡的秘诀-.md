<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/9e66b67c73ef431f887a88a78f972ea7.png" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><p><a href="https://gitee.com/wang-qin928/c-learning/blob/master/function/BinSearchTree/BSTree.h" rel="nofollow" title="AVL树的底层实现代码：BSTree.h · 钦某/C++learning">AVL树的底层实现代码：BSTree.h · 钦某/C++learning</a></p> <br><h2>什么是AVL树？</h2> <br><p>• AVL树是最先发明的⾃平衡⼆叉查找树，AVL是⼀颗空树，或者具备下列性质的⼆叉搜索树：<span style="color:#be191c;"><strong>它的左右⼦树都是AVL树，且左右⼦树的⾼度差的绝对值不超过1。</strong></span>AVL树是⼀颗⾼度平衡搜索⼆叉树， 通过控制⾼度差去控制平衡。</p> <br><p>• AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis是两个前苏联的科学家，他们在1962 年的论⽂《An algorithm for the organization of information》中发表了它。</p> <br><p>• AVL树实现这⾥我们引⼊⼀个<span style="color:#be191c;"><strong>平衡因⼦(balance factor)的概念</strong></span>，每个结点都有⼀个平衡因⼦，任何结点的平衡因⼦等于右⼦树的⾼度减去左⼦树的⾼度，也就是说任何结点的平衡因⼦等于0/1/-1， <span style="color:#1c7331;"><strong>AVL树并不是必须要平衡因⼦</strong></span>，但是有了平衡因⼦可以更⽅便我们去进⾏观察和控制树是否平衡， 就像⼀个⻛向标⼀样。（有平衡因子和没有平衡因子都有各自的好处）</p> <br><p>• 思考⼀下为什么AVL树是⾼度平衡搜索⼆叉树，要求⾼度差不超过1，⽽不是⾼度差是0呢？0不是更好的平衡吗？画画图分析我们发现，不是不想这样设计，⽽是有些情况是做不到⾼度差是0的。⽐如⼀棵树是2个结点，4个结点等情况下，⾼度差最好就是1，⽆法作为⾼度差是0</p> <br><p><span style="color:#be191c;"><strong>• AVL树整体结点数量和分布和完全⼆叉树类似，⾼度可以控制在log(n)，那么增删查改的效率也可 以控制在O(log(n))，相⽐⼆叉搜索树有了本质的提升。</strong></span></p> <br><p style="text-align:center;"><img alt="" height="377" src="https://i-blog.csdnimg.cn/direct/67c19731804f4e38be79d87202463075.png" width="557" /></p> <br><h2>实现AVL树</h2> <br><h3>AVL树的结构</h3> <br><pre><code class="language-cpp">template<class K,class V><br>struct AVLTreeNode<br>{<br><br>	AVLTreeNode(const pair<K, V>& kv)<br>		:_parent(nullptr),<br>		_left(nullptr),<br>		_right(nullptr),<br>		_kv(kv),<br>		_bf(0)<br>	{}<br>	struct AVLTreeNode<K, V>* _parent;<br>	struct AVLTreeNode<K, V>* _left;<br>	struct AVLTreeNode<K, V>* _right;<br>	pair<K, V> _kv;<br>	int _bf;<br>};<br><br>template<class K,class V><br>class AVLTree<br>{<br>	typedef struct AVLTreeNode<K,V> Node;<br>public:<br>	AVLTree()<br>		:_root(nullptr)<br>		,_size(0)<br>	{}<br>	bool Insert(const pair<K,V>& kv)<br>    {<br>        //...<br>    }<br>private:<br>	int _size;<br>	Node* _root;<br>};</code></pre> <br><p>AVL树的核心就是在插入的时候保持左右子树的高度差平衡，这里我们着重分析插入环节</p> <br><h3> AVL树的插⼊</h3> <br><p>AVL树插⼊⼀个值的⼤概过程</p> <br><p>1. 插⼊⼀个值按⼆叉搜索树规则进⾏插⼊。</p> <br><p>2. 新增结点以后，只会影响祖先结点的⾼度，也就是可能会影响部分祖先结点的平衡因⼦，所以更新从新增结点->根结点路径上的平衡因⼦，实际中最坏情况下要更新到根，有些情况更新到中间就可以停⽌了，具体情况我们下⾯再详细分析。</p> <br><p>3. 更新平衡因⼦过程中没有出现问题，则插⼊结束。</p> <br><p>4. 更新平衡因⼦过程中出现不平衡，<strong><span style="color:#be191c;">对不平衡⼦树旋转，旋转后本质调平衡的同时，本质降低了⼦树的⾼度，不会再影响上⼀层，所以插⼊结束。</span></strong></p> <br><h4>平衡因⼦更新</h4> <br><p>更新原则：</p> <br><p>• 平衡因⼦ = 右⼦树⾼度-左⼦树⾼度</p> <br><p>• 只有⼦树⾼度变化才会影响当前结点平衡因⼦。</p> <br><p>• 插⼊结点，会增加⾼度，所以新增结点在parent的右⼦树，parent的平衡因⼦++，新增结点在 parent的左⼦树，parent平衡因⼦--</p> <br><p>• parent所在⼦树的⾼度是否变化决定了是否会继续往上更新</p> <br><p>更新停⽌条件：</p> <br><p>• 更新后parent的平衡因⼦等于0，更新中parent的平衡因⼦变化为-1->0 或者 1->0，说明更新前 parent⼦树⼀边⾼⼀边低，新增的结点插⼊在低的那边，插⼊后parent所在的⼦树⾼度不变，不会 影响parent的⽗亲结点的平衡因⼦，更新结束。</p> <br><p>• 更新后parent的平衡因⼦等于1 或 -1，更新前更新中parent的平衡因⼦变化为0->1 或者 0->-1，说 明更新前parent⼦树两边⼀样⾼，新增的插⼊结点后，parent所在的⼦树⼀边⾼⼀边低，parent所 在的⼦树符合平衡要求，但是⾼度增加了1，会影响arent的⽗亲结点的平衡因⼦，所以要继续向上 更新。</p> <br><p>• 更新后parent的平衡因⼦等于2 或 -2，更新前更新中parent的平衡因⼦变化为1->2 或者 -1->-2，说明更新前parent⼦树⼀边⾼⼀边低，新增的插⼊结点在⾼的那边，parent所在的⼦树⾼的那边更⾼ 了，破坏了平衡，parent所在的⼦树不符合平衡要求，需要旋转处理，旋转的⽬标有两个：</p> <br><blockquote> <br> <p>1、把 parent⼦树旋转平衡。</p> <br> <p>2、降低parent⼦树的⾼度，恢复到插⼊结点以前的⾼度。所以旋转后也不 需要继续往上更新，插⼊结束。</p> <br></blockquote> <br><p>更新到10结点，平衡因⼦为2，10所在的⼦树已经不平衡，需要旋转处理 </p> <br><p style="text-align:center;"><img alt="" height="437" src="https://i-blog.csdnimg.cn/direct/507eee5244f848f59ef75564abc98934.png" width="614" /></p> <br><p>更新到中间结点，3为根的⼦树⾼度不变，不会影响上⼀层，更新结束 </p> <br><p style="text-align:center;"><img alt="" height="407" src="https://i-blog.csdnimg.cn/direct/22490a0f99bc4b309b091cde84af80ec.png" width="576" /></p> <br><p>最坏更新到根停⽌</p> <br><p style="text-align:center;"> <img alt="" height="394" src="https://i-blog.csdnimg.cn/direct/3d2b5c9aa9384afb87f750ca1b9f630e.png" width="542" /></p> <br><p> 插⼊结点及更新平衡因⼦的代码实现</p> <br><pre><code class="language-cpp">bool Insert(const pair<K,V>& kv)<br>	// 插入不要新建一个newnode，直接用cur节点，<br>	// newnode可能会导致<br>{<br>	if (_root == nullptr)<br>	{<br>		_root = new Node(kv);<br>		_size++;<br>		return true;<br>	}<br>	else<br>	{<br>		Node* parent = nullptr;<br>		Node* cur = _root;<br>		while (cur)<br>		{<br>			if (cur->_kv.first > kv.first)<br>			{<br>				parent = cur;//先更新parent<br>				cur = cur->_left;<br>			}<br>			else if (cur->_kv.first < kv.first)<br>			{<br>				parent = cur;<br>				cur = cur->_right;<br>			}<br>			else<br>				return false;<br>		}<br>		cur = new Node(kv);<br><br>		if (parent->_kv.first < cur->_kv.first)<br>			parent->_right = cur;<br>		else<br>			parent->_left = cur;<br>		cur->_parent = parent;<br><br>		while (parent)<br>		{<br>			if (cur == parent->_left)<br>				parent->_bf--;<br>			else<br>				parent->_bf++;<br><br>			if (parent->_bf == 0)<br>				break;// 结束更新<br>			else if (parent->_bf == 1 || parent->_bf == -1)<br>			{<br>				// 继续往上更新<br>				cur = parent;// 先更新cur<br>				parent = parent->_parent;<br>			}<br>			else if (parent->_bf == 2 || parent->_bf == -2)<br>			{<br>				// 不平衡，旋转...<br>                break;<br>			}<br>			else<br>				assert(false);// 在插入之前就不是AVL树<br>		}<br>	}<br>	_size++;<br>	return true;<br>}</code></pre> <br><h3>旋转</h3> <br><p>旋转的原则</p> <br><p>1. 保持搜索树的规则</p> <br><p>2. 让旋转的树从不满⾜变平衡，其次降低旋转树的⾼度</p> <br><p>旋转总共分为四种，左单旋/右单旋/左右双旋/右左双旋。</p> <br><p>说明：下⾯的图中，有些结点我们给的是具体值，如10和5等结点，这⾥是为了⽅便讲解，实际中是什 么值都可以，只要⼤⼩关系符合搜索树的规则即可。</p> <br><h4>右单旋</h4> <br><p>• 本图1展⽰的是10为根的树，有a/b/c抽象为三棵⾼度为h的⼦树(h>=0)，a/b/c均符合AVL树的要 求。10可能是整棵树的根，也可能是⼀个整棵树中局部的⼦树的根。这⾥a/b/c是⾼度为h的⼦树， 是⼀种概括抽象表⽰，他代表了所有右单旋的场景，实际右单旋形态有很多种，具体图2/图3/图4/ 图5进⾏了详细描述。</p> <br><p>• 在a⼦树中插⼊⼀个新结点，导致a⼦树的⾼度从h变成h+1，不断向上更新平衡因⼦，导致10的平 衡因⼦从-1变成-2，10为根的树左右⾼度差超过1，违反平衡规则。10为根的树左边太⾼了，需要 往右边旋转，控制两棵树的平衡。</p> <br><p>• 旋转核⼼步骤，因为5 < b⼦树的值 < 10，将b变成10的左⼦树，10变成5的右⼦树，5变成这棵树新 的根，符合搜索树的规则，控制了平衡，同时这棵的⾼度恢复到了插⼊之前的h+2，符合旋转原 则。如果插⼊之前10整棵树的⼀个局部⼦树，旋转后不会再影响上⼀层，插⼊结束了。</p> <br><div class="img-center"> <br> <figure class="image"> <br>  <img alt="" height="371" src="https://i-blog.csdnimg.cn/direct/5be33b68506d41ff9030ff9f880a793d.png" width="1043" /> <br>  <figcaption><br>    图一 <br>  </figcaption> <br> </figure> <br></div> <br><p> 右单旋代码</p> <br><pre><code class="language-cpp">void RotateR(Node* parent)<br>{<br>	Node* subL = parent->_left;<br>	Node* subLR = subL->_right;<br><br>	parent->_left = subLR;<br>	if (subLR)<br>		subLR->_parent = parent;<br><br>	Node* Pparent = parent->_parent;<br><br>	subL->_right = parent;<br>	parent->_parent = subL;<br><br>	//链接上面的<br>	if (Pparent)<br>	{<br>		subL->_parent = Pparent;<br><br>		if (Pparent->_left == parent)<br>			Pparent->_left = subL;<br>		else<br>			Pparent->_right = subL;<br>	}	<br>	else<br>	{<br>		subL->_parent = nullptr;<br>		_root = subL;<br>	}<br>	parent->_bf = 0;<br>	subL->_bf = 0;<br>}</code></pre> <br><h4> 左单旋</h4> <br><p>• 本图2展⽰的是10为根的树，有a/b/c抽象为三棵⾼度为h的⼦树(h>=0)，a/b/c均符合AVL树的要 求。10可能是整棵树的根，也可能是⼀个整棵树中局部的⼦树的根。这⾥a/b/c是⾼度为h的⼦树， 是⼀种概括抽象表示，他代表了所有右单旋的场景，实际右单旋形态有很多种，具体跟上⾯左旋类 似。</p> <br><p>• 在a⼦树中插⼊⼀个新结点，导致a⼦树的⾼度从h变成h+1，不断向上更新平衡因⼦，导致10的平 衡因⼦从1变成2，10为根的树左右⾼度差超过1，违反平衡规则。10为根的树右边太⾼了，需要往 左边旋转，控制两棵树的平衡。</p> <br><p>• 旋转核⼼步骤，因为10 < b⼦树的值 < 15，将b变成10的右⼦树，10变成15的左⼦树，15变成这棵 树新的根，符合搜索树的规则，控制了平衡，同时这棵的⾼度恢复到了插⼊之前的h+2，符合旋转原则。如果插⼊之前10整棵树的⼀个局部⼦树，旋转后不会再影响上⼀层，插⼊结束了。</p> <br><figure class="image"> <br> <img alt="" height="349" src="https://i-blog.csdnimg.cn/direct/be4bee4b1c924a20bd81760021965e91.png" width="1008" /> <br> <figcaption><br>   图二 <br> </figcaption> <br></figure> <br><p>左单旋代码实现 </p> <br><pre><code class="language-cpp">void RotateL(Node* parent)<br>{<br>	Node* subR = parent->_right;<br>	Node* subRL = subR->_left;<br><br>	parent->_right = subRL;<br>	if (subRL)<br>		subRL->_parent = parent;<br><br>	Node* Pparent = parent->_parent;<br><br>	subR->_left = parent;<br>	parent->_parent = subR;<br><br>	if (Pparent)<br>	{<br>		if(Pparent->_left == parent)<br>			Pparent->_left = subR;<br>		else<br>			Pparent->_right = subR;<br><br>		subR->_parent = Pparent;<br>	}<br>	else<br>	{<br>		_root = subR;<br>		subR->_parent = nullptr;<br>	}<br>	subR->_bf = 0;<br>	parent->_bf = 0;<br>}</code></pre> <br><h4>左右双旋</h4> <br><p>通过图3和图4可以看到，左边⾼时，如果插⼊位置不是在a⼦树，⽽是插⼊在b⼦树，b⼦树⾼度从h变 成h+1，引发旋转，右单旋⽆法解决问题，右单旋后，我们的树依旧不平衡。右单旋解决的纯粹的左边 ⾼，但是插⼊在b⼦树中，10为跟的⼦树不再是单纯的左边⾼，对于10是左边⾼，但是对于5是右边 ⾼，需要⽤两次旋转才能解决，以5为旋转点进⾏⼀个左单旋，以10为旋转点进⾏⼀个右单旋，这棵树这棵树就平衡了。</p> <br><figure class="image"> <br> <img alt="" height="388" src="https://i-blog.csdnimg.cn/direct/25bc5c571dac411eb82618ac4ec8abc5.png" width="1031" /> <br> <figcaption><br>   图三 <br> </figcaption> <br></figure> <br><figure class="image"> <br> <img alt="" height="403" src="https://i-blog.csdnimg.cn/direct/9043ecf2fac74905a544c16844023419.png" width="1044" /> <br> <figcaption><br>   图四 <br> </figcaption> <br></figure> <br><p>图3和图4分别为左右双旋中h==0和h==1具体场景分析，下⾯我们将a/b/c⼦树抽象为⾼度h的AVL ⼦树进⾏分析，另外我们需要把b⼦树的细节进⼀步展开为8和左⼦树⾼度为h-1的e和f⼦树，因为 我们要对b的⽗亲5为旋转点进⾏左单旋，左单旋需要动b树中的左⼦树。b⼦树中新增结点的位置 不同，平衡因⼦更新的细节也不同，通过观察8的平衡因⼦不同，这⾥我们要分三个场景讨论。</p> <br><p>• 场景1：h >= 1时，新增结点插⼊在e⼦树，e⼦树⾼度从h-1并为h并不断更新8->5->10平衡因⼦， 引发旋转，其中8的平衡因⼦为-1，旋转后8和5平衡因⼦为0，10平衡因⼦为1。</p> <br><p>• 场景2：h >= 1时，新增结点插⼊在f⼦树，f⼦树⾼度从h-1变为h并不断更新8->5->10平衡因⼦，引 发旋转，其中8的平衡因⼦为1，旋转后8和10平衡因⼦为0，5平衡因⼦为-1。</p> <br><p>• 场景3：h == 0时，a/b/c都是空树，b⾃⼰就是⼀个新增结点，不断更新5->10平衡因⼦，引发旋 转，其中8的平衡因⼦为0，旋转后8和10和5平衡因⼦均为0。</p> <br><p><img alt="" height="986" src="https://i-blog.csdnimg.cn/direct/a5824c78adc84f21b52b54f9dfa83960.png" width="745" /></p> <br><p>左右双旋实现代码</p> <br><pre><code class="language-cpp">void RotateLR(Node* parent)<br>{<br>	Node* subL = parent->_left;<br>	Node* subLR = subL->_right;<br><br>	int bf = subLR->_bf;<br><br>	RotateL(subL);<br>	RotateR(parent);<br><br>	if (bf == 0)<br>	{<br>		subL->_bf = 0;<br>		subLR->_bf = 0;<br>		parent->_bf = 0;<br>	}<br>	else if (bf == 1)<br>	{<br>		subL->_bf = -1;<br>		subLR->_bf = 0;<br>		parent->_bf = 0;<br>	}<br>	else if (bf == -1)<br>	{<br>		subL = 0;<br>		subLR->_bf = 0;<br>		parent->_bf = 1;<br>	}<br>	else<br>		assert(false);<br>}</code></pre> <br><h4>右左双旋</h4> <br><p>• 跟左右双旋类似，下⾯我们将a/b/c⼦树抽象为⾼度h的AVL⼦树进⾏分析，另外我们需要把b⼦树的 细节进⼀步展开为12和左⼦树⾼度为h-1的e和f⼦树，因为我们要对b的⽗亲15为旋转点进⾏右单 旋，右单旋需要动b树中的右⼦树。b⼦树中新增结点的位置不同，平衡因⼦更新的细节也不同，通 过观察12的平衡因⼦不同，这⾥我们要分三个场景讨论。</p> <br><p>• 场景1：h >= 1时，新增结点插⼊在e⼦树，e⼦树⾼度从h-1变为h并不断更新12->15->10平衡因 ⼦，引发旋转，其中12的平衡因⼦为-1，旋转后10和12平衡因⼦为0，15平衡因⼦为1。</p> <br><p>• 场景2：h >= 1时，新增结点插⼊在f⼦树，f⼦树⾼度从h-1变为h并不断更新12->15->10平衡因⼦， 引发旋转，其中12的平衡因⼦为1，旋转后15和12平衡因⼦为0，10平衡因⼦为-1。 </p> <br><p>• 场景3：h == 0时，a/b/c都是空树，b⾃⼰就是⼀个新增结点，不断更新15->10平衡因⼦，引发旋 转，其中12的平衡因⼦为0，旋转后10和12和15平衡因⼦均为0。 </p> <br><p><img alt="" height="980" src="https://i-blog.csdnimg.cn/direct/8edfec6304444ce6893d2cf981b355c7.png" width="729" /></p> <br><pre><code class="language-cpp">void RotateRL(Node* parent)<br>{<br>	Node* subR = parent->_right;<br>	Node* subRL = subR->_left;<br><br>	int bf = subRL->_bf;<br><br>	RotateR(subR);<br>	RotateL(parent);<br><br>	if (bf == 0)<br>	{<br>		subR->_bf = 0;<br>		subRL->_bf = 0;<br>		parent->_bf = 0;<br>	}<br>	else if (bf == -1)<br>	{<br>		subR->_bf = 1;<br>		subRL->_bf = 0;<br>		parent->_bf = 0;<br>	}<br>	else if (bf == 1)<br>	{<br>		subR->_bf = 0;<br>		subRL->_bf = 0;<br>		parent->_bf = -1;<br>	}<br>	else<br>		assert(false);<br>}</code></pre> <br><p style="text-align:center;"> <strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong> </p>