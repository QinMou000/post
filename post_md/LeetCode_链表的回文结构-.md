<blockquote> <br> <p><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6f2b920cd38b273e9349974209147fee.png" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12596977.html?spm=1001.2014.3001.5482" title="LeetCode刷题专栏">LeetCode刷题专栏</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>题目描述：</h2> <br><p>对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。给定一个链表的头指针A，请返回一个bool值，代表其是否为回文结构。保证链表长度小于等于900。</p> <br><blockquote> <br> <p>就比如：1->2->3->2->1就是回文链表，1->2->3->1->2不是回文链表。</p> <br></blockquote> <br><h3>示例代码：</h3> <br><pre><code class="language-cpp">class PalindromeList {<br>public:<br>    bool chkPalindrome(ListNode* A) {<br>        // write code here<br>};</code></pre> <br><h2> 分析：</h2> <br><blockquote> <br> <p>这里我们得到解法是先找到链表的中间节点，之后将中间节点后面的节点全部逆置。之后再从mid节点和链表头节点开始遍历、判断值是否相同，以mid节点和链表头节点都不为空为循环条件。</p> <br></blockquote> <br><p style="text-align:center;"><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/d71364f47c2708db79cd161e09019e48.png" /></p> <br><h3> 所以这里我们先要写出找中间节点的代码：</h3> <br><blockquote> <br> <p>以前做过类似的题《快慢指针》。快指针一次走两步，慢指针一次走一步。最终慢指针会停在中间节点处。</p> <br></blockquote> <br><p><span style="color:#be191c;"> <strong>注意：这里while循环的条件不能把fast->next放在前面，要先判断的fast不为空，再判断fast的下一个节点是否为空。否则会导致空指针的解引用。</strong></span></p> <br><pre><code class="language-cpp">struct ListNode* middleNode(struct ListNode* head) {<br>    struct ListNode* fast = head, *slow = head;<br>    while(fast && fast->next) {<br>        slow = slow->next;<br>        fast  = fast->next->next;<br>    }<br>    return slow;<br>}</code></pre> <br><h3>链表逆置代码：</h3> <br><pre><code class="language-cpp">struct ListNode* ReverseList(struct ListNode* head ) {<br>    struct ListNode* pcur = head;<br>    struct ListNode* prev = NULL;<br>    while(pcur)<br>    {<br>        struct ListNode* tmp = pcur->next;<br>        pcur->next = prev;<br>        prev = pcur;<br>        pcur = tmp;<br>    }    <br>    return prev;<br>}</code></pre> <br><h3> 主代码：</h3> <br><pre><code class="language-cpp">class PalindromeList {<br>public:<br>    bool chkPalindrome(ListNode* A) {<br>        // write code here<br>    struct ListNode* mid = middleNode(A); <br>    struct ListNode* rmid = ReverseList(mid);<br>    while(A && rmid)<br>    {<br>        if(A->val != rmid->val)<br>            return false;<br>        A = A->next;<br>        rmid = rmid->next;<br>    }<br>    return true;<br>    }<br>};</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>