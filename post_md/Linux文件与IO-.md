<blockquote> <br> <p style="text-align:center;"><img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/a46182e6318c4593a5c674f2bf9439d4.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12799988.html" title="Linux">Linux</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2><span style="color:#0d0016;">理解文件</span></h2> <br><ul><li><span style="color:#0d0016;">⽂件在磁盘⾥ </span></li><li><span style="color:#0d0016;">磁盘是永久性存储介质，因此⽂件在磁盘上的存储是永久性的 </span></li><li><span style="color:#0d0016;">磁盘是外设（即是输出设备也是输⼊设备） </span></li><li><span style="color:#0d0016;">磁盘上的⽂件本质是对⽂件的所有操作，都是对外设的输⼊和输出简称 IO</span></li><li><span style="color:#0d0016;">文件 = 文件属性 + 文件内容</span></li><li><span style="color:#0d0016;">0 kb的空文件也是在磁盘中占用空间的</span></li><li><span style="color:#0d0016;">对文件的操作无非都是<strong>进程对属性的操作和对内容的操作</strong></span></li><li><span style="color:#0d0016;">磁盘的管理者是操作系统</span></li><li> <br>  <div> <br>   <span style="color:#0d0016;">⽂件的读写本质不是通过 C 语⾔ / C++ 的库函数来操作的（这些库函数只是为⽤户提供⽅便），⽽是通过⽂件相关的系统调⽤接⼝来实现的</span> <br>  </div> </li></ul> <br><p><span style="color:#0d0016;">广义上对文件的理解：可以认为在</span><span style="color:#ed7976;"><em>Linux</em></span><span style="color:#0d0016;">下一切皆文件（键盘，显示器，网卡，磁盘……）</span><span style="color:#ed7976;"><em>Linux</em></span><span style="color:#0d0016;">下都把它们做了抽象。</span></p> <br><h2><span style="color:#0d0016;">回顾C语言的文件操作</span></h2> <br><p><span style="color:#0d0016;"> 回顾C语言文件操作接口：<a href="https://blog.csdn.net/2301_80194476/article/details/137158855" title="C语言中的文件和文件操作">C语言中的文件和文件操作</a></span></p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td> <p><span style="color:#0d0016;">文件操作函数</span></p> </td><td><span style="color:#0d0016;">    功能</span></td></tr><tr><td><span style="color:#0d0016;">fopen</span></td><td><span style="color:#0d0016;">打开文件</span></td></tr><tr><td><span style="color:#0d0016;">fclose</span></td><td><span style="color:#0d0016;">关闭文件</span></td></tr><tr><td><span style="color:#0d0016;">fputc</span></td><td><span style="color:#0d0016;">写入一个字符</span></td></tr><tr><td><span style="color:#0d0016;">fgetc</span></td><td><span style="color:#0d0016;">读取一个字符</span></td></tr><tr><td><span style="color:#0d0016;">fputs</span></td><td><span style="color:#0d0016;">写入一个字符串</span></td></tr><tr><td><span style="color:#0d0016;">fgets</span></td><td><span style="color:#0d0016;">读取一个字符串</span></td></tr><tr><td><span style="color:#0d0016;">fprintf</span></td><td><span style="color:#0d0016;">格式化写入数据</span></td></tr><tr><td><span style="color:#0d0016;">fscanf</span></td><td><span style="color:#0d0016;">格式化读取数据</span></td></tr><tr><td><span style="color:#0d0016;">fwrite</span></td><td><span style="color:#0d0016;">向二进制文件写入数据</span></td></tr><tr><td><span style="color:#0d0016;">fread</span></td><td><span style="color:#0d0016;">从二进制文件读取数据</span></td></tr><tr><td><span style="color:#0d0016;">fseek</span></td><td><span style="color:#0d0016;">设置文件指针的位置</span></td></tr><tr><td><span style="color:#0d0016;">ftell</span></td><td><span style="color:#0d0016;">计算当前文件指针相对于起始位置的偏移量</span></td></tr><tr><td><span style="color:#0d0016;">rewind</span></td><td><span style="color:#0d0016;">设置文件指针到文件的起始位置</span></td></tr><tr><td><span style="color:#0d0016;">ferro</span></td><td><span style="color:#0d0016;">判断文件操作过程中是否发生错误</span></td></tr><tr><td><span style="color:#0d0016;">feof</span></td><td><span style="color:#0d0016;">判断文件指针是否读取到文件末尾</span></td></tr></tbody></table> <br><p> 打开一个文件的模式：</p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:134px;"><span style="color:#0d0016;">文件使用方式</span></td><td style="width:310px;"><span style="color:#0d0016;">含义</span></td><td><span style="color:#0d0016;">如果指定文件不存在</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“r”（只读）   </span></td><td style="width:310px;"><span style="color:#0d0016;"> 为了输⼊数据，打开⼀个已经存在的⽂本⽂件  </span></td><td><span style="color:#0d0016;"> 出错</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“w”（只写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了输出数据，打开⼀个⽂本⽂件</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“a”（追加）  </span></td><td style="width:310px;"><span style="color:#0d0016;"> 向⽂本⽂件尾添加数据   </span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“rb”（只读）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了输⼊数据，打开⼀个⼆进制⽂件</span></td><td><span style="color:#0d0016;">出错</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“wb”（只写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了输出数据，打开⼀个⼆进制⽂件</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“ab”（追加）</span></td><td style="width:310px;"><span style="color:#0d0016;">向⼀个⼆进制⽂件尾添加数据</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“r+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了读和写，打开⼀个⽂本⽂件</span></td><td><span style="color:#0d0016;">出错</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“w+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了读和写，建议⼀个新的⽂件</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“a+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">打开⼀个⽂件，在⽂件尾进⾏读写</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“rb+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了读和写打开⼀个⼆进制⽂件</span></td><td><span style="color:#0d0016;">出错</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“wb+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">为了读和写，新建⼀个新的⼆进制⽂件</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr><tr><td style="width:134px;"><span style="color:#0d0016;">“ab+”（读写）</span></td><td style="width:310px;"><span style="color:#0d0016;">打开⼀个⼆进制⽂件，在⽂件尾进⾏读和写</span></td><td><span style="color:#0d0016;">建⽴⼀个新的⽂件</span></td></tr></tbody></table> <br><p>示例</p> <br><pre><code class="language-cpp">#include<stdio.h><br>int main()<br>{<br>    FILE*fp=fopen("log.txt","w");<br>    if(fp==NULL)<br>    {<br>        perror("fopen fail:");<br>        return 1;<br>    }<br>    //open success<br>    const char*msg="hello Qin!\n";<br>    int count=5;<br>    while(count--)<br>    {<br>        fputs(msg,fp);<br>    }<br>    fclose(fp);<br>    return 0;<br>}<br></code></pre> <br><p>进程在当前目录下新建文件并写入 </p> <br><p><img alt="" height="396" src="https://i-blog.csdnimg.cn/direct/215ffb7f457642059090d1bf449d45c9.png" width="817" /><img alt="" height="238" src="https://i-blog.csdnimg.cn/direct/e61002f9bb1649b0aaeec4b4585464f4.png" width="829" /></p> <br><p><span style="color:#0d0016;">一般而言如果没有定义对应</span><span style="color:#ed7976;"><em>log.txt</em></span><span style="color:#0d0016;">文件，系统会在当前路径自动创建该文件。并且当前路径并不是指可执行程序所处的路径，而是指该可执行程序运行成为进程时我们所处的路径。</span>并且当前路径并不是指可执行程序所处的路径，而是指该可执行程序运行成为进程时我们所处的路径。比如我们可以在上级目录执行<span style="color:#ed7976;"><em>test </em></span>文件：</p> <br><p><img alt="" height="115" src="https://i-blog.csdnimg.cn/direct/c2492edd1a9e4aaca65a62086738efce.png" width="939" /> <span style="color:#0d0016;">打开⽂件，本质是进程打开，所以，进程知道⾃⼰在哪⾥（环境变量</span><span style="color:#ed7976;"><em>cwd </em></span><span style="color:#0d0016;">等等），即便⽂件不带路径，进程也知道。由此</span><span style="color:#ed7976;"><em>OS </em></span><span style="color:#1f2329;">就能知道要创建的⽂件放在哪⾥。</span></p> <br><p><span style="color:#1f2329;">可以使⽤ </span><span style="color:#ed7976;"><em>ls /proc/[进程id] -l</em></span><span style="color:#1f2329;"> </span><span style="color:#1f2329;">命令查看当前正在运⾏进程的信息：</span>  </p> <br><p><img alt="" height="422" src="https://i-blog.csdnimg.cn/direct/fae123f6b5214cd69f2409f8882060d3.png" width="866" /></p> <br><p>然后我们可以看见两个软连接</p> <br><ul><li><span style="color:#ed7976;"><em>cwd</em></span>：<span style="color:#646a73;">指向当前进程运⾏⽬录的⼀个符号链接。</span></li><li><span style="color:#ed7976;"><em>exe</em></span>：<span style="color:#646a73;">指向启动当前进程的可执⾏⽂件（完整路径）的符号链接。</span></li></ul> <br><h2> 三个默认打开流</h2> <br><p>我们常说<span style="color:#ed7976;"><em>Linux</em></span>下一切皆文件，那么我们的键盘与显示器自然也是文件。我们向键盘输入数据，本质就是操作系统向键盘文件中读取数据；我们能从显示器看见数据，本质就是操作系统向显示器文件写入数据。但是我们在使用键盘与显示器时并没有手动进行任何文件相关的读写操作，那我们又是如何对键盘文件与显示器文件进行读写的呢？</p> <br><p>答案自然是操作系统自动帮我们打开的，任何进程在运行时，操作系统都会默认打开三个输入输出流，分别为：标准输入流，标准输出流以及标准错误流。<span style="color:#b95514;"><strong>对于C语言分别就是：stdin、stdout以及stderr。对于C++分别就是：cin、cout和cerr，自然其他语言也会有相似的概念，因为这是操作系统所支持的，而不是某个语言所独有的。</strong></span></p> <br><p>我们可以在Linux中的man查看对应的声明：</p> <br><p><img alt="" height="366" src="https://i-blog.csdnimg.cn/direct/039312c2bd43424bb12de05d3c48aeb0.png" width="806" /></p> <br><p>其中标准输入流对应的就是我们的键盘，而标准输出流与标准错误流对应的就是我们显示器。</p> <br><p>其中我们也可以通过<span style="color:#ed7976;"><em>fputs </em></span>函数验证一下：</p> <br><pre><code class="language-cpp">#include<stdio.h><br>int main()<br>{<br>  //向显示器打印<br>  fputs("hello QinMou!\n",stdout);<br>  fputs("hello QinMou!\n",stdout);<br>  fputs("hello QinMou!\n",stdout);<br>  fputs("hello QinMou!\n",stdout);<br>  return 0;<br>}</code></pre> <br><p><img alt="" height="133" src="https://i-blog.csdnimg.cn/direct/3c9bac76365940e3854034dad94dd03a.png" width="506" /></p> <br><h2>系统调用文件接口 </h2> <br><p>在前面我们学习操作系统时知道，为了方便用户使用，一般我们会对系统接口进行封装。我们的文件操作也不例外，像<span style="color:#ed7976;"><em>fopen</em></span>、<span style="color:#ed7976;"><em>fclose </em></span>等接口本质其实对操作系统提供的文件接口的封装。接下来我们就来学习一下系统提供的文件接口。 </p> <br><h3>open函数</h3> <br><p>首先我们来介绍文件打开操作的系统接口。</p> <br><p><img alt="" height="197" src="https://i-blog.csdnimg.cn/direct/ae0d1e82ae0e43ceb61f355ed555652a.png" width="651" /></p> <br><ul><li>pathname：表示打开或者创建的目标文件，若pathname以路径的方式给出，则当需要创建该文件时，就在pathname路径下进行创建。若pathname以文件名的方式给出，则当需要创建该文件时，默认在当前路径下进行创建。</li><li>flags：表示打开文件的方式。</li><li>mode：表示创建文件的默认权限(八进制数)。</li></ul> <br><p> 其中常用文件打开方式有如下几个：</p> <br><table><thead><tr><th>参数选项</th><th>含义</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>以只读的方式打开文件</td></tr><tr><td>O_WRNOLY</td><td>以只写的方式打开文件</td></tr><tr><td>O_APPEND</td><td>以追加的方式打开文件</td></tr><tr><td>O_RDWR</td><td>以读写的方式打开文件</td></tr><tr><td>O_CREAT</td><td>当目标文件不存在时，创建文件</td></tr></tbody></table> <br><p>参数 <span style="color:#ed7976;"><em>flags </em></span>使用了位图的传参方式，如果想同时兼具多个打开方式，可以使用逻辑与 | 链接两个选项。比如说我们想打开文件并且文件不存在时创建文件，可以写成：</p> <br><pre><code class="language-cpp">O_WRNOLY | O_CREAT</code></pre> <br><p>所以我们也可以使用按位与<code>&</code>操作来检测是否设置某个选项：</p> <br><pre><code class="language-cpp">if (flags&O_RDONLY){<br>    //设置了O_RDONLY选项<br>}<br>if (flags&O_WRONLY){<br>    //设置了O_WRONLY选项<br>}<br>if (flags&O_RDWR){<br>    //设置了O_RDWR选项<br>}<br>if (flags&O_CREAT){<br>    //设置了O_CREAT选项<br>}<br>//...<br></code></pre> <br><p>并且如果我们打开的文件已存在就使用两个参数的接口，如果打开的文件不存在就需要使用三个参数的接口，即需要为创建的文件设置默认权限。</p> <br><p><a href="https://blog.csdn.net/2301_80194476/article/details/143259081?spm=1001.2014.3001.5502" title="Linux：权限-CSDN博客">Linux：权限-CSDN博客</a></p> <br><p>如果我们要为文件设置默认权限，就需要考虑文件默认掩码umask的影响。我们之前讲过文件的默认权限为：mode&(~mask)，我们除了可以在命令行通过指令umask 八进制数来修改默认的掩码umask(默认为002)外，还能在程序中调用umask函数进行修改。比如我们将umask设置为0：</p> <br><pre><code class="language-cpp">umask(0); // 将文件默认掩码设置为0</code></pre> <br><p>最后再来探究一下<span style="color:#ed7976;"><em>open </em></span>的返回值，也就是文件描述符 <em><span style="color:#ed7976;">fd</span></em></p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include <sys/types.h><br>#include <sys/stat.h><br>#include <fcntl.h><br>int main()<br>{<br>    umask(0);//设置文件掩码为0<br>    int fd1 = open("log1.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd2 = open("log2.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd3 = open("log3.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd4 = open("log4.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd5 = open("log5.txt", O_RDONLY | O_CREAT, 0666);<br>	printf("fd1:%d\n", fd1);<br>	printf("fd2:%d\n", fd2);<br>	printf("fd3:%d\n", fd3);<br>	printf("fd4:%d\n", fd4);<br>	printf("fd5:%d\n", fd5);<br>    return 0;<br>}</code></pre> <br><p><img alt="" height="253" src="https://i-blog.csdnimg.cn/direct/1c30425fb0ab41c98a6a10858d9a2dcc.png" width="822" /></p> <br><p>运行之后我观察到文件描述符是从3开始的，并且依次递增，这起始并不是偶然。0 1 2系统默认给了标准输入，标准输出，标准错误。</p> <br><p>当然这只是文件成功返回的情况，如果文件打开失败，那将返回-1。</p> <br><h3>close函数 </h3> <br><p>我们可以调用系统接口<span style="color:#ed7976;"><em>close </em></span>来关闭指定文件，其原型为： </p> <br><p><img alt="" height="359" src="https://i-blog.csdnimg.cn/direct/71bd68cbdec34c55ac7bfd62f8bad345.png" width="1106" />使用<span style="color:#ed7976;"><em>close</em></span> 函数时传入需要关闭文件的文件描述符即可，若关闭文件成功则返回0，若关闭文件失败则返回-1。 </p> <br><h3> write函数</h3> <br><p>同样我们也能通过系统接口<span style="color:#ed7976;"><em>write </em></span>对文件进行写入，其原型为： </p> <br><p><img alt="" height="185" src="https://i-blog.csdnimg.cn/direct/3d0a4c1e3cc54f70b73ec6674071e2ec.png" width="763" /></p> <br><p>其中<span style="color:#ed7976;"><em>fd </em></span>指的是文件描述符，<span style="color:#ed7976;"><em>buf </em></span>为用户缓冲区，而<span style="color:#ed7976;"><em>count </em></span>为<span style="color:#b95514;"><strong>期望写的字节数。如果写入成功返回实际写入的字节数，若写入失败则返回-1。</strong></span></p> <br><blockquote> <br> <p>注意：ssize_t其实就是一个有符号整型，具体来说就是被typedef重新定义过：typedef int ssize_t</p> <br></blockquote> <br><p>以下我们可以利用write函数对一个log.txt文件进行写入：</p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<unistd.h><br>#include<sys/types.h><br>#include<sys/stat.h><br>#include<fcntl.h><br>#include<string.h><br>int main()<br>{<br>    int fd = open("log.txt",O_WRONLY | O_CREAT);<br>    if(fd < 0)<br>    {<br>        //open error<br>        perror("open fail:");<br>        return 1;<br>    }<br>    const char* msg = "hello QinMou!\n";<br>    for(int i = 0; i < 8; i++)<br>    {<br>        write(fd, msg, strlen(msg));<br>    }<br>    close(fd);<br>    return 0;<br>}<br></code></pre> <br><p><img alt="" height="220" src="https://i-blog.csdnimg.cn/direct/68d043f4b25e4751a783e9ccaac9c086.png" width="731" /></p> <br><h3>read函数 </h3> <br><p>同样我们也能通过系统接口<span style="color:#ed7976;"><em>read</em></span> 对文件进行读写，其原型为： </p> <br><p><img alt="" height="235" src="https://i-blog.csdnimg.cn/direct/ee958bc00b624e0085142083a9ebc7b2.png" width="869" /></p> <br><p>其中<em><span style="color:#ed7976;">fd </span></em>指的是文件描述符，<span style="color:#ed7976;"><em>buf</em></span> 为用户缓冲区，而<span style="color:#ed7976;"><em>count </em></span>为期望读的字节数。如果读出成功返回实际读出的字节数，若读出失败则返回 -1。</p> <br><p>以下我们可以利用<span style="color:#ed7976;"><em>read </em></span>函数对一个<span style="color:#ed7976;"><em>log.txt </em></span>文件进行读出：</p> <br><pre><code class="language-cpp">#include<sys/types.h><br>#include<sys/stat.h><br>#include<fcntl.h><br>#include<string.h><br>int main()<br>{<br>    int fd = open("log.txt", O_RDONLY);<br>    if(fd < 0)<br>    {<br>        perror("open fail:");<br>        return 1;<br>    }<br>    char buf[1024] = {'\0'};<br>    ssize_t ret = read(fd, buf, 1023);<br>    if(ret > 0) printf("%s",buf);<br>    <br>    close(fd);<br>    return 0;<br>}</code></pre> <br><p> <img alt="" height="202" src="https://i-blog.csdnimg.cn/direct/c195816cc30c40e2a448a5984f580c70.png" width="752" /></p> <br><h2 style="background-color:transparent;">文件描述符——fd </h2> <br><p>在我们的操作系统中，文件是由我们进程所打开的，存在大量进程就意味着存在大量被打开的文件。为了方便我们对文件进行管理，我们就将每个文件<span style="color:#ed7976;"><em>struct file </em></span>链入我们的双向链表之中。 </p> <br><pre><code class="language-cpp">struct File<br>{<br>  //包含了打开文件的相关属性<br>  //链接属性<br>};<br></code></pre> <br><p><img alt="" height="457" src="https://i-blog.csdnimg.cn/direct/690c342169af46baaa42165543d20971.png" width="1063" /></p> <br><p>而一个文件也可能被多个进程所读写，为了让操作系统能够准确识别每个进程对应的文件，我们就一定要让进程与我们的文件建立联系。事实也是如此，我们的进程控制块<span style="color:#ed7976;"><em>task_struct </em></span>中就存在一个指针指向一个名为<em><span style="color:#ed7976;">struct file_struct </span></em>的结构体，这个结构体中存在一个结构体指针数组<span style="color:#ed7976;"><em>struct file*fd_array[] </em></span>分别存放着着每个文件<span style="color:#ed7976;"><em>struct file </em></span>的地址。这样我们的进程就与文件建立起了联系。</p> <br><p><img alt="" height="339" src="https://i-blog.csdnimg.cn/direct/b6c0194390564a75a193ea4621d77f96.png" width="944" /> <img alt="" height="278" src="https://i-blog.csdnimg.cn/direct/2dcabbfc13714c058742a3d6915fe8d2.png" width="718" /></p> <br><p><img alt="" height="848" src="https://i-blog.csdnimg.cn/direct/0fa988e7a5ad4c1daacdbeefbe2a4294.png" width="1200" /></p> <br><p></p> <br><p>一般我们的指针数组<span style="color:#ed7976;"><em>struct file*fd_array[] </em></span>的<strong><span style="color:#b95514;">0，1，2下标分别对应我们的标准输入流，标准输出流，标准错误流这三个文件</span></strong>，而这些<strong><span style="color:#b95514;">下标就是我们所说的文件描述符——fd。</span></strong>这也解释了我们打开文件的描述符为什么从3开始，并且依次递增。并且，通过对应的文件描述符，进程只需要找到对应的指针数组<em><span style="color:#ed7976;">fd_array </span></em>就能访问对应的文件，这也是为什么我们文件的系统调用接口的参数一定会有<span style="color:#ed7976;"><em>fd </em></span>的原因。</p> <br><p>当然如果我们在中途关掉某个文件，操作系统就会为该下标重新分配对应的文件。 </p> <br><pre><code class="language-cpp">#include <stdio.h><br>#include <sys/stat.h><br>#include <sys/types.h><br>#include <fcntl.h><br>int main()<br>{<br>    close(0);<br>    close(2);<br>	int fd1 = open("log1.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd2 = open("log2.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd3 = open("log3.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd4 = open("log4.txt", O_RDONLY | O_CREAT, 0666);<br>	int fd5 = open("log5.txt", O_RDONLY | O_CREAT, 0666);<br>	printf("fd1:%d\n", fd1);<br>	printf("fd2:%d\n", fd2);<br>	printf("fd3:%d\n", fd3);<br>	printf("fd4:%d\n", fd4);<br>	printf("fd5:%d\n", fd5);<br>	return 0;<br>}<br></code></pre> <br><p> </p> <br><p class="img-center"><img alt="" height="128" src="https://i-blog.csdnimg.cn/direct/ce4d49accaa94bcf8840340aa60fcafa.png" width="462" /></p> <br><p>我们也知道，当一个程序运行起来时，操作系统会将该程序的代码和数据加载到内存，然后为其创建对应的<em><span style="color:#ed7976;">task_struct、mm_struct</span></em>、页表等相关的数据结构，并通过页表建立虚拟内存和物理内存之间的映射关系。如果与我们的文件管理联系起来，就是一个磁盘文件<span style="color:#ed7976;"><em>log.txt </em></span>加载进内存形成内存文件，最后加入对应双向链表中管理起来。</p> <br><p><img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/beccafa9b6a84c61b5ca42ee7b9cb165.png" width="1200" /></p> <br><p>当文件存储在磁盘上时，我们称之为磁盘文件。而当磁盘文件被加载到内存中后，就变成了内存文件。磁盘文件与内存文件的关系，恰似程序和进程的关系。程序在运行起来后成为进程，同样，磁盘文件在加载到内存后成为内存文件。磁盘文件主要由两部分构成，即文件内容和文件属性。文件内容指的是文件中存储的数据，而文件属性则是文件的一些基本信息，包括文件名、文件大小以及文件创建时间等。这些文件属性也被称为元信息。在文件加载到内存的过程中，一般会先加载文件的属性信息。这是因为在很多情况下，我们可能只需要了解文件的基本属性，而不一定立即需要对文件内容进行操作。当确实需要对文件内容进行读取、输入或输出等操作时，才会延后式地加载文件数据。这样的设计可以提高系统的效率，避免在不必要的时候浪费资源加载大量的文件数据。</p> <br><h2>重定向原理</h2> <br><p>重定向的底层原理就是修改进程的文件结构体指针数组，例如将原本输出到屏幕的信息输出到一个文件中只需要将fd为1的位置修改为指向相应的文件结构体就行了。</p> <br><h3 style="background-color:transparent;">输出重定向</h3> <br><p>输出重定向的本质就是，将我们本应该输出到一个文件的数据重定向输出到另一个文件中，即关闭对应标准输出流的文件描述符1，然后让该文件描述符重新指向新的文件，最后如果我们再对该文件描述符进行<span style="color:#b95514;"><strong>写入</strong></span>，本应该打印在屏幕的数据就重定向进入新文件。 </p> <br><p><img alt="" height="996" src="https://i-blog.csdnimg.cn/direct/431b83547f8645348405fbe497937a0d.png" width="1200" /></p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<sys/stat.h><br>#include<fcntl.h><br>#include<sys/types.h><br><br>int main()<br>{<br>    close(1); // 关闭标准输出流<br>    int fd = open("log.txt", O_WRONLY | O_CREAT, 0666);<br>    if(fd < 0)<br>    {<br>        perror("open failed");<br>        return 1;<br>    }<br>    printf("Hello, world\n");<br>    printf("Hello, world\n");<br>    printf("Hello, world\n");<br>    fflush(stdout);<br>    close(fd);<br>    return 0;<br>}</code></pre> <br><p>此时输出的信息在语言缓冲区里面， 还没有刷新到系统缓冲区中，也就写不到文件中，需要用fflush函数提前刷新，详细见后文。</p> <br><p class="img-center"><img alt="" height="179" src="https://i-blog.csdnimg.cn/direct/00602e50c67743c7a1f3805b62c3f8e6.png" width="883" /></p> <br><p>本应将信息写入（打印）屏幕上，现在却写进了log.txt文件里，这就是输出重定向。 </p> <br><h3>输入重定向</h3> <br><p>输入重定向的本质也是与输出重定向同理，将我们本应该输入到一个文件的数据重定向输入到另一个文件中，即关闭对应标准输出流的文件描述符0，然后让该文件描述符重新指向新的文件，最后如果我们再对该文件描述符进行<strong><span style="color:#b95514;">读取</span></strong>，本应该从键盘读取的数据就重定向变为从新文件读取。</p> <br><p><img alt="" height="988" src="https://i-blog.csdnimg.cn/direct/83cb39fb3ff04a499a6af88495f9dcc1.png" width="1200" /></p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<sys/stat.h><br>#include<fcntl.h><br>#include<sys/types.h><br><br>int main()<br>{<br>    close(0);<br>    int fd = open("log.txt", O_RDONLY);<br>    if(fd < 0)<br>    {<br>        perror("open failed");<br>        return 1;<br>    }<br>    char buf[128] = {0};<br>    while(scanf("%s", buf) != EOF)<br>    {<br>        printf("%s\n", buf);<br>    }<br>    close(fd);<br>    return 0;<br>}</code></pre> <br><p><img alt="" height="154" src="https://i-blog.csdnimg.cn/direct/a2de2934d5f446adbb9d7f8ba8e51c6c.png" width="860" /></p> <br><p>本应该向标准输入读取的，现在成了从log.txt文件中读取，这就是输入重定向。</p> <br><h3>追加重定向</h3> <br><p>追加重定向相对于输出重定向的区别仅仅是，将打开文件的方式改为追加打开即可</p> <br><pre><code class="language-cpp">int fd = open("log.txt", O_WRONLY | O_APPEND | O_CREAT, 0666);</code></pre> <br><p>标准输出和标准错误对应的设备都是显示器，那么它们有什么区别呢？</p> <br><pre><code class="language-cpp">printf("Hello, world\n");<br>perror("Hello, world\n");<br>fprintf(stdout, "stdout Hello, world\n");<br>fprintf(stderr, "stderr Hello, world\n");</code></pre> <br><p>上面的代码的运行结果重定向到log.txt文件里：</p> <br><p class="img-center"><img alt="" height="134" src="https://i-blog.csdnimg.cn/direct/ce0007866fa947ee82f5ad4a59179ea5.png" width="589" /></p> <br><p>可以发现，标准错误流的信息不会重定向到文件里。 这是因为输出重定向默认关闭的是1号文件描述符，并没有关闭2号文件描述符。</p> <br><p>我们可以使用2>操作将标准错误流重定向到其他文件里。</p> <br><p class="img-center"><img alt="" height="152" src="https://i-blog.csdnimg.cn/direct/d7d9a97f59d74d7588c780ed99718bdb.png" width="660" /></p> <br><p>当然如果想将标准输出与标准输出的内容输出到同一文件中，也可以使用类似的指令。</p> <br><p class="img-center"><img alt="" height="133" src="https://i-blog.csdnimg.cn/direct/4cc14cb3a6a046aabdf0a923af12f022.png" width="606" /></p> <br><h2> dup2函数</h2> <br><p>其中Linux操作系统也为了我们提供了专门的重定向接口——dup2函数</p> <br><ul><li>原型：</li></ul> <br><pre><code class="language-cpp">int dup2(int oldfd, int newfd);</code></pre> <br><ul><li>函数功能：dup2会将fd_array[oldfd]的内容拷贝到fd_array[newfd]当中，如果有必要的话我们需要先关闭文件描述符为newfd的文件。</li><li>函数返回值： 如果调用成功，返回newfd，否则返回-1</li></ul> <br><p><img alt="" height="848" src="https://i-blog.csdnimg.cn/direct/6b05394f7e21496fa8312c28b827922d.png" width="1200" /></p> <br><p><span style="color:#0d0016;">使用dup2函数时，需要注意以下两点：</span></p> <br><ul><li><span style="color:#0d0016;">如果oldfd不是有效的文件描述符，dup2就会调用失败，此时文件描述符为newfd的文件没有被关闭。</span></li><li><span style="color:#0d0016;">如果oldfd是一个有效的文件描述符，但是newfd和oldfd具有相同的值，则dup2不做任何操作，并返回newfd。</span></li></ul> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<sys/stat.h><br>#include<fcntl.h><br>#include<sys/types.h><br>#include<unistd.h><br><br>int main()<br>{<br>    int fd = open("log.txt", O_WRONLY | O_CREAT, 0666);<br>    if(fd < 0)<br>    {<br>        perror("open fail:");<br>        return 1;<br>    }<br>    close(1);<br>    dup2(fd, 1); // 将fd处的指针拷贝到1处，进行重定向<br>    printf("hello printf!\n");<br>    fprintf(stdout, "hello fprintf!\n");<br>    close(fd);<br>    return 0;<br>}</code></pre> <br><h2>缓冲区</h2> <br><h3 style="background-color:transparent;">语言缓冲区</h3> <br><p>在计算机领域，缓冲区是一块存储区域。它用于暂存数据，以协调不同速度的设备或操作之间的数据传输。比如我们再来看看下面这段代码：</p> <br><pre><code class="language-cpp">#include <stdio.h><br>#include <sys/stat.h><br>#include <sys/types.h><br>#include <fcntl.h><br>int main()<br>{<br>    close(1); // 关闭标准输出流<br>    int fd=open("log.txt", O_WRONLY | O_CREAT, 0666);<br>    if(fd<0) <br>    {<br>        perror("open fail:");<br>        return 1;<br>    }<br>    //向屏幕打印信息<br>    printf("hello world!\n");<br>    printf("hello world!\n");<br>    close(fd);<br>    return 0;<br>}         <br></code></pre> <br><p class="img-center"><img alt="" height="79" src="https://i-blog.csdnimg.cn/direct/83228d9a8a014f23bb25e10ef7caa266.png" width="805" /></p> <br><p>为什么没有打印信息呢？其实这就与我们C语言的缓冲区有关，因为缓冲区常见的刷新策略有三种：</p> <br><ul><li>无缓冲</li><li>行缓冲（常见的对显示器进行刷新数据）</li><li>全缓冲（常见的对磁盘文件写入数据）</li></ul> <br><p>其中对于我们的printf函数，如果没有加\n就是全缓冲，否则就是行缓冲。</p> <br><p>因为我们对文件进行了重定向，让本应该向屏幕打印的信息输入进一个磁盘文件，这时缓冲策略就从行缓冲变成了全缓冲，全缓冲需要程序结束之后才会向磁盘刷新文件内容，但是在此之前文件我们已经调用close接口关闭了对于的文件描述符，此时程序结束后就无法找到对应的文件，自然也不会对文件进行任何写入。所以一般为了解决这个问题，我们可以使用fflush函数提前刷新缓冲区。</p> <br><p>由于我们使用的printf是C语言提供的接口，所以这个缓冲区也是C语言提供的，其被包含在名为File的结构体中，不光是缓冲区，文件描述符fd也被包含在其中。这也是为什么C语言的文件接口需要返回File*的原因。</p> <br><h3>系统缓冲区</h3> <br><p>不仅是我们语言方面存在缓冲区，我们操作系统内部也会存在一个缓冲区，我们一般称为<span style="color:#b95514;"><strong>内核缓冲区。</strong></span>同样语言缓冲区刷新到系统缓冲区也遵循三种刷新策略：</p> <br><ul><li>无缓冲。</li><li>行缓冲。（常见的对显示器进行刷新数据）</li><li>全缓冲。（常见的对磁盘文件写入数据）</li></ul> <br><p>所以说我们使用语言所提供的接口如printf对文件进行写入数据，首先会将数据存放在语言缓冲区，然后根据不同的刷新规则再刷新到系统缓冲区中，最后才会将系统缓冲区的数据刷新到磁盘或者对应的外设之中。</p> <br><p class="img-center"><img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/2fa31e24255a41d982074370fc0b7e0d.png" width="831" /></p> <br><p>对于下面的代码：</p> <br><pre><code class="language-cpp">#include <stdio.h><br>#include <unistd.h><br>int main()<br>{<br>	//c<br>	printf("hello printf\n");<br>	fputs("hello fputs\n", stdout);<br>	//system<br>	write(1, "hello write\n", 12);<br>	fork();<br>	return 0;<br>}<br><br></code></pre> <br><p class="img-center"><img alt="" height="308" src="https://i-blog.csdnimg.cn/direct/e09d8ff9dfee4684b55cd0799e0b0dbf.png" width="752" /></p> <br><p><strong>为什么重定向之后的内容会与之前截然不同呢？</strong></p> <br><p>这是因为我们执行可执行程序，<span style="color:#b95514;"><strong>打印到屏幕，默认是行缓冲</strong></span>，所以直接打印所以数据。但是如果我们对数据进行重定向的话，<strong><span style="color:#b95514;">向磁盘写入数据，默认为全缓冲</span></strong>，此时数据都会存在语言缓冲区中。而此时我们创建子进程，<span style="color:#b95514;"><strong>父子进程之间代码数据共享</strong></span>，进程结束之后对语言缓冲区进行刷新，本质就是对数据进行修改，为了进程之间的独立性，就会发生写实拷贝，所以重定向之后C语言接口的数据打印会打印两份。<span style="color:#ff9900;"><strong>而因为系统接口write写入的数据是直接写入系统缓冲区的，不需要发生写实拷贝，所以只打印一份。</strong></span></p> <br><p style="text-align:center;"> <strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>