<blockquote> <br> <p><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6f2b920cd38b273e9349974209147fee.png" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12596977.html?spm=1001.2014.3001.5482" title="LeetCode刷题专栏">LeetCode刷题专栏</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>题目：</h2> <br><p style="text-align:center;"><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/251252e3a58c652b75596993d58b17a6.png" /></p> <br><h2> 题解：</h2> <br><p>看到这个题目首先我们要排除链表逆置的想法，如图、因为c1节点只有一个next指针，逆置后不可能同时指向a2和b3节点。</p> <br><p>其次有的的同学想到一个一个节点来比较值，首先这是错误的。</p> <br><blockquote> <br> <p>第一：AB两个链表的长度不一定相同，不能相比。</p> <br> <p>第二：比较节点中的值有一定的特殊情况，我们要比的时节点的地址。</p> <br></blockquote> <br><h3>常规解法：</h3> <br><blockquote> <br> <p>先分别算出A、B两个链表的长度lenA,lenB，先让长的链表的头指针走|lenA - lenB|,然后再一起走，以longlist != shortlist为循环的终止条件</p> <br></blockquote> <br><pre><code class="language-cpp">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) <br>{   <br>    int lenA = 0;<br>    int lenB = 0;<br>    struct ListNode *cur1 = headA;<br>    struct ListNode *cur2 = headB;<br>    while(cur1->next)<br>    {<br>        lenA++;<br>        cur1 = cur1->next;<br>    }<br>    while(cur2->next)<br>    {<br>        lenB++;<br>        cur2 = cur2->next;<br>    }<br>    int Difference = abs(lenA - lenB);   <br> <br>    struct ListNode *longlist = headA;<br>    struct ListNode *shortlist = headB;<br>    if(lenA < lenB)<br>    {<br>        longlist = headB;<br>        shortlist = headA;<br>    }<br><br>    while(Difference--)<br>        longlist = longlist->next;<br>    while(longlist && shortlist)<br>    {<br>        if(longlist == shortlist)<br>            return longlist;<br>        longlist = longlist->next;<br>        shortlist = shortlist->next;<br>    }<br>    return NULL; <br>}</code></pre> <br><h3>大神解法：</h3> <br><blockquote> <br> <p>让A链表从头遍历，当pA为空时，pA = headB；B链表从头遍历，当pB为空时，pB = headA。让每个链表都走完两个链表的路程，最后它们一定会在相交节点处相遇</p> <br></blockquote> <br><p style="text-align:center;"> <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/42de7623acd7859eb6475166ca3f87c6.jpeg" /></p> <br><pre><code class="language-cpp">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB)<br>{<br>    <br>    if(headA == NULL || headB ==NULL) <br>        return NULL;<br>    struct ListNode *pA = headA;<br>    struct ListNode *pB = headB;<br>    while(pA != pB)<br>    {<br>        pA = pA == NULL?headB:pA->next;<br>        pB = pB == NULL?headA:pB->next;<br>    }<br>    return pA;<br>}</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>