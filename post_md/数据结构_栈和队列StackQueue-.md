<blockquote> <br> <p><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6f2b920cd38b273e9349974209147fee.png" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12634416.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>栈：</h2> <br><blockquote> <br> <p>代码：<a class="has-card" href="https://gitee.com/wang-qin928/c-language-learning/blob/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88/stack.c" rel="nofollow" title="function/数据结构_栈/stack.c · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">function/数据结构_栈/stack.c · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.7/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=O83A" alt="icon-default.png?t=O83A" />https://gitee.com/wang-qin928/c-language-learning/blob/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88/stack.c</span></span></a></p> <br></blockquote> <br><h3>栈的概念及结构</h3> <br><p>栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守<strong>后进先出LIFO</strong>（Last In First Out）的原则。</p> <br><blockquote> <br> <p><strong>压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。</strong></p> <br></blockquote> <br><blockquote> <br> <p><strong>出栈：栈的删除操作叫做出栈。出数据也在栈顶。</strong></p> <br></blockquote> <br><p><img alt="" height="801" src="https://i-blog.csdnimg.cn/blog_migrate/09d64647551c7ce5aa1e2d3b700f5f11.jpeg" width="1200" /></p> <br><p><img alt="" height="415" src="https://i-blog.csdnimg.cn/blog_migrate/017f2906dac175bf84240689572ede42.png" width="1200" /></p> <br><h3>栈的实现</h3> <br><p>栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。</p> <br><p>其实单链表也可以很好的实现栈，我们将只需要进行头插和头删就行了<strong>（避免在尾部要进行找尾的循环操作）</strong>。</p> <br><p>这里我们用顺序表实现，要实现的接口都是和顺序表大同小异：</p> <br><pre><code class="language-cpp">typedef int STDataType;<br><br>typedef struct Stack<br>{<br>	STDataType* data;<br>	int capacity;<br>	int top;<br>}ST;<br><br>void STInit(ST* pst);<br><br>void STDestroy(ST* pst);<br><br>void STPush(ST* pst, STDataType x);<br><br>void STPop(ST* pst);<br><br>STDataType STTop(ST* pst);<br><br>bool STEmpty(ST* pst);<br><br>int STSize(ST* pst);</code></pre> <br><h2>队列：</h2> <br><blockquote> <br> <p>代码：</p> <br> <p><a class="has-card" href="https://gitee.com/wang-qin928/c-language-learning/blob/master/function/%E9%98%9F%E5%88%97/Queue.c" rel="nofollow" title="function/队列/Queue.c · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">function/队列/Queue.c · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.7/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=O83A" alt="icon-default.png?t=O83A" />https://gitee.com/wang-qin928/c-language-learning/blob/master/function/%E9%98%9F%E5%88%97/Queue.c</span></span></a></p> <br></blockquote> <br><h3>队列的概念及结构</h3> <br><p>队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有<strong>先进先出FIFO</strong>(First In First Out)</p> <br><blockquote> <br> <p><strong>入队列：进行插入操作的一端称为队尾</strong></p> <br></blockquote> <br><blockquote> <br> <p><strong>出队列：进行删除操作的一端称为队头</strong></p> <br></blockquote> <br><p><img alt="" height="342" src="https://i-blog.csdnimg.cn/blog_migrate/1fa11aab9d0cb5ba37bb13304268c429.png" width="1200" /></p> <br><h3>队列的实现</h3> <br><p>队列也可以数组和链表的结构实现，<strong>使用链表的结构实现更优一些</strong>，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低（需要整体往前挪动）</p> <br><p>我们这里都尽量选择时间复杂度小的算法来实现</p> <br><p>实现接口：</p> <br><pre><code class="language-cpp">typedef int QDataType;<br><br>typedef struct QueueNode<br>{<br>	QDataType val;<br>	struct QueueNode* next;<br>}QNode;<br><br>typedef struct Queue<br>{<br>	QNode* phead;<br>	QNode* ptail;<br>	int size;<br>}Queue;<br><br>void QueueInit(Queue* pq);//队列初始化<br><br>void Destory(Queue* pq);//销毁队列<br><br>void QueuePush(Queue* pq, QDataType x);//入队<br><br>void QueuePop(Queue* pq);//出队<br><br>int QueueSize(Queue* pq);//获得队列元素个数<br><br>QDataType QueueFront(Queue* pq);//取出队头的元素<br><br>QDataType QueueBack(Queue* pq);//取出队尾的元素</code></pre> <br><p><strong>栈和队列这两个数据结构在之前的顺序表和链表的基础上没有增加什么难度，学习栈和队列真正有难度的地方在LeetCode上的OJ题。<span style="color:#be191c;">大家可以期待一下后续我在数据结构专栏的题目！</span></strong></p> <br><p style="text-align:center;"><a href="https://blog.csdn.net/2301_80194476/article/details/138811755?spm=1001.2014.3001.5502" title="LeetCode_栈和队列相关OJ题目-CSDN博客">LeetCode_栈和队列相关OJ题目-CSDN博客</a></p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>