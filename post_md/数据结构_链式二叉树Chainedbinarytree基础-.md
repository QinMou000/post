<blockquote> <br> <p style="text-align:center;"><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6f2b920cd38b273e9349974209147fee.png" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12634416.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2> 二叉树的遍历</h2> <br><h3>前序、中序以及后序遍历</h3> <br><p>学习二叉树结构，最简单的方式就是遍历。所谓二叉树遍历(Traversal)是按照某种特定的规则，依次对二叉树中的结点进行相应的操作，并且每个结点只操作一次。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，也是二叉树上进行其它运算的基础。<br /> 按照规则，二叉树的遍历有：前序/中序/后序的递归结构遍历：</p> <br><blockquote> <br> <p>1. 前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。<br /> 2. 中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。<br /> 3. 后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。</p> <br></blockquote> <br><p>由于被访问的结点必是某子树的根，所以N(Node）、L(Left subtree）和R(Right subtree）又可解释为根、根的左子树和根的右子树。<strong>NLR、LNR和LRN分别又称为先根遍历、中根遍历和后根遍历。</strong></p> <br><p><img alt="" height="789" src="https://i-blog.csdnimg.cn/blog_migrate/5d6bc02a339cc3c2bb4bc5d3ef2e8131.png" width="1170" /></p> <br><pre><code class="language-cpp">// 二叉树前序遍历 <br>void BinaryTreePrevOrder(BTNode* root)<br>{<br>	if (root == NULL)<br>	{	<br>		printf("# ");<br>		return;<br>	}<br>	printf("%c ",root->_data);<br>	BinaryTreePrevOrder(root->_left);<br>	BinaryTreePrevOrder(root->_right);<br>}<br>// 二叉树中序遍历<br>void BinaryTreeInOrder(BTNode* root)<br>{<br>	if (root == NULL)<br>	{<br>		printf("# ");<br>		return;<br>	}<br>	BinaryTreePrevOrder(root->_left);<br>	printf("%c ", root->_data);<br>	BinaryTreePrevOrder(root->_right);<br>}<br>// 二叉树后序遍历<br>void BinaryTreePostOrder(BTNode* root)<br>{<br>	if (root == NULL)<br>	{<br>		printf("# ");<br>		return;<br>	}<br>	BinaryTreePrevOrder(root->_left);<br>	BinaryTreePrevOrder(root->_right);<br>	printf("%c ", root->_data);<br>}</code></pre> <br><h3>层序遍历</h3> <br><p>层序遍历：除了前序遍历、中序遍历、后序遍历外，还可以对二叉树进行层序遍历。设二叉树的根结点所在层数为1，层序遍历就是从所在二叉树的根结点出发，首先访问第一层的树根结点，然后从左到右访问第2层上的结点，接着是第三层的结点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。</p> <br><p>这里与前、中、后序遍历不同的是：层序遍历用的迭代而非递归。创建一个队列，将整个树的根节点入队，之后再将根节点的左右节点入队。让上一层节点带动下一层，父节点将子女节点带入队，之后将父节点拿出队列，这样就实现了层序遍历。</p> <br><pre><code class="language-cpp">// 层序遍历<br>void BinaryTreeLevelOrder(BTNode* root)<br>{<br>	assert(root);<br>	Queue q;<br>	QueueInit(&q);<br>	QueuePush(&q,root);<br>	<br>	while (QueueSize(&q))<br>	{<br>		BTNode* front = QueueFront(&q);<br>		QueuePop(&q);<br><br>		printf("%c ", front->_data);<br><br>		if (front->_left)<br>			QueuePush(&q,front->_left);<br>		if(front->_right)<br>			QueuePush(&q,front->_right);<br>	}<br>}</code></pre> <br><h2> 其他函数</h2> <br><h3>通过前序遍历数组创建二叉树</h3> <br><p> 判断下标为i的字符是否为'#'，如果不为'#'那就新malloc一个节点将数据放进去，新节点的左右节点分别再递归赋值。</p> <br><pre><code class="language-cpp">BTNode* BinaryTreeCreate(BTDataType* a,int* pi)<br>{<br>	if (a[*pi] == '#')<br>	{<br>		(*pi)++;<br>		return NULL;<br>	}<br>	BTNode* new = (BTNode*)malloc(sizeof(BTNode));<br>	if (new == NULL)<br>	{<br>		perror("malloc is fail");<br>		return NULL;<br>	}<br>	new->_data = a[(*pi)++];<br>	new->_left = BinaryTreeCreate(a, pi);<br>	new->_right = BinaryTreeCreate(a, pi);<br>	return new;<br>}</code></pre> <br><h3>销毁二叉树</h3> <br><p>如果当前节点为空那么就释放，如果当前节点不为空，那么就先递归释放左右子树,左右子树释放后再将根节点释放并置空。</p> <br><pre><code class="language-cpp">// 二叉树销毁<br>void BinaryTreeDestory(BTNode** root)<br>{<br>	if (*root == NULL)<br>	{<br>		free(*root);<br>		return;<br>	}<br>	BinaryTreeDestory(&(*root)->_left);<br>	BinaryTreeDestory(&(*root)->_right);<br>	free(*root);<br>	*root = NULL;<br>}</code></pre> <br><h3>二叉树节点个数</h3> <br><p>如果当前节点为空返回0，如果当前节点不为空返回其左右子树的节点个数+1。</p> <br><pre><code class="language-cpp">// 二叉树节点个数<br>int BinaryTreeSize(BTNode* root)<br>{<br>	if (root == NULL)<br>		return 0;<br>	return BinaryTreeSize(root->_left)<br>         + BinaryTreeSize(root->_right) + 1;<br>}</code></pre> <br><h3>二叉树叶子节点个数</h3> <br><p>如果节点的左右节点都为空返回1，否则返回左右子树的叶子节点个数。</p> <br><pre><code class="language-cpp">// 二叉树叶子节点个数<br>int BinaryTreeLeafSize(BTNode* root)<br>{<br>	if (root == NULL)<br>		return 0;<br>	if (root->_left == NULL && root->_right == NULL)<br>		return 1;<br>	return BinaryTreeLeafSize(root->_left)<br>         + BinaryTreeLeafSize(root->_right);<br>}</code></pre> <br><h3>二叉树第k层节点个数</h3> <br><p>第k层节点的个数，可以看作第一层的左右节点的第k-1层节点个数，因此当k == 1时此层就是要计算再内的节点。</p> <br><pre><code class="language-cpp">// 二叉树第k层节点个数<br>int BinaryTreeLevelKSize(BTNode* root, int k)<br>{<br>	if (root == NULL)<br>		return 0;<br>	if (k == 1)<br>		return 1;<br>	return BinaryTreeLevelKSize(root->_left, k - 1)<br>		 + BinaryTreeLevelKSize(root->_right, k - 1);<br>}</code></pre> <br><h3>二叉树查找值为x的节点</h3> <br><p>采取前序遍历，如果根节点的值等于x，返回root，否则先判断左子树有无符合节点，若有返回对应的节点，反之返回另一个子树的对应节点，若左右字数都没有对应节点，最终将返回空</p> <br><pre><code class="language-cpp">// 二叉树查找值为x的节点<br>BTNode* BinaryTreeFind(BTNode* root, BTDataType x)<br>{<br>	if (root == NULL)<br>		return NULL;<br>	if (root->_data == x)<br>		return root;<br>	BTNode* ret1 = BinaryTreeFind(root->_left, x);<br>	if (ret1 != NULL)<br>		return ret1;<br>	return BinaryTreeFind(root->_right, x);	<br>}</code></pre> <br><h3>判断二叉树是否为完全二叉树</h3> <br><p>建立一个队列，和层序遍历一样，当遇到空节点时，跳出循环，开始判断。如果再空节点的后面还有非空节点，那么这棵树就不是完全二叉树。反之此树空节点之后的所有的节点都为空，那么此树为完全二叉树。</p> <br><p><img alt="" height="800" src="https://i-blog.csdnimg.cn/blog_migrate/3ba14b23ce3681e56adea576872f6ff6.png" width="1200" /></p> <br><pre><code class="language-cpp">// 判断二叉树是否是完全二叉树<br>int BinaryTreeComplete(BTNode* root)<br>{<br>	assert(root);<br>	Queue q;<br>	QueueInit(&q);<br>	QueuePush(&q, root);<br><br>	while (QueueSize(&q))<br>	{<br>		BTNode* front = QueueFront(&q);<br>		QueuePop(&q);<br><br>		if (front == NULL)<br>			break;<br>		<br>		QueuePush(&q, front->_left);<br>		QueuePush(&q, front->_right);<br>	}<br>	while (QueueSize(&q))<br>	{<br>		BTNode* front = QueueFront(&q);<br>		QueuePop(&q);<br>		if (front)<br>		{<br>			Destory(&q);<br>			return false;<br>		}<br>	}<br>	return true;<br>}</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>