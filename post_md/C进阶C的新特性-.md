<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/9e66b67c73ef431f887a88a78f972ea7.png" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>C++11的发展历史</h2> <br><p> 2011年，C++标准委员会发布了C++11标准，这是C++的一次巨大飞跃，引入了许多重要的新特性，如智能指针、lambda表达式、并发编程支持等。这一版本的发布对C++社区产生了深远的影响，使得C++在现代软件开发中更具竞争力。C++11 是 C++ 的第⼆个主要版本，并且是从 C++98 起的最重要更新。C++03 与 C++11 期间花了 8 年时间，故⽽这是迄今为⽌最⻓的版本间隔。从那时起，C++ 有规律地每 3 年更新⼀次。 </p> <br><p><img alt="" height="325" src="https://i-blog.csdnimg.cn/direct/77d5f9af7bf8439096ee2ff8f50ca247.png" width="960" /> </p> <br><h2 style="background-color:transparent;"> 初始化列表</h2> <br><p>在C++98中我们可以用 { } 来初始化数组，结构体。 </p> <br><pre><code class="language-cpp">struct Point<br>{<br>	int _x;<br>	int _y;<br>};<br><br>int main()<br>{<br>	int array1[] = { 1, 2, 3, 4, 5 };<br>	int array2[5] = { 0 };<br>	Point p = { 1, 2 };<br>	return 0;<br>}</code></pre> <br><p>C++11以后想统⼀初始化⽅式，<span style="color:#be191c;"><strong>试图实现⼀切对象皆可⽤{}初始化</strong></span>，{}初始化也叫做列表初始化。</p> <br><ul><li>内置类型⽀持，⾃定义类型也⽀持，⾃定义类型本质是类型转换，中间会产⽣临时对象，最后优化了以后变成直接构造。</li><li>{ } 初始化的过程中，可以省略掉 = 。</li><li>C++11列表初始化的本意是想实现⼀个⼤统⼀的初始化⽅式，其次他在有些场景下带来的不少便利，如容器push/inset多参数构造的对象时，{}初始化会很⽅便。</li></ul> <br><h3>std::initializer_list</h3> <br><ul><li>上⾯的初始化已经很⽅便，但是对象容器初始化还是不太⽅便，⽐如⼀个vector对象，我想⽤N个值去构造初始化，那么我们得实现很多个构造函数才能⽀持， vector v1 = {1,2,3}; vector v2 = {1,2,3,4,5};</li><li>C++11库中提出了⼀个std::initializer_list的类， auto il = { 10, 20, 30 }; // the type of il is an initializer_list ，这个类的本质是底层开⼀个数组，将数据拷⻉过来，std::initializer_list内部有两个指针分别指向数组的开始和结束。</li><li>这是他的⽂档：<a href="https://legacy.cplusplus.com/reference/initializer_list/initializer_list/" rel="nofollow" title="initializer_list ">initializer_list </a>，std::initializer_list⽀持迭代器遍历。</li><li>容器⽀持⼀个std::initializer_list的构造函数，也就⽀持任意多个值构成的 {x1,x2,x3...} 进⾏ 初始化。STL中的容器⽀持任意多个值构成的 {x1,x2,x3...} 进⾏初始化，就是通过 std::initializer_list的构造函数⽀持的。</li></ul> <br><p>STL中的容器都增加了⼀个initializer_list的构造</p> <br><p><img alt="" height="69" src="https://i-blog.csdnimg.cn/direct/d0ea12d90a5d40bc8546cd92867034bd.png" width="1001" /></p> <br><p><img alt="" height="69" src="https://i-blog.csdnimg.cn/direct/9d5c84bed7c14a1986a8d1f8f80a4630.png" width="1000" /> <img alt="" height="40" src="https://i-blog.csdnimg.cn/direct/0c3d92bf03ba472aaa4e4c31bca89eea.png" width="1000" /></p> <br><p><img alt="" height="101" src="https://i-blog.csdnimg.cn/direct/3b515a8d4e8f4c919b9d539c5d94ca3f.png" width="1002" /></p> <br><h2> 右值引用和移动语义</h2> <br><p>C++98的C++语法中就有引⽤的语法，⽽C++11中新增了的右值引⽤语法特性，C++11之后我们之前学习的引⽤就叫做左值引⽤。⽆论左值引⽤还是右值引⽤，都是给对象取别名。</p> <br><h3>左值和右值</h3> <br><ul><li>左值是⼀个表示数据的表达式(如变量名或解引⽤的指针)，⼀般是有持久状态，存储在内存中，<strong><span style="color:#be191c;">我们可以获取它的地址</span></strong>，左值可以出现赋值符号的左边，也可以出现在赋值符号右边。定义时const 修饰符后的左值，不能给他赋值，但是可以取它的地址。</li><li>右值也是⼀个表⽰数据的表达式，要么是字⾯值常量、要么是表达式求值过程中创建的临时对象等，右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，<span style="color:#be191c;"><strong>右值不能取地址。</strong></span></li><li>值得⼀提的是，左值的英⽂简写为lvalue，右值的英⽂简写为rvalue。传统认为它们分别是left value、right value 的缩写。现代C++中，lvalue 被解释为loactor（定位） value的缩写，可意为存储在内存中、有明确存储地址可以取地址的对象，⽽ rvalue 被解释为 read value，指的是那些可以提供数据值，但是不可以寻址，例如：临时变量，字⾯量常量，存储于寄存器中的变量等，<span style="color:#be191c;"><strong>也就是说左值和右值的核⼼区别就是能否取地址。</strong></span></li></ul> <br><pre><code class="language-cpp">int main()<br>{<br>	// 左值：可以取地址<br>	// 以下的p、b、c、*p、s、s[0]就是常⻅的左值<br>	int* p = new int(0);<br>	int b = 1;<br>	const int c = b;<br>	*p = 10;<br>	string s("111111");<br>	s[0] = 'x';<br>	cout << &c << endl;<br>	cout << (void*)&s[0] << endl;<br>	// 右值：不能取地址<br>	double x = 1.1, y = 2.2;<br>	// 以下⼏个10、x + y、fmin(x, y)、string("11111")都是常⻅的右值<br>	10;<br>	x + y;<br>	fmin(x, y);<br>	string("11111");<br>	//cout << &10 << endl;<br>	//cout << &(x+y) << endl;<br>	//cout << &(fmin(x, y)) << endl;<br>	//cout << &string("11111") << endl;<br>	return 0;<br>}</code></pre> <br><h3>左值引用和右值引用</h3> <br><ul><li>Type& r1 = x; Type&& rr1 = y; 第⼀个语句就是左值引⽤，左值引⽤就是给左值取别名，第⼆个就是右值引⽤，同样的道理，右值引⽤就是给右值取别名。</li><li><span style="color:#be191c;"><strong>左值引⽤不能直接引⽤右值，但是const左值引⽤可以引⽤右值 </strong></span></li><li><span style="color:#be191c;"><strong>右值引⽤不能直接引⽤左值，但是右值引⽤可以引⽤move(左值)</strong></span></li><li>move是库⾥⾯的⼀个函数模板，本质内部是进⾏强制类型转换，但是底层实现还挺复杂的。<img alt="" height="146" src="https://i-blog.csdnimg.cn/direct/84cb8ba43cd94530850ae7a887ed8478.png" width="1200" /></li><li>需要注意的是变量表达式都是左值属性，也就<span style="color:#be191c;"><strong>意味着⼀个右值被右值引⽤绑定后，右值引⽤变量变量表达式的属性是左值</strong></span></li><li>语法层⾯看，左值引⽤和右值引⽤都是取别名，不开空间。从汇编底层的⻆度看左值引用和右值引用的实现，底层都是⽤指针实现的，没什么区别。底层汇编等实现和上层语法表达的意义有时是背离的，所以不要混到⼀起去理解，互相佐证，这样反⽽是陷⼊迷途。  <img alt="" height="410" src="https://i-blog.csdnimg.cn/direct/74aac9355ec24885857bf4578d3e30b7.png" width="901" /></li></ul> <br><p></p> <br><h3>引⽤延⻓⽣命周期</h3> <br><p>右值引⽤可⽤于为临时对象延⻓⽣命周期，const 的左值引⽤也能延⻓临时对象⽣存期，但这些对象⽆法被修改。 </p> <br><pre><code class="language-cpp">int main()<br>{<br>	std::string s1 = "Test";<br>	// std::string&& r1 = s1; // 错误：不能绑定到左值<br><br>	const std::string& r2 = s1 + s1; // OK：到 const 的左值引用延长生存期<br>	// r2 += "Test"; // 错误：不能通过到 const 的引⽤修改<br><br>	std::string&& r3 = s1 + s1; // OK：右值引用延长生存期<br>	r3 += "Test"; // OK：能通过到非 const 的引用修改<br>	std::cout << r3 << '\n';// TestTestTest<br><br>	return 0;<br>}</code></pre> <br><h3>左值和右值的参数匹配</h3> <br><ul><li>C++98中，我们实现⼀个const左值引⽤作为参数的函数，那么实参传递左值和右值都可以匹配。</li><li>C++11以后，分别重载左值引⽤、const左值引⽤、右值引⽤ 作为形参的f函数，那么实参是左值会匹配f(左值引⽤)，实参是const左值会匹配f(const 左值引⽤)，实参是右值会匹配f(右值引⽤)。</li><li>右值引⽤变量在⽤于表达式时属性是左值，这个设计这⾥会感觉很怪，但是在一些特定的地方就能体现出这样设计的目的（不要认为C++委员会的人是吃素的啊！魂淡！）</li></ul> <br><h3>右值引⽤和移动语义 </h3> <br><h4>左值引⽤主要使⽤场景回顾</h4> <br><p>左值引⽤主要使⽤场景是在函数中左值引⽤传参和左值引⽤传返回值时减少拷⻉，同时还可以修改实参和修改返回对象的价值。</p> <br><p>左值引⽤已经解决⼤多数场景的拷⻉效率问题，但是有些场景不能使⽤传左值引⽤返回，如addStrings和generate函数（返回的是一个局部对象，出了作用域会销毁），C++98中的解决⽅案只能是被迫使⽤输出型参数解决（类似LeetCode里用C语言些OJ的时候有一个renturn的参数在参数列表里面）。</p> <br><pre><code class="language-cpp">string addStrings(string num1, string num2) {<br>	string str;<br>	int end1 = num1.size() - 1, end2 = num2.size() - 1;<br>	// 进位<br>	int next = 0;<br>	while (end1 >= 0 || end2 >= 0)<br>	{<br>		int val1 = end1 >= 0 ? num1[end1--] - '0' : 0;<br>		int val2 = end2 >= 0 ? num2[end2--] - '0' : 0;<br>		int ret = val1 + val2 + next;<br>		next = ret / 10;<br>		ret = ret % 10;<br>		str += ('0' + ret);<br>	}<br>	if (next == 1)<br>		str += '1';<br>	reverse(str.begin(), str.end());<br>	return str;<br>}</code></pre> <br><pre><code class="language-cpp">vector<vector<int>> generate(int numRows) {<br>	vector<vector<int>> vv(numRows);<br>	for (int i = 0; i < numRows; ++i)<br>	{<br>		vv[i].resize(i + 1, 1);<br>	}<br>	for (int i = 2; i < numRows; ++i)<br>	{<br>		for (int j = 1; j < i; ++j)<br>		{<br>			vv[i][j] = vv[i - 1][j] + vv[i - 1][j - 1];<br>		}<br>	}<br>	return vv;<br>}</code></pre> <br><p>那么C++11以后这⾥可以使⽤右值引⽤做返回值解决吗？显然是不可能的，因为这⾥的本质是返回 对象是⼀个局部对象，函数结束这个对象就析构销毁了，右值引⽤返回也⽆法概念对象已经析构销毁的事实 </p> <br><h4>移动构造和移动赋值</h4> <br><ul><li>移动构造函数是⼀种构造函数，类似拷⻉构造函数，移动构造函数要求第⼀个参数是该类类型的引⽤，但是不同的是<span style="color:#be191c;"><strong>要求这个参数是右值引⽤，如果还有其他参数，额外的参数必须有缺省值。</strong></span></li><li>移动赋值是⼀个赋值运算符的重载，他跟拷⻉赋值构成函数重载，类似拷⻉赋值函数，移动赋值函数要求<span style="color:#be191c;"><strong>第⼀个参数是该类类型的引⽤</strong></span>，但是不同的是要求这个参数是<strong><span style="color:#be191c;">右值引⽤</span></strong>。</li><li>对于像string/vector这样的<span style="color:#be191c;"><strong>深拷⻉的类或者包含深拷⻉的成员变量的类，移动构造和移动赋值才有意义</strong></span>，因为移动构造和移动赋值的第⼀个参数都是右值引⽤的类型，<span style="color:#ed7976;"><strong>他的本质是要“掠夺”引⽤的右值对象的资源，⽽不是像拷⻉构造和拷⻉赋值那样去拷⻉资源，从而提⾼效率。</strong></span>以string为例： <pre><code class="language-cpp">// 移动构造<br>string(string&& s)<br>{<br>    cout << "string(string&& s) -- 移动构造" << endl;<br>    swap(s);<br>}<br>// 移动赋值<br>string& operator=(string&& s)<br>{<br>    cout << "string& operator=(string&& s) -- 移动赋值" << endl;<br>    swap(s);<br>    return *this;<br>}<br></code></pre> </li></ul> <br><h4>右值对象移动语义优化传值问题 </h4> <br><p>在C++11以前（没有移动构造，移动赋值），只能返回局部对象的拷贝的临时对象再拷贝一次到返回的ret对象上，这样是很消耗资源的。C++没有解决问题的方法，只有考编译器的优化了。编译器直接把两次拷贝构造合二为一，就只用一次拷贝。 </p> <br><p>C++11出来以后（没有移动构造，移动赋值），在没有编译器优化的情况下，会调用两次移动构造相当于将局部对象的资源转移了两次，但即使这样，也不会消耗太多资源，其实就是几个swap，假如是一棵树，只用交换root，一个链表，只用交换头节点。这样其实没有编译器的优化效率也很高。编译器优化之后，只需调用一次移动构造（其实也没优化到什么）。</p> <br><p>所以在编译器和C++委员会的工同努力下，这个问题得到了妥善的解决。</p> <br><blockquote> <br> <p>在Linux系统下，取消编译器的所有优化：g++ test.cpp -fno-elide-constructors </p> <br></blockquote> <br><h4>右值引⽤和移动语义在传参中的提效</h4> <br><ul><li>查看STL⽂档我们发现C++11以后容器的push和insert系列的接⼝都增加了右值引⽤版本</li><li>当实参是⼀个左值时，容器内部继续调⽤拷⻉构造进⾏拷⻉（不能将其资源转走，之后可能还会用到该对象），将对象拷⻉到容器空间中的对象</li><li>当实参是⼀个右值（大多是临时变量，局部变量，反正都会销毁），容器内部则调⽤移动构造，将右值对象的资源移动到容器空间的对象上</li></ul> <br><h3>类型分类（了解）</h3> <br><ul><li>C++11以后，进⼀步对类型进⾏了划分，右值被划分纯右值(pure value，简称prvalue)和将亡值 (expiring value，简称xvalue)。</li><li>纯右值是指那些字⾯值常量或求值结果相当于字⾯值或是⼀个不具名的临时对象。如： 42、 true、nullptr 或者类似 str.substr(1, 2)、str1 + str2 传值返回函数调⽤，或者整 形 a、b，a++，a+b 等。纯右值和将亡值C++11中提出的，C++11中的纯右值概念划分等价于 C++98中的右值。</li><li>将亡值是指返回右值引⽤的函数的调⽤表达式和转换为右值引⽤的转换函数的调⽤表达，如 move(x)、static_cast(x)</li><li>泛左值(generalized value，简称glvalue)，泛左值包含将亡值和左值。</li><li><a href="https://zh.cppreference.com/w/cpp/language/value_category" rel="nofollow" title="值类别 - cppreference.com">值类别 - cppreference.com</a>和<a href="https://en.cppreference.com/w/cpp/language/value_category" rel="nofollow" title="Value categories">Value categories</a>这两个关于值类型的中⽂和英⽂的官⽅⽂档。</li><li>有名字，就是glvalue；有名字，且不能被move，就是lvalue；有名字，且可以被move，就是 xvalu；没有名字，且可以被移动，则是prvalue。</li></ul> <br><p><img alt="" height="354" src="https://i-blog.csdnimg.cn/direct/6b70acbdec8348529800834ecf335bd1.png" width="904" /></p> <br><h3>引⽤折叠</h3> <br><ul><li>C++中不能直接定义引⽤的引⽤如 int& && r = i; ，这样写会直接报错，通过模板或 typedef 中的类型操作可以构成引⽤的引⽤。</li><li>通过模板或 typedef 中的类型操作可以构成引⽤的引⽤时，这时C++11给出了⼀个引⽤折叠的规则：右值引⽤的右值引⽤折叠成右值引⽤，所有其他组合均折叠成左值引⽤。</li><li>下⾯的程序中很好的展⽰了模板和typedef时构成引⽤的引⽤时的引⽤折叠规则，⼤家需要⼀个⼀个仔细理解⼀下。 <pre><code class="language-cpp">// 由于引⽤折叠限定，f1实例化以后总是⼀个左值引⽤<br>template<class T><br>void f1(T& x)<br>{}<br>// 由于引⽤折叠限定，f2实例化后可以是左值引⽤，也可以是右值引⽤<br>template<class T><br>void f2(T&& x)<br>{}<br>int main()<br>{<br>	typedef int& lref;<br>	typedef int&& rref;<br>	int n = 0;<br>	lref& r1 = n; // r1 的类型是 int&<br>	lref&& r2 = n; // r2 的类型是 int&<br>	rref& r3 = n; // r3 的类型是 int&<br>	rref&& r4 = 1; // r4 的类型是 int&&<br>	// 没有折叠->实例化为void f1(int& x)<br>	f1<int>(n);<br>	f1<int>(0); // 报错<br>	// 折叠->实例化为void f1(int& x)<br>	f1<int&>(n);<br>	f1<int&>(0); // 报错<br>	// 折叠->实例化为void f1(int& x)<br>	f1<int&&>(n);<br>	f1<int&&>(0); // 报错<br>	// 折叠->实例化为void f1(const int& x)<br>	f1<const int&>(n);<br>	f1<const int&>(0);<br>	// 折叠->实例化为void f1(const int& x)<br>	f1<const int&&>(n);<br>	f1<const int&&>(0);<br>	// 没有折叠->实例化为void f2(int&& x)<br>	f2<int>(n); // 报错<br>	f2<int>(0);<br>	// 折叠->实例化为void f2(int& x)<br>	f2<int&>(n);<br>	f2<int&>(0); // 报错<br>	// 折叠->实例化为void f2(int&& x)<br>	f2<int&&>(n); // 报错<br>	f2<int&&>(0);<br>	return 0;<br>}</code></pre> <p></p> </li><li>像f2这样的函数模板中，T&& x参数看起来是右值引⽤参数，<span style="color:#be191c;"><strong>但是由于引⽤折叠的规则，他传递左值时就是左值引⽤，传递右值时就是右值引⽤，有些地⽅也把这种函数模板的参数叫做万能引⽤。</strong></span></li><li>Function(T&& t)函数模板程序中，<span style="color:#ed7976;"><strong>假设实参是int右值，模板参数T的推导int，实参是int左值，模板参数T的推导int&</strong></span>，再结合引⽤折叠规则，就实现了实参是左值，实例化出左值引⽤版本形参的 Function，实参是右值，实例化出右值引⽤版本形参的Function。 <pre><code class="language-cpp">template<class T><br>void Function(T&& t)<br>{<br>	int a = 0;<br>	T x = a;<br>	//x++;<br>	cout << &a << endl;<br>	cout << &x << endl << endl;<br>}<br>int main()<br>{<br>	// 10是右值，推导出T为int，模板实例化为void Function(int&& t)<br>	Function(10); // 右值<br>	int a;<br>	// a是左值，推导出T为int&，引⽤折叠，模板实例化为void Function(int& t)<br>	Function(a); // 左值<br>	// std::move(a)是右值，推导出T为int，模板实例化为void Function(int&& t)<br>	Function(std::move(a)); // 右值<br>	const int b = 8;<br>	// a是左值，推导出T为const int&，引⽤折叠，模板实例化为void Function(const int&t)<br>	// 所以Function内部会编译报错，x不能++<br>	Function(b); // const 左值<br>	// std::move(b)右值，推导出T为const int，模板实例化为void Function(const int&&t)<br>	// 所以Function内部会编译报错，x不能++<br>	Function(std::move(b)); // const 右值<br>	return 0;<br>}</code></pre> </li></ul> <br><h3> 完美转发</h3> <br><p>Function(T&& t)函数模板程序中，传左值实例化以后是左值引⽤的Function函数，传右值实例化以后是右值引⽤的Function函数。</p> <br><p>但是我们之前有说，变量表达式都是左值属性，也就意味着⼀个右值被右值引⽤绑定后，右值引⽤变量表达式的属性是左值，<span style="color:#be191c;"><strong>也就是说Function函数中t的属性是左值，那么我们把t传递给下⼀层函数Fun，那么匹配的都是左值引⽤版本的Fun函数。这⾥我们想要保持t对象的属性， 就需要使⽤完美转发实现。</strong></span></p> <br><p><img alt="" height="343" src="https://i-blog.csdnimg.cn/direct/5c5759c8c95141bd99c0e8c75f98f176.png" width="1200" /></p> <br><p>完美转发forward本质是⼀个函数模板，他主要还是通过引⽤折叠的⽅式实现，下⾯示例中传递给 Function的实参是右值，T被推导为int，没有折叠，forward内部t被强转为右值引⽤返回；传递给 Function的实参是左值，T被推导为int&，引⽤折叠为左值引⽤，forward内部t被强转为左值引⽤ 返回。</p> <br><pre><code class="language-cpp">template <class _Ty><br>_Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept<br>{ // forward an lvalue as either an lvalue or an rvalue<br>	return static_cast<_Ty&&>(_Arg);<br>}<br>void Fun(int& x) { cout << "左值引⽤" << endl; }<br>void Fun(const int& x) { cout << "const 左值引⽤" << endl; }<br>void Fun(int&& x) { cout << "右值引⽤" << endl; }<br>void Fun(const int&& x) { cout << "const 右值引⽤" << endl; }<br><br>template < class T><br>void Function(T && t)<br>{<br>	Fun(t);<br>	//Fun(forward<T>(t));<br>}<br>int main()<br>{<br>	// 10是右值，推导出T为int，模板实例化为void Function(int&& t)<br>	Function(10); // 右值<br>	int a;<br>	// a是左值，推导出T为int&，引⽤折叠，模板实例化为void Function(int& t)<br>	Function(a); // 左值<br>	// std::move(a)是右值，推导出T为int，模板实例化为void Function(int&& t)<br>	Function(std::move(a)); // 右值<br>	const int b = 8;<br>	// a是左值，推导出T为const int&，引⽤折叠，模板实例化为void Function(const int&t)<br>	Function(b); // const 左值<br>	// std::move(b)右值，推导出T为const int，模板实例化为void Function(const int&&t)<br>	Function(std::move(b)); // const 右值<br>	return 0;<br>}</code></pre> <br><h2>可变参数模板 </h2> <br><ul><li>C++11⽀持可变参数模板，也就是说⽀持可变数量参数的函数模板和类模板，可变数⽬的参数被称为参数包，存在两种参数包：</li></ul> <br><blockquote> <br> <ol><li>模板参数包，表示零或多个模板参数；</li><li>函数参数包：表示零或多个函数参数。</li></ol> <br></blockquote> <br><pre><code class="language-cpp">template <class ...Args> void Func(Args... args) {}<br>template <class ...Args> void Func(Args&... args) {}<br>template <class ...Args> void Func(Args&&... args) {}</code></pre> <br><ul><li>我们⽤省略号来指出⼀个模板参数或函数参数的表示⼀个包，在模板参数列表中，class...或 typename...指出接下来的参数表示零或多个类型列表；在函数参数列表中，类型名后⾯跟...指出 接下来表⽰零或多个形参对象列表；函数参数包可以⽤左值引⽤或右值引⽤表⽰，跟前⾯普通模板 ⼀样，每个参数实例化时遵循引⽤折叠规则。</li><li>可变参数模板的原理跟模板类似，本质还是去实例化对应类型和个数的多个函数。</li><li>这⾥我们可以使⽤sizeof...运算符去计算参数包中参数的个数。</li></ul> <br><pre><code class="language-cpp">template <class ...Args><br>void Print(Args&&... args)<br>{<br>cout << sizeof...(args) << endl;<br>}<br></code></pre> <br><p><img alt="" height="550" src="https://i-blog.csdnimg.cn/direct/a1e63bbedf8f4ad1b32a53cb4005593b.png" width="1200" /> 可变参数模板先是根据实参的个数示例化出模板，之后再根据模板示例化出对应的函数（编译器是黑奴~~~）</p> <br><blockquote> <br> <p>可以这么理解<br /> 模板：不知道参数类型，但是知道参数个数<br /> 可变参数模板：参数类型和个数都不知道 </p> <br></blockquote> <br><h3>包扩展 </h3> <br><ul><li>对于⼀个参数包，我们除了能计算他的参数个数，我们能做的唯⼀的事情就是扩展它，当扩展⼀个包时，我们还要提供⽤于每个扩展元素的模式，扩展⼀个包就是将它分解为构成的元素，对每个元素应⽤模式，获得扩展后的列表。我们通过在模式的右边放⼀个省略号(...)来触发扩展操作。底层的实现细节如图1所⽰。</li><li>C++还⽀持更复杂的包扩展，直接将参数包依次展开依次作为实参给⼀个函数去处理。 </li></ul> <br><pre><code class="language-cpp">void ShowList()<br>{<br>	// 编译器时递归的终⽌条件，参数包是0个时，直接匹配这个函数<br>	cout << endl;<br>}<br>template <class T, class ...Args><br>void ShowList(T x, Args... args)<br>{<br>	cout << x << " ";<br>	// args是N个参数的参数包<br>	// 调⽤ShowList，参数包的第⼀个传给x，剩下N-1传给第⼆个参数包<br>	ShowList(args...);<br>}<br>// 编译时递归推导解析参数<br>template <class ...Args><br>void Print(Args... args)<br>{<br>	ShowList(args...);<br>}<br>int main()<br>{<br>	Print();<br>	Print(1);<br>	Print(1, string("xxxxx"));<br>	Print(1, string("xxxxx"), 2.2);<br>	return 0;<br>}</code></pre> <br><p><img alt="" height="889" src="https://i-blog.csdnimg.cn/direct/2f2f47c4b8fd42828486242d19ffd607.png" width="1029" /></p> <br><p><span style="color:#be191c;"><strong>注意：以上过程是在编译时发生的，本质上是一个编译时递归。平常我们写的递归都是运行时递归。 </strong></span></p> <br><pre><code class="language-cpp">template <class T><br>const T& GetArg(const T& x)<br>{<br>	cout << x << " ";<br>	return x;<br>}<br>template <class ...Args><br>void Arguments(Args... args)<br>{}<br>template <class ...Args><br>void Print(Args... args)<br>{<br>	// 注意GetArg必须返回或者到的对象，这样才能组成参数包给Arguments<br>	Arguments(GetArg(args)...);<br>}<br></code></pre> <br><p>本质可以理解为编译器编译时，包的扩展模式将上⾯的函数模板扩展实例化为下⾯的函数，这样设计其实挺巧妙的。C++委员会的大佬还是有水平的哈哈！</p> <br><pre><code class="language-cpp">void Print(int x, string y, double z)<br>{<br>	Arguments(GetArg(x), GetArg(y), GetArg(z));<br>}</code></pre> <br><h3>empalce系列接⼝</h3> <br><pre><code class="language-cpp">template void emplace_back (Args&&... args);<br>template iterator emplace (const_iterator position, Args&&... args);</code></pre> <br><ul><li>C++11以后STL容器新增了empalce系列的接⼝，empalce系列的接⼝均为模板可变参数，功能上兼容push和insert系列，但是empalce还⽀持新玩法，假设容器为container，empalce还⽀持直接插⼊构造T对象的参数，这样有些场景会更⾼效⼀些，可以直接在容器空间上构造T对象。</li><li>emplace_back总体⽽⾔是更⾼效，推荐以后使⽤emplace系列替代insert和push系列</li><li>在底层实现emplace_back的时候，我们不需要像push_back一样先构造一个对象，然后再把这个对象的 const引用 不断往下传。emplace_back只需要把参数包不断往下传，传到最后直接用参数包在与T匹配的类型构造T对象。emplace_back 相当于直接插入构造T对象的参数。</li><li>传递参数包过程中，如果是 Args&&... args 的参数包，要⽤完美转发参数包，⽅式如下 std::forward(args)... ，否则编译时包扩展后右值引⽤变量表达式就变成了左值。</li></ul> <br><pre><code class="language-cpp">int main()<br>{<br>	list<string> lt;<br>	//传左值，跟push_back⼀样，⾛拷贝构造<br>	string s1 = "11111";<br>	lt.emplace_back(s1);<br>	//右值，跟push_back⼀样，⾛移动构造<br>	lt.emplace_back(move(s1));<br>	cout << "*********************************" << endl;<br><br>	// 直接把构造string参数包往下传，直接⽤string参数包构造string<br>	// 这⾥达到的效果是push_back做不到的<br>	lt.emplace_back("111111111111");<br>	cout << "*********************************" << endl;<br><br>	list<pair<string, int>> lt1;<br>	// 跟push_back⼀样<br>	// 构造pair + 拷贝/移动构造pair到list的节点中data上<br>	pair<string, int> kv("苹果", 1);<br>	lt1.emplace_back(kv);<br>	// 跟push_back⼀样<br>	lt1.emplace_back(move(kv));<br>	cout << "*********************************" << endl;<br><br>	// 直接把构造pair参数包往下传，直接⽤pair参数包构造pair<br>	// 这⾥达到的效果是push_back做不到的<br>	lt1.emplace_back("苹果", 1);<br>	cout << "*********************************" << endl;<br><br>    //模拟实现list的emplace和emplace_back接⼝，这⾥把参数包不断往下传递， <br>    //最终在结点的构造中直接去匹配容器存储的数据类型T的构造，<br>    //所以达到了前⾯说的empalce⽀持直接插⼊构造T对象的参数，<br>    //这样有些场景会更⾼效⼀些，可以直接在容器空间上构造T对象。<br><br>	return 0;<br>}</code></pre> <br><h2 style="background-color:transparent;"> 新的类功能</h2> <br><h3>默认的移动构造和移动赋值</h3> <br><ul><li>原来C++类中，有6个默认成员函数：构造函数/析构函数/拷⻉构造函数/拷⻉赋值重载/取地址重载/const 取地址重载，最后重要的是前4个，后两个⽤处不⼤，默认成员函数就是我们不写编译器会⽣成⼀个默认的。<strong><span style="color:#be191c;">C++11 新增了两个默认成员函数，移动构造函数和移动赋值运算符重载。</span></strong></li><li><span style="color:#ed7976;"><strong>如果你没有⾃⼰实现移动构造函数，且没有实现析构函数 、拷⻉构造、拷⻉赋值重载中的任意⼀个（深拷贝类型需要实现的默认成员函数）。</strong></span><span style="color:#be191c;"><strong>那么编译器会⾃动⽣成⼀个默认移动构造。</strong></span>默认⽣成的移动构造函数，对于内置类型成员会执⾏逐成员<strong><span style="color:#4da8ee;">按字节拷⻉</span></strong>，⾃定义类型成员，则需要看这个成员是否实现移动构造，如果实现了就调⽤移动构造，没有实现就调⽤拷⻉构造。</li><li><span style="color:#ed7976;"><strong>如果你没有⾃⼰实现移动赋值重载函数，且没有实现析构函数 、拷⻉构造、拷⻉赋值重载中的任意 ⼀个，</strong></span><span style="color:#be191c;"><strong>那么编译器会⾃动⽣成⼀个默认移动赋值。</strong></span>默认⽣成的移动构造函数，对于内置类型成员会执⾏逐成员按字节拷⻉，⾃定义类型成员，则需要看这个成员是否实现移动赋值，如果实现了就调⽤移动赋值，没有实现就调⽤拷⻉赋值。(默认移动赋值跟上⾯移动构造完全类似)</li><li>如果你提供了移动构造或者移动赋值，编译器不会⾃动提供拷⻉构造和拷⻉赋值。</li></ul> <br><h3>defult和delete</h3> <br><ul><li>C++11可以让你更好的控制要使⽤的默认函数。假设你要使⽤某个默认的函数，但是因为⼀些原因这个函数没有默认⽣成。⽐如：我们提供了拷⻉构造，就不会⽣成移动构造了，那么我们可以使⽤default关键字显式指定移动构造⽣成。</li><li>如果能想要限制某些默认函数的⽣成，在C++98中，是该函数设置成private，并且只声明补丁已， 这样只要其他⼈想要调⽤就会报错。在C++11中更简单，只需在该函数声明加上=delete即可，该语 法指⽰编译器不⽣成对应函数的默认版本，称=delete修饰的函数为删除函数。 </li></ul> <br><pre><code class="language-cpp">class Person<br>{<br>public:<br>	Person(const char* name = "", int age = 0)<br>		:_name(name)<br>		, _age(age)<br>	{}<br>		Person(const Person & p)<br>		:_name(p._name)<br>		, _age(p._age)<br>	{}<br>	Person(Person&& p) = default;//强制编译器生成此类构造函数<br><br>	//Person(const Person& p) = delete;<br>	//编译器不会再自动生成此类构造函数<br>private:<br>	string _name;<br>	int _age;<br>};</code></pre> <br><h3>final与override关键字 </h3> <br><p>小老弟~ 忘了就老老实实去多态复习吧~  <a href="https://blog.csdn.net/2301_80194476/article/details/142217240" title="C++进阶：多态-CSDN博客">C++进阶：多态-CSDN博客</a></p> <br><h2>STL中⼀些变化</h2> <br><ul><li>C++11中STL中的新容器有：<array><forward_list><unordered_map><unordered_set>，但是实际最有⽤的是unordered_map和unordered_set。<a href="https://blog.csdn.net/2301_80194476/article/details/143109764?spm=1001.2014.3001.5501" title="C++进阶：哈希_c++ hash-CSDN博客">C++进阶：哈希_c++ hash-CSDN博客</a></li><li>STL中容器的新接⼝也不少，最重要的就是右值引⽤和移动语义相关的push/insert/emplace系列 接⼝和移动构造和移动赋值，还有initializer_list版本的构造等，这些前⾯都讲过了。</li><li>容器的范围for遍历，这个在容器部分也讲过了。 </li><li><span style="color:#be191c;"><strong>如果忘记了老实复习奥！！！</strong></span></li></ul> <br><h2>lambda</h2> <br><h3>lambda表达式语法</h3> <br><ul><li>lambda 表达式<span style="color:#be191c;"><strong>本质是⼀个匿名函数对象</strong></span>，跟普通函数不同的是它<strong><span style="color:#be191c;">可以定义在函数内部</span></strong>。 lambda 表达式语法使⽤层⽽⾔没有类型，所以我们⼀般是<span style="color:#be191c;"><strong>⽤auto或者模板参数定义的对象去接收 lambda 对象。</strong></span></li><li>lambda表达式的格式： <pre><code class="language-cpp"> [capture-list] (parameters)-> return type { function boby }</code></pre> </li><li>[capture-list] : 捕捉列表，该列表总是出现在 lambda 函数的开始位置，编译器根据[]来判断接下来的代码是否为 lambda 函数，捕捉列表能够捕捉上下⽂中的变量供 lambda 函数使⽤，捕捉列表可以传值和传引⽤捕捉，具体细节下面有专门讲解。<span style="color:#4da8ee;"><strong>捕捉列表为空也不能省略。</strong></span></li><li>(parameters) ：参数列表，与普通函数的参数列表功能类似，<span style="color:#4da8ee;"><strong>如果不需要参数传递，则可以连 同()⼀起省略</strong></span></li><li>->return type ：返回值类型，⽤追踪返回类型形式声明函数的返回值类型，<span style="color:#4da8ee;"><strong>没有返回值时此 部分可省略。⼀般返回值类型明确情况下，也可省略，由编译器对返回类型进⾏推导。</strong></span></li><li>{function boby} ：<span style="color:#be191c;"><strong>函数体，函数体内的实现跟普通函数完全类似，在该函数体内，除了可以 使⽤其参数外，还可以使⽤所有捕获到的变量，函数体为空也不能省略。 </strong></span></li></ul> <br><pre><code class="language-cpp">int main()<br>{<br>	// ⼀个简单的lambda表达式<br>	auto add1 = [](int x, int y)->int {return x + y; };<br>	cout << add1(1, 2) << endl;<br>	// 1、捕捉为空也不能省略<br>	// 2、参数为空可以省略<br>	// 3、返回值可以省略，可以通过返回对象⾃动推导<br>	// 4、函数体不能省略<br>	auto func1 = []<br>	{<br>		cout << "hello Qin" << endl;<br>		return 0;<br>	};<br>	func1();<br>	int a = 0, b = 1;<br>	auto swap1 = [](int& x, int& y)<br>	{<br>		int tmp = x;<br>		x = y;<br>		y = tmp;<br>	};<br>	swap1(a, b);<br>	cout << a << ":" << b << endl;<br>	return 0;<br>}</code></pre> <br><h3> 捕捉列表</h3> <br><ul><li>lambda 表达式中<span style="color:#be191c;"><strong>默认只能⽤ lambda 函数体和参数中的变量，</strong></span>如果想⽤外层作⽤域中的变量就需要进⾏捕捉</li><li>第⼀种捕捉⽅式是<span style="color:#be191c;"><strong>在捕捉列表中显式的传值捕捉和传引⽤捕捉</strong></span>，捕捉的多个变量⽤逗号分割。[x， y， &z] 表⽰x和y值捕捉，z引⽤捕捉。</li><li>第⼆种捕捉⽅式是在捕捉列表中隐式捕捉，我们在捕捉列表写⼀个 = 表示隐式值捕捉，在捕捉列表写⼀个 & 表示隐式引⽤捕捉，这样我们 lambda 表达式中⽤了那些变量，编译器就会⾃动捕捉那些变量。（这里并不是把外部全部的变量都压入函数栈帧）</li><li>第三种捕捉⽅式是在捕捉列表中混合使⽤隐式捕捉和显式捕捉。<span style="color:#be191c;"><strong>[=, &x]表示其他变量隐式值捕捉， x引⽤捕捉；[&, x, y]表⽰其他变量引⽤捕捉，x和y值捕捉。</strong></span><span style="color:#38d8f0;"><strong>当使⽤混合捕捉时，第⼀个元素必须是 &或=，并且&混合捕捉时，后⾯的捕捉变量必须是值捕捉，同理=混合捕捉时，后⾯的捕捉变量必须是引⽤捕捉。</strong></span></li><li><span style="color:#ed7976;"><strong>lambda 表达式如果在函数局部域中，他可以捕捉 lambda 位置之前定义的变量，不能捕捉静态局部变量和全局变量，静态局部变量和全局变量也不需要捕捉， lambda 表达式中可以直接使⽤。</strong></span><span style="color:#be191c;"><strong>这也意味着 lambda 表达式如果定义在全局位置，捕捉列表必须为空。</strong></span></li><li>默认情况下， lambda 捕捉列表是被const修饰的，也就是说传值捕捉的过来的对象不能修改， <span style="color:#be191c;"><strong>mutable加在参数列表的后⾯可以取消其常量性</strong></span>，也就说使⽤该修饰符后，传值捕捉的对象就可以修改了，但是<span style="color:#be191c;"><strong>修改还是形参对象，不会影响实参。使⽤该修饰符后，参数列表不可省略(即使参数为空)。</strong></span></li></ul> <br><pre><code class="language-cpp">int a = 0, b = 1, c = 2, d = 3;<br>// 传值捕捉本质是⼀种拷贝,并且被const修饰了<br>// mutable相当于去掉const属性，可以修改了<br>// 但是修改了不会影响外⾯被捕捉的值，因为是⼀种拷贝<br>auto func7 = [=]()mutable<br>{<br>	a++;<br>	b++;<br>	c++;<br>	d++;<br>	return a + b + c + d;<br>};</code></pre> <br><h3> lambda的应⽤</h3> <br><ul><li>在学习 lambda 表达式之前，我们的使⽤的<span style="color:#be191c;"><strong>可调⽤对象</strong></span>只有函数指针和仿函数对象，函数指针的类型定义起来⽐较⿇烦，仿函数要定义⼀个类，相对会⽐较⿇烦。使⽤ lambda 去定义可调⽤对象，既简单⼜⽅便。</li><li>lambda 在很多其他地⽅⽤起来也很好⽤。⽐如线程中定义线程的执⾏函数逻辑，智能指针中定制删除器等， lambda 的应⽤还是很⼴泛的。</li></ul> <br><pre><code class="language-cpp">struct Goods<br>{<br>	string _name; // 名字<br>	double _price; // 价格<br>	int _evaluate; // 评价<br>	// ...<br>	Goods(const char* str, double price, int evaluate)<br>		:_name(str)<br>		, _price(price)<br>		, _evaluate(evaluate)<br>	{}<br>};</code></pre> <br><pre><code class="language-cpp">int main()<br>{<br>	vector<Goods> v = { { "苹果", 2.1, 5 }, { "⾹蕉", 3, 4 }, { "橙⼦", 2.2, 3<br>	}, { "菠萝", 1.5, 4 } };<br>	// 类似这样的场景，我们实现仿函数对象或者函数指针支持商品中<br>	// 不同项的⽐较，相对还是比较麻烦的，那么这⾥lambda就很好⽤了<br><br>	sort(v.begin(), v.end(), [](const Goods& g1, const Goods& g2) {<br>		return g1._price < g2._price;<br>		});<br>	sort(v.begin(), v.end(), [](const Goods& g1, const Goods& g2) {<br>		return g1._price > g2._price;<br>		});<br>	sort(v.begin(), v.end(), [](const Goods& g1, const Goods& g2) {<br>		return g1._evaluate < g2._evaluate;<br>		});<br>	sort(v.begin(), v.end(), [](const Goods& g1, const Goods& g2) {<br>		return g1._evaluate > g2._evaluate;<br>		});<br>	return 0;<br>}</code></pre> <br><h3>lambda的原理</h3> <br><ul><li>lambda 的原理和范围for很像，编译后从汇编指令层的⻆度看，压根就没有 lambda 和范围for 这样的东西。<span style="color:#be191c;"><strong>范围for底层是迭代器，⽽lambda底层是仿函数对象，也就说我们写了⼀个 lambda 以后，编译器会⽣成⼀个对应的仿函数的类。</strong></span></li><li>仿函数的类名是编译按⼀定规则⽣成的，保证不同的 lambda ⽣成的类名不同（这里用到；了一个东西叫uuid），<span style="color:#b95514;"><strong>lambda参数/返回类型/函数体就是仿函数operator()的参数/返回类型/函数体， lambda 的捕捉列表本质是⽣成的仿函数类的成员变量，也就是说捕捉列表的变量都是 lambda 类构造函数的实参，当然隐式捕捉，编译器要看使⽤哪些就传那些对象。</strong></span> <img alt="" height="282" src="https://i-blog.csdnimg.cn/direct/8e70fee0228740aea332c4d16ffbae49.png" width="998" /></li><li>上⾯的原理，我们可以透过汇编层了解⼀下，下⾯第⼆段汇编层代码印证了上⾯的原理</li></ul> <br><pre><code class="language-cpp">class Rate<br>{<br>public:<br>	Rate(double rate)<br>		: _rate(rate)<br>	{}<br>	double operator()(double money, int year)<br>	{<br>		return money * _rate * year;<br>	}<br>private:<br>	double _rate;<br>};<br>int main()<br>{<br>	double rate = 0.49;<br>	// lambda<br>	// 捕捉列表的rate，可以看到作为lambda_1类构造函数的参数传递了，这样要拿去初始化成员变量<br>	auto r2 = [rate](double money, int year) {<br>		return money * rate * year;<br>		};<br>	// 函数对象<br>	Rate r1(rate);<br>	r1(10000, 2);<br>	r2(10000, 2);<br>	auto func1 = [] {<br>		cout << "hello world" << endl;<br>		};<br>	func1();<br>	return 0;<br>}<br></code></pre> <br><p><img alt="" height="694" src="https://i-blog.csdnimg.cn/direct/b4e47995c4164349b27ed7e273ae2666.png" width="1200" /></p> <br><h2> 包装器</h2> <br><h3>function</h3> <br><pre><code class="language-cpp">template <class T><br>class function; // undefined<br>template <class Ret, class... Args><br>class function<Ret(Args...)>;</code></pre> <br><p>std::function 是⼀个类模板，也是⼀个包装器。<span style="color:#be191c;"><strong> std::function 的实例对象可以包装存储其他的可调⽤对象，包括函数指针、仿函数、 lambda 、 bind 表达式等</strong></span>，存储的可调⽤对象被称为 std::function 的⽬标。若 std::function 不含⽬标，则称它为空。调⽤空 std::function 的⽬标导致抛出 <a href="https://zh.cppreference.com/w/cpp/utility/functional/bad_function_call" rel="nofollow" title="std::bad_function_call">std::bad_function_call</a> 异常。</p> <br><p>以上是 function 的原型，他被定义头⽂件中。<a href="https://zh.cppreference.com/w/cpp/utility/functional/function" rel="nofollow" title="std::function - cppreference.com">std::function - cppreference.com</a> 是function的官⽅⽂档</p> <br><p>函数指针、仿函数、 lambda 等可调⽤对象的类型各不相同， <span style="color:#be191c;"><strong>std::function 的优势就是统⼀类型，对他们都可以进⾏包装，</strong></span>这样在很多地⽅就⽅便声明可调⽤对象的类型，下⾯的第⼆个代码样例展示了 std::function 作为map的参数，实现字符串和可调⽤对象的映射表功能。</p> <br><pre><code class="language-cpp">#include<functional><br>int f(int a, int b)<br>{<br>	return a + b;<br>}<br>struct Functor<br>{<br>public:<br>	int operator() (int a, int b)<br>	{<br>		return a + b;<br>	}<br>};<br>class Plus<br>{<br>public:<br>	Plus(int n = 10)<br>		:_n(n)<br>	{}<br>	static int plusi(int a, int b)<br>	{<br>		return a + b;<br>	}<br>	double plusd(double a, double b)<br>	{<br>		return (a + b) * _n;<br>	}<br>private:<br>	int _n;<br>};<br>int main()<br>{<br>	// 包装各种可调⽤对象<br>	function<int(int, int)> f1 = f;<br>	function<int(int, int)> f2 = Functor();<br>	function<int(int, int)> f3 = [](int a, int b) {return a + b; };<br>	cout << f1(1, 1) << endl;<br>	cout << f2(1, 1) << endl;<br>	cout << f3(1, 1) << endl;<br><br>	// 包装静态成员函数<br>	// 成员函数要指定类域并且前⾯加&才能获取地址<br>	function<int(int, int)> f4 = &Plus::plusi;<br>	cout << f4(1, 1) << endl;<br><br>	// 包装普通成员函数<br>	// 普通成员函数还有⼀个隐含的this指针参数，所以绑定时传对象或者对象的指针过去都可以<br>	function<double(Plus*, double, double)> f5 = &Plus::plusd;<br>	Plus pd;<br>	cout << f5(&pd, 1.1, 1.1) << endl;<br><br>	function<double(Plus, double, double)> f6 = &Plus::plusd;<br>	cout << f6(pd, 1.1, 1.1) << endl;<br><br>	function<double(Plus&&, double, double)> f7 = &Plus::plusd;<br>	cout << f7(move(pd), 1.1, 1.1) << endl;<br>	cout << f7(Plus(), 1.1, 1.1) << endl;// 也可以传匿名对象<br>	return 0;<br>}</code></pre> <br><p> <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/" rel="nofollow" title="150. 逆波兰表达式求值 - 力扣（LeetCode）">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p> <br><pre><code class="language-cpp">#include<map><br>#include<stack><br>using namespace std;<br>// 使⽤map映射string和function的⽅式实现<br>// 这种⽅式的最⼤优势之⼀是⽅便扩展，假设还有其他运算，我们增加map中的映射即可<br>class Solution {<br>public:<br>	int evalRPN(vector<string>& tokens) {<br>		stack<int> st;<br>		// function作为map的映射可调⽤对象的类型<br>		map<string, function<int(int, int)>> opFuncMap = {<br>		{"+", [](int x, int y) {return x + y; }},<br>		{"-", [](int x, int y) {return x - y; }},<br>		{"*", [](int x, int y) {return x * y; }},<br>		{"/", [](int x, int y) {return x / y; }}<br>		};<br>		for (auto& str : tokens)<br>			if (opFuncMap.count(str)) // 操作符<br>			{<br>				int right = st.top();<br>				st.pop();<br>				int left = st.top();<br>				st.pop();<br>				int ret = opFuncMap[str](left, right);// <--核心代码<br>				st.push(ret);<br>			}<br>			else<br>				st.push(stoi(str));<br>		return st.top();<br>	}<br>};</code></pre> <br><h3 style="background-color:transparent;">bind </h3> <br><p><img alt="" height="136" src="https://i-blog.csdnimg.cn/direct/810a5f090e944cbbaea3a49f3fd39d84.png" width="1030" /></p> <br><ul><li>bind 是⼀个函数模板，它也是⼀个可调⽤对象的包装器，可以把他看做⼀个函数适配器，对接收的fn可调⽤对象进⾏处理后返回⼀个可调⽤对象。 bind 可以⽤来调整参数个数和参数顺序。 bind 也在这个头⽂件中。</li><li>调⽤bind的⼀般形式： <pre><code class="language-cpp">auto newCallable = bind(callable, arg_list);</code></pre> 其中 newCallable本⾝是⼀个可调⽤对象，arg_list是⼀个逗号分隔的参数列表，对应给定的callable的参数。当我们调⽤newCallable时，newCallable会调⽤callable，并传给它arg_list中的参数。</li><li>arg_list中的参数可能包含形如_n的名字，其中n是⼀个整数，这些参数是占位符，表示 newCallable的参数，它们占据了传递给newCallable的参数的位置。数值n表⽰⽣成的可调⽤对象中参数的位置：_1为newCallable的第⼀个参数，_2为第⼆个参数，以此类推。_1/_2/_3....这些占位符放到placeholders的⼀个命名空间中。  </li></ul> <br><pre><code class="language-cpp">#include<functional><br>using placeholders::_1;<br>using placeholders::_2;<br>using placeholders::_3;<br>int Sub(int a, int b)<br>{<br>	return (a - b) * 10;<br>}<br>int SubX(int a, int b, int c)<br>{<br>	return (a - b - c) * 10;<br>}<br>class Plus<br>{<br>public:<br>	static int plusi(int a, int b)<br>	{<br>		return a + b;<br>	}<br>	double plusd(double a, double b)<br>	{<br>		return a + b;<br>	}<br>};<br>int main()<br>{<br>	auto sub1 = bind(Sub, _1, _2);<br>	cout << sub1(10, 5) << endl;<br>	// bind 本质返回的⼀个仿函数对象<br>	// 调整参数顺序（不常用）<br>	// _1代表第一个实参<br>	// _2代表第二个实参<br>	// ...<br>	auto sub2 = bind(Sub, _2, _1);<br>	cout << sub2(10, 5) << endl;<br>	// 调整参数个数 （常用）<br>	auto sub3 = bind(Sub, 100, _1);<br>	cout << sub3(5) << endl;<br>	auto sub4 = bind(Sub, _1, 100);<br>	cout << sub4(5) << endl;<br>	// 分别绑死第123个参数<br>	auto sub5 = bind(SubX, 100, _1, _2);<br>	cout << sub5(5, 1) << endl;<br>	auto sub6 = bind(SubX, _1, 100, _2);<br>	cout << sub6(5, 1) << endl;<br>	auto sub7 = bind(SubX, _1, _2, 100);<br>	cout << sub7(5, 1) << endl;<br>	// 成员函数对象进行绑死，就不需要每次都传递了<br>	function<double(Plus&&, double, double)> f6 = &Plus::plusd;<br>	Plus pd;<br>	cout << f6(move(pd), 1.1, 1.1) << endl;<br>	cout << f6(Plus(), 1.1, 1.1) << endl;<br>	// bind⼀般⽤于，绑死一些固定参数<br>	function<double(double, double)> f7 = bind(&Plus::plusd, Plus(), _1, _2);<br>	cout << f7(1.1, 1.1) << endl;<br>	return 0;<br>}<br></code></pre> <br><p> bind绑定特定参数，function包装 计算复利</p> <br><pre><code class="language-cpp">// 计算复利的lambda<br>auto func1 = [](double rate, double money, int year)->double {<br>	double ret = money;<br>	for (int i = 0; i < year; i++)<br>	{<br>		ret += ret * rate;<br>	}<br>	return ret - money;<br>	};<br>// 绑死⼀些参数，实现出⽀持不同年化利率，不同金额和不同年份计算出复利的结算利息<br>function<double(double)> func3_1_5 = bind(func1, 0.015, _1, 3);<br>function<double(double)> func5_1_5 = bind(func1, 0.015, _1, 5);<br>function<double(double)> func10_2_5 = bind(func1, 0.025, _1, 10);<br>function<double(double)> func20_3_5 = bind(func1, 0.035, _1, 30);<br>cout << func3_1_5(1000000) << endl;<br>cout << func5_1_5(1000000) << endl;<br>cout << func10_2_5(1000000) << endl;<br>cout << func20_3_5(1000000) << endl;</code></pre> <br><p>未完待续……</p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>