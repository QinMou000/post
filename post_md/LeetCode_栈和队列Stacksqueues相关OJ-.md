<p></p> <br><blockquote> <br> <p><img alt="0c76f4c1e358481fbc51e89cd6e2e854.png" src="https://i-blog.csdnimg.cn/blog_migrate/6f2b920cd38b273e9349974209147fee.png" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12596977.html?spm=1001.2014.3001.5482" title="LeetCode刷题专栏">LeetCode刷题专栏</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><p style="text-align:center;">上一篇：<a href="https://blog.csdn.net/2301_80194476/article/details/138316164?spm=1001.2014.3001.5502" title="数据结构_栈和队列(Stack & Queue)-CSDN博客">数据结构_栈和队列(Stack & Queue)-CSDN博客</a> </p> <br><h2> 有效的括号</h2> <br><p><img alt="fa8665e0221848ac8d681622763fdf99.png" src="https://i-blog.csdnimg.cn/blog_migrate/e8149d836089e0c84451e50e63fdd788.png" /></p> <br><h3>解析:</h3> <br><p>这里我们用<strong>数组实现的栈</strong>来解决这个问题，在有了栈的几个基础接口之后，我们运用这几个接口解决问题。</p> <br><p>首先新建一个栈并初始化，进入循环如果当前指针指向的字符元素为左括号 {([ 就入栈，反之就出栈，之后判断指针指向的字符是否和出栈的字符左右括号相匹配。</p> <br><blockquote> <br> <p>(  (top == '{'&& *s != '}')  ||  (top == '['&& *s != ']')  ||  (top == '('&& *s !=')')  )</p> <br></blockquote> <br><p> 每次循环后s++，如果 *s != '\0' 就进行下一次循环。</p> <br><p>写完后提交会发现当只有一个元素的时候这种写法是不能过的</p> <br><p><img alt="e66b9b3067d24488a17ef5e12181c92a.png" src="https://i-blog.csdnimg.cn/blog_migrate/e96d71c188c0749440b2808c30db0731.png" /></p> <br><p> 这里我们在else里面做一个判空，因为如果进了else里面，就说明这是个右括号，那么栈里面一定有其所对应的左括号，如果这时后栈为空，那么显然括号之间是不匹配的。这样就很好的解决了诸如此类的问题。</p> <br><blockquote> <br> <p>if(STEmpty(&S))<br /> {<!-- --><br />         STDestroy(&S);<br />         return false;</p> <br> <p>}</p> <br></blockquote> <br><p>最后s遇到了 '\0' 循环结束，我们判断栈是否为空，如果为空返回true，否则栈中还有元素括号之间也是不匹配的。</p> <br><blockquote> <br> <p>return STEmpty(&S);</p> <br></blockquote> <br><p> 可以这么理解这两段代码：一个判断了左括号是否多了，一个判断了右括号是否多了。</p> <br><h3> 示例代码：</h3> <br><p> <a class="has-card" href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88" rel="nofollow" title="function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.7/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=O83A" alt="icon-default.png?t=O83A" />https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88</span></span></a></p> <br><pre><code class="language-cpp">bool isValid(char* s)<br>{<br>    ST S;<br>    STInit(&S);<br>    while(*s)<br>    {<br>        if(*s == '{' || *s == '[' || *s == '(')<br>        {<br>            STPush(&S,*s);<br>        }<br>        else<br>        {<br>            if(STEmpty(&S))<br>            {<br>                STDestroy(&S);<br>                return false;<br>            }<br>            char top = STTop(&S);<br>            STPop(&S);<br><br>            if((top == '{'&& *s != '}')||<br>            (top == '['&& *s != ']') ||<br>            (top == '('&& *s !=')'))<br>            {<br>                STDestroy(&S);<br>                return false;               <br>            }<br>        }<br>        s++;<br>    }<br>    return STEmpty(&S);<br>}</code></pre> <br><h2> 用队列实现栈</h2> <br><p><img alt="3aeb55e96b4742ab99063dab48a0291b.png" src="https://i-blog.csdnimg.cn/blog_migrate/ed48b1880d301091061c38e4b60a55fd.png" /></p> <br><h3>解析：</h3> <br><p>这里我们使用数组实现的队列，只需要创建两个队列，把数据在两个队列之间互相导就行了。</p> <br><h4>定义结构体MyStack：</h4> <br><p>将mystack结构体里面创建两个队列q1、q2。</p> <br><h4>myStackCreate函数：</h4> <br><p>malloc出结构体pst的内存空间 ，并将q1、q2交给 QueueInit函数，返回这个结构体。</p> <br><h4>myStackPush函数：</h4> <br><p>将数据方放进 QueuePush，入队列q1就行。</p> <br><h4>myStackPop函数：</h4> <br><p>将q1队列的数据转到q2里面，最后剩一个数据不转，直接删除，之后再将数据从q2转到q1里面。返回删除的那个数据。</p> <br><h4>myStackTop函数：</h4> <br><p>和上一个函数一样，只不过myStackTop不删除数据，直接返回就好了。</p> <br><h4>myStackEmpty函数：</h4> <br><blockquote> <br> <p>return !QueueSize(&(obj->q1));</p> <br></blockquote> <br><h4> myStackFree函数：</h4> <br><p>这里一定要先释放q1、q2的空间之后再释放pst。</p> <br><h3>示例代码：</h3> <br><p><a class="has-card" href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E9%98%9F%E5%88%97" rel="nofollow" title="function/队列 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">function/队列 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.7/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=O83A" alt="icon-default.png?t=O83A" />https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E9%98%9F%E5%88%97</span></span></a></p> <br><pre><code class="language-cpp"><br>typedef struct {<br>    Queue q1;<br>    Queue q2;<br>} MyStack;<br><br>MyStack* myStackCreate() {<br>    MyStack* pst = (MyStack*)malloc(sizeof(MyStack));<br>    QueueInit(&(pst->q1));<br>    QueueInit(&(pst->q2));<br><br>    return pst;<br>}<br><br>void myStackPush(MyStack* obj, int x) {<br>    QueuePush(&(obj->q1),x);<br>}<br><br>int myStackPop(MyStack* obj) {<br>    while(QueueSize(&(obj->q1)) != 1)<br>    {<br>        QueuePush(&(obj->q2),QueueFront(&(obj->q1)));<br>        QueuePop(&(obj->q1));<br>    }<br>    int tmp = QueueFront(&(obj->q1));<br>    QueuePop(&(obj->q1));<br>    while(QueueSize(&(obj->q2)))<br>    {<br>        QueuePush(&(obj->q1),QueueFront(&(obj->q2)));<br>        QueuePop(&(obj->q2));<br>    }<br>    return tmp;<br>}<br><br>int myStackTop(MyStack* obj) {<br>    return QueueBack(&(obj->q1));<br>}<br><br>bool myStackEmpty(MyStack* obj) {<br>    return !QueueSize(&(obj->q1));<br>}<br><br>void myStackFree(MyStack* obj) {<br>    Destory(&(obj->q1));<br>    Destory(&(obj->q2));<br>    free(obj);<br>}</code></pre> <br><h2> 用栈实现队列</h2> <br><p><img alt="55a9b73110954d878af70071ad863d35.png" src="https://i-blog.csdnimg.cn/blog_migrate/37ee7d3189a84bc474584017aac37a6d.png" /></p> <br><h3>解析：</h3> <br><p>此题与上题思路差不多，有一些细节上的改变，我们在代码里面细说。</p> <br><h4>定义结构体MyQueue：</h4> <br><p>创建两个栈st1、st2</p> <br><h4>myQueueCreate函数：</h4> <br><p>为MyQueue结构体malloc一块空间，将里面的st1、st2交给 STInit函数。</p> <br><h4>myQueuePush函数：</h4> <br><p>直接利用STPush函数插入就行。</p> <br><h4>myQueuePeek函数：</h4> <br><p>这里判断一下，如果st2为空的话，就将st1的数据转到st2来，取栈顶元素返回（转过来的时候数据会反过来）如果st2不为空，就直接返回st2栈顶元素。</p> <br><h4>myQueuePop函数：</h4> <br><p>这里本来也是要进行判断、转数据的，但是我们可以简化一下代码，直接调用myQueuePeek返回值存起来，这样st2必然就有数据，我们就可以直接pop掉st2里面的数据。</p> <br><h4>myQueueEmpty函数：</h4> <br><p>只有st1、st2同时为空，这个队列才为空。</p> <br><h4>myQueueFree函数：</h4> <br><p>先用 STDestroy释放掉st1、st2的空间，之后再free掉obj。</p> <br><blockquote> <br> <p><strong>总结：此题目不用将st2的数据再转回到st1里，相当于st2是专门用来出数据的，st1专门用来入数据的。</strong></p> <br></blockquote> <br><h3>示例代码：</h3> <br><p><a class="has-card" href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88" rel="nofollow" title="function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.7/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=O83A" alt="icon-default.png?t=O83A" />https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88</span></span></a></p> <br><pre><code class="language-cpp">typedef struct {<br>    ST st1;<br>    ST st2;<br>} MyQueue;<br><br>MyQueue* myQueueCreate() {<br>    MyQueue* Q = (MyQueue*)malloc(sizeof(MyQueue));<br>    STInit(&(Q->st1));<br>    STInit(&(Q->st2));<br>    return Q;<br>}<br><br>void myQueuePush(MyQueue* obj, int x) {<br>    STPush(&(obj->st1),x);<br>}<br><br>int myQueuePop(MyQueue* obj) {<br>    int tmp = myQueuePeek(obj);<br>    STPop(&(obj->st2));<br>    return tmp;<br>}<br><br>int myQueuePeek(MyQueue* obj) {<br>    if(STEmpty(&(obj->st2)))<br>    {<br>        while(!STEmpty(&(obj->st1)))<br>        {<br>            STPush(&(obj->st2),STTop(&(obj->st1)));<br>            STPop(&(obj->st1));<br>        }<br>        return STTop(&(obj->st2));<br>    }<br>    else<br>    {<br>        return STTop(&(obj->st2));<br>    }<br>}<br><br>bool myQueueEmpty(MyQueue* obj) {<br>    return (STEmpty(&(obj->st1)) && STEmpty(&(obj->st2)));<br>}<br><br>void myQueueFree(MyQueue* obj) {<br>    STDestroy(&(obj->st1));<br>    STDestroy(&(obj->st2));<br>    free(obj);<br>}</code></pre> <br><h2>设计循环队列 </h2> <br><p><img alt="7695610debf84b95b303e6eb554eeb23.png" src="https://i-blog.csdnimg.cn/blog_migrate/b4019437deac0c0948a493c052b063eb.png" /></p> <br><h3>解析：</h3> <br><p>用数组实现，多开辟一块空间，防止假溢出。或多定义一个size元素记录数组元素个数。主要都是为了解决判空和判满的问题。</p> <br><h4>定义MyCircularQueue结构体：</h4> <br><p>一个int*指针、一个head、一个tail、一个k表示队列容量。</p> <br><h4>myCircularQueueCreate函数：</h4> <br><p>为MyCircularQueue建立空间，并为data建立空间，其他值：obj->head = obj->tail = 0，obj->k = k。</p> <br><h4>myCircularQueueIsEmpty函数：</h4> <br><p>如果obj->head == obj->tail就为空，返回true，反之返回false。</p> <br><p><img alt="09c5a4dc0d664cceb48796cde149f93b.png" src="https://i-blog.csdnimg.cn/blog_migrate/70f273cddda855242457d1b652dee57d.png" /></p> <br><h4>myCircularQueueIsFull函数：</h4> <br><p>如果obj->head == (obj->tail+1)%(obj->k+1)就为满，返回true，反之返回false。</p> <br><p><img alt="2504324f2bc347de88ad48254f13d16a.png" src="https://i-blog.csdnimg.cn/blog_migrate/f7a7eb0e2e24031548c40ae8cf02235f.png" /></p> <br><h4>myCircularQueueEnQueue函数：</h4> <br><p>先判断是否为满，之后再往里面插入数据。注意这里tail的变化:</p> <br><blockquote> <br> <p style="text-align:center;">(obj->tail) %= (obj->k+1);</p> <br></blockquote> <br><h4>myCircularQueueDeQueue函数：</h4> <br><p>先判断是否为空，之后再删除数据。注意head的变化：</p> <br><blockquote> <br> <p style="text-align:center;"> (obj->head) %= (obj->k+1);</p> <br></blockquote> <br><h4>myCircularQueueFront函数：</h4> <br><blockquote> <br> <p style="text-align:center;">return myCircularQueueIsEmpty(obj)?-1:obj->data[obj->head];</p> <br></blockquote> <br><h4>myCircularQueueRear函数：</h4> <br><blockquote> <br> <p style="text-align:center;">return myCircularQueueIsEmpty(obj)?-1:obj->data[(obj->tail+obj->k)%(obj->k+1)];</p> <br></blockquote> <br><p>注意这里tail+1后可能回超出范围，所以我们要在这里模上(k+1)。</p> <br><h4>myCircularQueueFree函数：</h4> <br><p>先free掉obj->data,之后free掉obj。</p> <br><blockquote> <br> <p>总结：</p> <br> <p>我们要时刻注意，tail和head的范围，不能超过k，否则就应该模上(k+1)。其次这道题用单链表写会麻烦很多，因为不好处理循环的问题。如果你用双向循环链表，当我没说……（我们要用最少的消耗，干最多的事儿！）</p> <br></blockquote> <br><h3>示例代码：</h3> <br><pre><code class="language-cpp">typedef struct {<br>    int *data;<br>    int head;<br>    int tail;<br>    int k;<br>} MyCircularQueue;<br><br>MyCircularQueue* myCircularQueueCreate(int k) {<br>    MyCircularQueue* CQ = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));<br>    CQ->data = (int*)malloc(sizeof(int)*(k+1));//data需另外开辟空间<br>    CQ->head = 0;<br>    CQ->tail = 0;<br>    CQ->k = k;<br>    return CQ;<br>}<br><br>bool myCircularQueueIsEmpty(MyCircularQueue* obj) {<br>    return obj->head == obj->tail;<br>}<br><br>bool myCircularQueueIsFull(MyCircularQueue* obj) {<br>    return (obj->tail+1) % (obj->k + 1) == obj->head;<br>}<br><br>bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {<br>    if(myCircularQueueIsFull(obj))<br>        return false;<br><br>    obj->data[obj->tail] = value;<br>    obj->tail++;<br>    (obj->tail) %= (obj->k+1);<br>    return true;<br>}<br><br>bool myCircularQueueDeQueue(MyCircularQueue* obj) {<br>    if(myCircularQueueIsEmpty(obj))<br>        return false;<br><br>    obj->head++;<br>    (obj->head) %= (obj->k+1);<br>    return true;<br>}<br><br>int myCircularQueueFront(MyCircularQueue* obj) {<br>    return myCircularQueueIsEmpty(obj)?-1:obj->data[obj->head];<br>}<br><br>int myCircularQueueRear(MyCircularQueue* obj) {<br>    return myCircularQueueIsEmpty(obj)?-1:obj->data[(obj->tail+obj->k)%(obj->k+1)];<br>}<br><br>void myCircularQueueFree(MyCircularQueue* obj) {<br>    free(obj->data);<br>    free(obj);<br>}</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p> <br><p></p>