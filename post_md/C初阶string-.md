<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/a1e2fd8531ae4fbab004f1ecd1a2c8b1.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2> 为什么要学习string类</h2> <br><blockquote> <br> <p>C语言中，字符串是以'\0'结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列 的库函数，但是这些库函数与字符串是分离开的，不太符合OOP：面向对象编程（Object-Oriented Programming，简称OOP）的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。</p> <br> <p>在OJ中，有关字符串的题目基本以string类的形式出现，而且在常规工作中，为了简单、方便、 快捷，基本都使用string类，很少有人去使用C库中的字符串操作函数。</p> <br></blockquote> <br><h2> auto关键字</h2> <br><blockquote> <br> <p>（1）在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，后来这个不重要了。C++11中，标准委员会变废为宝赋予了auto全新的含义即：auto不再是一个存储类型 指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期<u><em><strong>推导而得</strong></em>。 </u></p> <br> <p>（2）<strong><em><u>用auto<span style="color:#ff9900;">声明指针类型时</span>，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加& </u></em></strong></p> <br> <p>（3）<strong><em><u>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错</u>，</em></strong>因为编译器实际 只对第一个类型进行推导，然后用推导出来的类型定义其他变量。</p> <br> <p>（4）<em><u><strong>auto不能作为函数的参数，可以做返回值，但是建议谨慎使用</strong></u></em></p> <br> <p>（5）<em><u><strong>auto不能直接用来声明数组</strong></u></em></p> <br></blockquote> <br><pre><code class="language-cpp">int main()<br>{<br>	int x = 10;<br>	auto y = &x;<br>	auto* z = &x;<br>	auto& m = x;<br><br>	cout << typeid(x).name() << endl;//输出：int<br>	cout << typeid(y).name() << endl;//输出：int * __ptr64<br>	cout << typeid(z).name() << endl;//输出：int * __ptr64<br><br>	return 0;<br>}</code></pre> <br><h2>范围for </h2> <br><blockquote> <br> <p>（1）对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因此 C++11中引入了基于范围的for循环。<u><em><strong>for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围，自动迭代，自动取数据，自动判断结束。</strong></em></u></p> <br> <p>（2）范围for可以作用到数组和容器对象上进行遍历</p> <br> <p>（3）范围for的底层很简单，容器遍历实际就是<em><u><strong>替换为迭代器</strong></u></em>，这个从汇编层也可以看到。</p> <br></blockquote> <br><pre><code class="language-cpp">int main()<br>{<br>	int arr[] = { 1,2,3,4,5 };<br>	for (auto& a : arr)<br>		cout << a << " ";<br>	cout << endl;<br><br>	string str("hello world");<br>	for (auto& ch : str)<br>		cout << ch;<br>	cout << endl;<br>	return 0;<br>}</code></pre> <br><h2>string常用接口</h2> <br><h3>常见构造</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数名(constructor)</td><td>功能说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/string/" rel="nofollow" title="string">string</a><span style="color:#6eaad7;"><strong>()</strong></span></td><td>构造空的string类对象，即空字符串</td></tr><tr><td><strong>string(conshar* s)t c</strong></td><td>用C-string来构造string类对象</td></tr><tr><td>string(size_t n,char c)</td><td>string类对象中包含n个字符c</td></tr><tr><td><strong>string(const string& s)</strong></td><td>拷贝构造函数</td></tr></tbody></table> <br><pre><code class="language-cpp">void Teststring()<br>{<br>	string s1;				 // 构造空的string类对象s1<br>	string s2("hello bit");  // 用C格式字符串构造string类对象s2<br>	string s3(s2);			 // 拷贝构造s3<br>}</code></pre> <br><h3>string类对象的容量操作</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/size/" rel="nofollow" title="size">size</a>（重点）</td><td>返回字符串有效字符长度</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/length/" rel="nofollow" title="length">length</a></td><td>返回字符串有效字符长度</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/capacity/" rel="nofollow" title="capacity">capacity</a></td><td>返回空间总大小（不包含'\0'）</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/empty/" rel="nofollow" title="empty">empty</a>（重点）</td><td>检测字符串释放为空串，是返回true，否则返回false</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/clear/" rel="nofollow" title="clear">clear</a>（重点）</td><td>清空有效字符</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/reserve/" rel="nofollow" title="reserve">reserve</a>（重点）</td><td>为字符串预留空间</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/resize/" rel="nofollow" title="resize">resize</a>（重点）</td><td>将有效字符的个数该成n个，多出的空间用字符c填充</td></tr></tbody></table> <br><blockquote> <br> <p>注意：</p> <br> <p>1. <strong><u><em>size()与length()方法底层实现原理完全相同</em></u></strong>，引入size()的原因是为了与其他容器的接 口保持一致，一般情况下基本都是用size()。</p> <br> <p>2. <u><em><strong>clear()只是将string中有效字符清空，不改变底层空间大小。</strong></em></u></p> <br> <p>3. resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的元素空间。<strong>（ps：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。）</strong></p> <br> <p>4. reserve(size_t res_arg=0)：为string预留空间，<u><em><strong>不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserver不会改变容量大小。</strong></em></u></p> <br></blockquote> <br><h3> string类对象的访问及遍历操作</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/operator%5B%5D/" rel="nofollow" title="operator[]">operator[]</a>（重点）</td><td>返回pos位置的字符，const string类对象调用</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/begin/" rel="nofollow" title="begin">begin</a><span style="color:#6eaad7;"><strong>和</strong></span><a href="https://legacy.cplusplus.com/reference/string/string/end/" rel="nofollow" title="end">end</a></td><td>begin获取一个字符的迭代器   end获取最后一个字符下一个位置的迭代器</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/rbegin/" rel="nofollow" title="rbegin">rbegin</a><span style="color:#6eaad7;"><strong>和</strong></span><a href="https://legacy.cplusplus.com/reference/string/string/rend/" rel="nofollow" title="rend">rend</a></td><td>rbegin获取最后一个字符的迭代器   rend获取第一个字符上一个位置的迭代器</td></tr><tr><td>范围for</td><td>C++11支持更简洁的范围for的新遍历方式</td></tr></tbody></table> <br><h3> string类对象的修改操作</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/push_back/" rel="nofollow" title="push_back">push_back</a></td><td>在字符串后尾插字符c</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/append/" rel="nofollow" title="append">append</a></td><td>在字符串后追加一个字符串</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/operator+=/" rel="nofollow" title="operator+=">operator+=</a>（重点）</td><td>在字符串后追加字符串str</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/c_str/" rel="nofollow" title="c_str">c_str</a>（重点）</td><td>返回C格式字符串(返回字符串第一个字符的指针)</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/find/" rel="nofollow" title="find">find</a>（重点）</td><td>从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/rfind/" rel="nofollow" title="rfind">rfind</a></td><td>从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/substr/" rel="nofollow" title="substr">substr</a></td><td>在str中从pos位置开始，截取n个字符，然后将其返回</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/npos/" rel="nofollow" title="npos">npos</a>（重点）</td><td>整型的最大值-1</td></tr></tbody></table> <br><blockquote> <br> <p> 注意：</p> <br> <p>1. 在string尾部追加字符时，s.push_back(c) / s.append(1, c) / s += 'c'三种的实现方式都差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。</p> <br> <p>2. 对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留好，减少消耗。</p> <br></blockquote> <br><h3>string类非成员函数</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/operator+/" rel="nofollow" title="operator+">operator+</a></td><td>尽量少用，因为传值返回，导致深拷贝效率低</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/operator%3E%3E/" rel="nofollow" title="operator>>">operator>></a>（重点）</td><td>输入运算符重载</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/operator%3C%3C/" rel="nofollow" title="operator<<">operator<<</a>（重点）</td><td>输出运算符重载</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/getline/" rel="nofollow" title="getline">getline</a>（重点）</td><td>获取一行字符串(可以包含空格)</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/string/string/operators/" rel="nofollow" title="relational operators">relational operators</a>（重点）</td><td>大小比较</td></tr></tbody></table> <br><h2>浅拷贝</h2> <br><p><strong><em>也称位拷贝，编译器只是将对象中的值拷贝过来。如果对象中管理资源，最后就会导致多个对象共享同一份资源，当一个对象销毁时就会将该资源释放掉，而此时另一些对象不知道该资源已经被释放，以为还有效，所以当继续对资源进项操作时，就会发生发生了访问违规。</em></strong></p> <br><p><img alt="" height="551" src="https://i-blog.csdnimg.cn/direct/fab8ac571555494b8ff99e159f4ecdad.png" width="1200" /></p> <br><h2>深拷贝</h2> <br><blockquote> <br> <p><em><strong>每个string对象都要有空间来放字符串，而s2要用s1拷贝构造出来因此需要给s2分配一块独立的空间，保证多个对象之间不会因共享资源而造成多次释放造成的程序崩溃问题</strong></em></p> <br> <p>如果一个类中涉及到资源的管理，其拷贝构造函数、赋值运算符重载以及析构函数必须要显式给 出。一般情况都是按照深拷贝方式提供。</p> <br></blockquote> <br><p><img alt="" height="536" src="https://i-blog.csdnimg.cn/direct/863a7699b9554890bdfbecd7b8a3d024.png" width="1200" /></p> <br><h2>模拟实现string类 </h2> <br><p><a href="https://gitee.com/wang-qin928/c-learning/tree/master/function/string%E7%B1%BB" rel="nofollow" title="function/string类 · 钦某/C++learning - 码云 - 开源中国 (gitee.com)">function/string类 · 钦某/C++learning - 码云 - 开源中国 (gitee.com)</a></p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>