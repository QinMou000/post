<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/a1e2fd8531ae4fbab004f1ecd1a2c8b1.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨</p> <br></blockquote> <br><h2> 构造函数中的初始化列表</h2> <br><p>• 之前实现构造函数时，初始化成员变量主要使⽤函数体内赋值，构造函数初始化还有⼀种⽅式，就是<strong>初始化列表</strong>，初始化列表的使⽤⽅式是以⼀个冒号开始，接着是⼀个以逗号分隔的数据成 员列表，每个"成员变量"后⾯跟⼀个放在括号中的初始值或表达式。</p> <br><pre><code class="language-cpp">class A<br>{<br>public:<br>	A()<br>		:_a(1)//初值<br>		,_b(1+1)//表达式<br>	{}<br>private:<br>	int _a;<br>	int _b;<br>};</code></pre> <br><p>• <strong>每个成员变量在初始化列表中<span style="color:#be191c;">只能出现⼀次</span></strong>，语法理解上初始化列表可以认为是每个成员变量定义初始化的地⽅。</p> <br><p><span style="color:#be191c;"><strong>• 引⽤成员变量（在定义的时候初始化，不能重新赋值），const成员变量（只能初始化，不能赋值），没有默认构造的类类型变量，必须放在初始化列表位置进⾏初始化，否则会编译报错。</strong></span></p> <br><pre><code class="language-cpp">class MyClass {<br>public:<br>    // 常量成员<br>    // error C2512: “Time”: 没有合适的默认构造函数可⽤<br>    const int constVar;<br><br>    // 引用成员<br>    // error C2530 : “Date::_ref” : 必须初始化引⽤<br>    int& refVar;<br><br>    // 没有默认构造函数的类类型成员<br>    // error C2789 : “Date::_n” : 必须初始化常量限定类型的对象<br>    AnotherClass obj;<br><br>    MyClass(int value, int& ref, AnotherClass objParam)<br>        : constVar(value), refVar(ref), obj(objParam) {}<br>};</code></pre> <br><p>• C++11⽀持在成员变量<strong>声明的位置给缺省值</strong>，这个缺省值主要是<strong>给没有显示在初始化列表初始化的成员使⽤的。</strong></p> <br><p>• 尽量使⽤初始化列表初始化，因为那些你不在初始化列表初始化的成员也会⾛初始化列表，如果这个<strong>成员在声明位置给了缺省值，初始化列表会⽤这个缺省值初始化</strong>。如果你<strong>没有给缺省值</strong>，对于<strong>没有显示在初始化列表初始化的内置类型成员</strong>是否初始化<strong>取决于编译器</strong>，C++并没有规定。对于<strong>没有显⽰在初始化列表初始化</strong>的<strong>⾃定义类型成员</strong>会调⽤这个成员类型的<strong>默认构造函数</strong>，如果没有默认构造会编译错误。</p> <br><p>• <strong>初始化列表中按照成员变量<span style="color:#be191c;">在类中声明顺序进⾏初始化</span></strong>，跟成员在初始化列表出现的的先后顺序⽆关。建议声明顺序和初始化列表顺序保持⼀致。</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br>class A<br>{<br>public:<br>	A(int a)<br>		:_a1(a)<br>		, _a2(_a1)<br>	{}<br>	void Print() {<br>		cout << _a1 << " " << _a2 << endl;<br>	}<br>private:<br>	int _a2 = 2;<br>	int _a1 = 2;<br>};<br>int main()<br>{<br>	A aa(1);<br>	aa.Print();//输出: 1 随机值<br>}</code></pre> <br><h2> 类型转换</h2> <br><p>• C++⽀持内置类型隐式类型转换为类类型对象，需要有相关内置类型为参数的构造函数。</p> <br><p>• 构造函数前⾯加explicit就不再⽀持隐式类型转换</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br>class A<br>{<br>public:<br>	//构造函数explicit就不再⽀持隐式类型转换<br>	 //explicit A(int a1)<br>		A(int a1)<br>		:_a1(a1)<br>	{}<br>	//explicit A(int a1, int a2)<br>	A(int a1, int a2)<br>		:_a1(a1)<br>		, _a2(a2)<br>	{}<br>	void Print() const<br>	{<br>		cout << _a1 << " " << _a2 << endl;<br>	}<br>private:<br>	int _a1 = 1;<br>	int _a2 = 2;<br>};<br>int main()<br>{<br>	// 1构造⼀个A的临时对象，再⽤这个临时对象拷⻉构造aa3<br>	// 编译器遇到连续构造+拷⻉构造->优化为直接构造<br>	A aa1 = 1;<br>	aa1.Print();<br>	const A& aa2 = 1;<br>	aa2.Print();<br>	// C++11之后才⽀持多参数转化<br>	A aa3 = { 2,2 };<br>	aa3.Print();<br>	return 0;<br>}</code></pre> <br><h2>static成员</h2> <br><p>• ⽤static修饰的成员变量，称之为静态成员变量，<strong>静态成员变量⼀定要<span style="color:#be191c;">在类外进⾏初始化</span></strong>。</p> <br><p>• 静态成员变量为<strong>所有类对象所共享</strong>，不属于某个具体的对象，不存在对象中，存放在<strong>静态区</strong>。</p> <br><p>• ⽤static修饰的成员函数，称之为静态成员函数，<span style="color:#be191c;"><strong>静态成员函数没有this指针。</strong></span></p> <br><p>• 静态成员函数中<strong>可以访问其他的静态成员</strong>，但是<span style="color:#be191c;"><strong>不能访问⾮静态的，因为没有this指针。</strong></span></p> <br><p>• <strong>⾮静态的成员函数，可以访问任意的静态成员变量和静态成员函数。</strong></p> <br><p>• <span style="color:#be191c;"><strong>突破类域就可以访问静态成员</strong></span>，可以通过<strong>类名::静态成员</strong> 或者 <strong>对象.静态成员</strong> 来访问静态成员变和静态成员函数。 </p> <br><p>• 静态成员也是类的成员，受public、protected、private 访问限定符的限制。</p> <br><p>• 静态成员变量<strong>不能在声明位置给缺省值初始化</strong>，因为缺省值是个构造函数初始化列表的，<span style="color:#be191c;"><strong>静态成员变量不属于某个对象，不⾛构造函数初始化列表。</strong></span></p> <br><pre><code class="language-cpp">// 实现⼀个类，计算程序中创建出了多少个类对象？<br>#include<iostream><br>using namespace std;<br>class A<br>{<br>public:<br>	A()<br>	{<br>		++_scount;<br>	}<br>	A(const A& t)<br>	{<br>		++_scount;<br>	}<br>	~A()<br>	{<br>		--_scount;<br>	}<br>	static int GetACount()<br>	{<br>		return _scount;<br>	}<br>private:<br>	// 类⾥⾯声明<br>	static int _scount;<br>};<br>// 类外⾯初始化<br>int A::_scount = 0;<br>int main()<br>{<br>	cout << A::GetACount() << endl;<br>	A a1, a2;<br>	A a3(a1);<br>	cout << A::GetACount() << endl;<br>	cout << a1.GetACount() << endl;<br>	//编译报错：error C2248: “A::_scount”: ⽆法访问 private 成员(在“A”类中声明)<br>	//cout << A::_scount << endl;<br>	return 0;<br>}<br></code></pre> <br><p> 有一道题：ABCD四个类，下面程序中它们的构造函数和析构函数的调用顺序分别是？</p> <br><pre><code class="language-cpp">C c;<br>int main()<br>{<br>	A a;<br>	B b;<br>	static D d;<br>	return;<br>}</code></pre> <br><blockquote> <br> <p>分析:</p> <br> <p>   1、类的析构函数调用一般按照构造函数调用的相反顺序进行调用，但是要注意static对象的存在， 因为<strong>static改变了对象的生存作用域</strong>，<strong>需要等待程序结束时才会析构释放对象</strong></p> <br> <p>   2、<strong>全局对象先于局部对象进行构造</strong></p> <br> <p>   3、<strong>局部对象按照出现的顺序进行构造，无论是否为static</strong></p> <br> <p>   4、所以构造的顺序为 C A B D</p> <br> <p>   5、析构的顺序按照构造的<strong>相反顺序析构</strong>，只需注意static改变对象的生存作用域之后，会<strong>放在局部对象之后进行析构</strong></p> <br> <p>   6、因此析构顺序为B A D C</p> <br></blockquote> <br><h2> 友元 </h2> <br><p>• 友元提供了⼀种<strong>突破类访问限定符封装</strong>的⽅式，友元分为：<strong>友元函数和友元类</strong>，在函数声明或者类声明的前⾯加friend，并且把友元声明放到⼀个类的⾥⾯。</p> <br><p>• 外部友元函数可访问类的私有和保护成员，友元函数<strong>仅仅是⼀种声明</strong>，他<strong>不是类的成员函数</strong>。</p> <br><p>• <strong>友元函数可以在类定义的任何地⽅声明，不受类访问限定符限制。</strong></p> <br><p>• <strong>⼀个函数可以是多个类的友元函数</strong>。</p> <br><p>• <strong>友元类中的成员函数都可以是另⼀个类的友元函数</strong>，都可以访问另⼀个类中的私有和保护成员。</p> <br><p>• <strong>友元类的关系是单向的，不具有交换性</strong>，⽐如A类是B类的友元，但是B类不是A类的友元。</p> <br><p>• 友元类关系<strong>不能传递</strong>，如果A是B的友元， B是C的友元，但是A不是B的友元。</p> <br><p>• 有时提供了便利。但是友元会增加耦合度，破坏了封装<strong>（我们需要高内聚低耦合）</strong>，所以友元不宜多⽤。</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br>// 前置声明，否则A的友元函数声明编译器不认识B，编译器都是从上到下识别的<br>class B;<br>class A<br>{<br>	// 外部函数友元声明<br>	friend void func(const A& aa, const B& bb);<br>private:<br>	int _a1 = 1;<br>	int _a2 = 2;<br>};<br>class B<br>{<br>	// 外部函数友元声明<br>	friend void func(const A& aa, const B& bb);<br>private:<br>	int _b1 = 3;<br>	int _b2 = 4;<br>};<br>void func(const A& aa, const B& bb)<br>{<br>	cout << aa._a1 << endl;// 访问类里面的私有成员变量<br>	cout << bb._b1 << endl;<br>}<br>int main()<br>{<br>	A aa;<br>	B bb;<br>	func(aa, bb);<br>	return 0;<br>}</code></pre> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br>class A<br>{<br>	// 类友元声明<br>	friend class B;<br>private:<br>	int _a1 = 1;<br>	int _a2 = 2;<br>};<br>class B<br>{<br>public:<br>	void func1(const A& aa)<br>	{<br>		cout << aa._a1 << endl;// 访问友元类的私有成员变量<br>		cout << _b1 << endl;<br>	}<br>	void func2(const A& aa)<br>	{<br>		cout << aa._a2 << endl;// 访问友元类的私有成员变量<br>		cout << _b2 << endl;<br>	}<br>private:<br>	int _b1 = 3;<br>	int _b2 = 4;<br>};<br>int main()<br>{<br>	A aa;<br>	B bb;<br>	bb.func1(aa);<br>	bb.func1(aa);<br>	return 0;<br>}</code></pre> <br><h2>内部类</h2> <br><p>• <strong>如果⼀个类定义在另⼀个类的内部</strong>，这个类就叫做内部类。内部类是⼀个独⽴的类，跟定义在全局相⽐，他只是受外部类类域限制和访问限定符限制，所以外部类定义的对象中不包含内部类。</p> <br><p>• <strong>内部类默认是外部类的友元类。（内部类可以访问外部类的私有成员变量类，但外部不能突破内部类的访问限定符）</strong></p> <br><p>• 内部类本质也是⼀种封装，当A类跟B类紧密关联，A类实现出来主要就是给B类使⽤，那么可以考 虑把A类设计为B的内部类，如果放到private/protected位置，那么A类就是B类的专属内部类，其 他地⽅都⽤不了。</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br>class A<br>{<br>private:<br>	static int _k;// 静态变量在类外初始化，不属于任何类，放在静态区<br>	int _h = 1;<br>public:<br>	class B // B默认就是A的友元<br>	{<br>	public:<br>		void foo(const A & a)<br>		{<br>			cout << _k << endl; <br>			cout << a._h << endl; // 内部类可以访问外部类的私有成员变量类，<br>			                      // 但外部不能突破内部类的访问限定符<br>		}<br>	};<br>};<br>int A::_k = 1;<br>int main()<br>{<br>	cout << sizeof(A) << endl;<br>	A::B b;// 注意对象定义方式<br>	A aa;<br>	b.foo(aa);<br>	return 0;<br>}</code></pre> <br><h2>匿名对象</h2> <br><p>• ⽤类型 (实参) 定义出来的对象叫做<strong>匿名对象</strong>，相⽐之前我们定义的 类型 对象名(实参) 定义出来的 叫<strong>有名对象</strong></p> <br><p>• <strong>匿名对象⽣命周期只在当前⼀⾏</strong>，⼀般临时定义⼀个对象当前⽤⼀下即可，就可以定义匿名对象。</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br>class A<br>{<br>public:<br>	A(int a = 0)<br>		:_a(a)<br>	{<br>		cout << "A(int a)" << endl;<br>	}<br>	~A()<br>	{<br>		cout << "~A()" << endl;<br>	}<br>private:<br>	int _a;<br>};<br>class Solution {<br>public:<br>	int Sum_Solution(int n) {<br>		//... 这个函数和类也没有直接关系<br>		return n;<br>	}<br>};<br>int main()<br>{<br>	A aa1;<br>	// 不能这么定义对象，因为编译器⽆法识别下⾯是⼀个函数声明，还是对象定义<br>	//A aa1();<br>	// 但是我们可以这么定义匿名对象，匿名对象的特点不⽤取名字，<br>	// 但是他的⽣命周期只有这⼀⾏，我们可以看到下⼀⾏他就会⾃动调⽤析构函数<br>	A();<br>	A(1);<br>	A aa2(2);<br>	// 匿名对象在这样场景下就很好⽤，当然还有⼀些其他使⽤场景，这个以后遇到了再说<br>	Solution().Sum_Solution(10);// 你只想调用以下这个类里面的某个函数<br>	return 0;<br>}</code></pre> <br><p>强大的编译器优化 </p> <br><p>• 现代编译器会为了尽可能提⾼程序的效率，在不影响正确性的情况下会尽可能减少⼀些传参和传参 过程中可以省略的拷⻉。</p> <br><p>• 如何优化C++标准并没有严格规定，各个编译器会根据情况⾃⾏处理。当前主流的相对新⼀点的编 译器对于连续⼀个表达式步骤中的连续拷⻉会进⾏合并优化，有些更新更"激进"的编译还会进⾏跨⾏跨表达式的合并优化。</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br>class A<br>{<br>public:<br>	A(int a = 0)<br>		:_a1(a)<br>	{<br>		cout << "A(int a)" << endl;<br>	}<br>	A(const A& aa)<br>		:_a1(aa._a1)<br>	{<br>		cout << "A(const A& aa)" << endl;<br>	}<br>	A& operator=(const A& aa)<br>	{<br>		cout << "A& operator=(const A& aa)" << endl;<br>		if (this != &aa)<br>		{<br>				_a1 = aa._a1;<br>		}<br>		return *this;<br>	}<br>	~A()<br>	{<br>		cout << "~A()" << endl;<br>	}<br>private:<br>	int _a1 = 1;<br>};<br>void f1(A aa)<br>{}<br>A f2()<br>{<br>	A aa;<br>	return aa;<br>}<br>int main()<br>{<br>	// 传值传参<br>	A aa1;<br>	f1(aa1);<br>	cout << endl;<br>	// 隐式类型，连续构造+拷⻉构造->优化为直接构造<br>	f1(1);<br>	// ⼀个表达式中，连续构造+拷⻉构造->优化为⼀个构造<br>	f1(A(2));<br>	cout << endl;<br>	cout << "***********************************************" << endl;<br>	// 传值返回<br>	// 返回时⼀个表达式中，连续拷⻉构造+拷⻉构造->优化⼀个拷⻉构造 （vs2019）<br>	// ⼀些编译器会优化得更厉害，进⾏跨⾏合并优化，直接变为构造。（vs2022）<br>	f2();<br>	cout << endl;<br>	// 返回时⼀个表达式中，连续拷⻉构造+拷⻉构造->优化⼀个拷⻉构造 （vs2019）<br>	// ⼀些编译器会优化得更厉害，进⾏跨⾏合并优化，直接变为构造。（vs2022）<br>	A aa2 = f2();<br>	cout << endl;<br>	// ⼀个表达式中，连续拷⻉构造+赋值重载->⽆法优化<br>	aa1 = f2();<br>	cout << endl;<br>	return 0;<br>}</code></pre> <br><p>代码输出结果： （VS2022）</p> <br><p><img alt="" height="674" src="https://i-blog.csdnimg.cn/direct/f5951462efd14c898f1c0a5339e8bb33.png" width="673" /></p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>