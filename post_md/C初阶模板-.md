<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/a1e2fd8531ae4fbab004f1ecd1a2c8b1.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2> 泛型编程</h2> <br><p>以前，我们经常用到交换函数swap，但是它的参数类型和返回值类型都是确定的。现在学习了C++的函数重载之后我们可以多重载几个参数类型和返回值类型不同的swap函数，但是这样有几个不好的地方</p> <br><blockquote> <br> <p>1. 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增 加对应的函数</p> <br> <p>2. 代码的可维护性比较低，一个出错可能所有的重载均出错</p> <br></blockquote> <br><p>那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？</p> <br><p><span style="color:#ff9900;"><strong>泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。</strong></span></p> <br><p><img alt="" height="377" src="https://i-blog.csdnimg.cn/direct/37c4cc2ad66048fb8303b7fe052ea21b.png" width="820" /></p> <br><h2> 函数模板</h2> <br><h3>概念及基础用法</h3> <br><p>函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生 函数的特定类型版本。</p> <br><pre><code class="language-cpp">template<typename T1, typename T2,…… typename Tn><br>返回值类型 函数名(参数列表) {}</code></pre> <br><p><span style="color:#ff9900;"><strong> 注意：typename是用来定义模板参数关键字，也可以使用class(切记：不能使用struct代替 class)</strong></span></p> <br><pre><code class="language-cpp">template<class T><br>T Swap(T x, T y){<br>	T tmp = x;<br>	x = y;<br>	y = tmp;<br>}</code></pre> <br><h3> 原理</h3> <br><p>函数模板是一个蓝图，<strong>它本身并不是函数</strong>，是编译器用使用方式产生特定具体类型函数的<strong>模具</strong>。 所以其实模板就是将本来应该我们做的重复的事情交给了编译器</p> <br><p>在编译器<strong>编译阶段</strong>，对于模板函数的使用，编译器需要根据传入的实参类型来<strong>推演生成对应类型的函数以供调用。</strong></p> <br><p><img alt="" height="466" src="https://i-blog.csdnimg.cn/direct/10ac0013669d49d9a1b0f1485e84eb73.png" width="1040" /></p> <br><p>比如：当用double类型使用函数模板时，编译器通过对实参类型的推演， 将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此。</p> <br><h3>函数模板的实例化</h3> <br><p><strong>用不同类型的参数使用函数模板时，称为函数模板的实例化。</strong></p> <br><p>模板参数实例化分为：隐式实例化和显式实例化。</p> <br><p>（1）隐式实例化：让编译器根据实参推演模板参数的实际类型</p> <br><pre><code class="language-cpp">template<class T><br>T Add(const T& left, const T& right)<br>{<br>	return left + right;<br>}<br>int main()<br>{<br>	int a1 = 10, a2 = 20;<br>	double d1 = 10.0, d2 = 20.0;<br>	Add(a1, a2);<br>	Add(d1, d2);<br>	/*<br>	该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型<br>	通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有<br>	一个T，编译器无法确定此处到底该将T确定为int 或者 double类型而报错<br>	注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅<br>	Add(a1, d1);<br>	*/<br>	// 此时有两种处理方式：1. 用户自己来强制转化 2. 使用显式实例化<br>	Add(a1, (int)d1);<br>	return 0;<br>}</code></pre> <br><p>（2）显式实例化：在函数名后的<>中指定模板参数的实际类型</p> <br><pre><code class="language-cpp">int main()<br>{<br>	int a = 10;<br>	double b = 20.0;<br>	// 显式实例化<br>	Add<int>(a, b);<br>	return 0;<br>}</code></pre> <br><p>如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。 </p> <br><h3>模板参数的匹配原则 </h3> <br><blockquote> <br> <p>（1）<strong>一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数</strong></p> <br> <pre><code class="language-cpp">// 专门处理int的加法函数<br>int Add(int left, int right)<br>{<br>	return left + right;<br>}<br>// 通用加法函数<br>template<class T><br>T Add(T left, T right)<br>{<br>	return left + right;<br>}<br>void Test()<br>{<br>	Add(1, 2); // 与非模板函数匹配，编译器不需要特化<br>	Add<int>(1, 2); // 调用编译器特化的Add版本<br>}</code></pre> <br> <p>（2）对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会<span style="color:#ff9900;"><strong>优先调用非模板函数而 不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板</strong></span></p> <br> <pre><code class="language-cpp">// 专门处理int的加法函数<br>int Add(int left, int right)<br>{<br>	return left + right;<br>}<br>// 通用加法函数<br>template<class T1, class T2><br>T1 Add(T1 left, T2 right)<br>{<br>	return left + right;<br>}<br>void Test()<br>{<br>	Add(1, 2); // 与非函数模板类型完全匹配，不需要函数模板实例化<br>	Add(1, 2.0); // 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数<br>}</code></pre> <br> <p>（3）模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</p> <br></blockquote> <br><h2>类模板</h2> <br><h3>定义模式</h3> <br><pre><code class="language-cpp">template<class T1, class T2, ……, class Tn><br>class 类模板名<br>{<br>	// 类内成员定义<br>};<br></code></pre> <br><p>例如实现一个类模板栈：</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br>// 类模版<br>template<typename T><br>class Stack<br>{<br>public:<br>	Stack(size_t capacity = 4)<br>	{<br>		_array = new T[capacity];<br>		_capacity = capacity;<br>		_size = 0;<br>	}<br>	void Push(const T& data);<br>private:<br>	T* _array;<br>	size_t _capacity;<br>	size_t _size;<br>};<br>// 模版不建议声明和定义分离到两个文件.h 和.cpp会出现链接错误<br>template<class T><br>void Stack<T>::Push(const T& data)<br>{<br>	// 扩容<br>	_array[_size] = data;<br>	++_size;<br>}<br>int main()<br>{<br>	Stack<int> st1; // int<br>	Stack<double> st2; // double<br>	return 0;<br>}</code></pre> <br><blockquote> <br> <p><strong>如果将模板的声明放在.h 文件中，而定义放在.cpp 文件中，会出现问题。在声明和定义分离的情况下，当在某个.cpp 文件中使用模板时，编译器会在该文件中寻找模板的定义以进行实例化。然而，由于定义在另一个.cpp 文件中，此时编译器无法找到具体的模板定义，它只会实例化函数的符号，而不会生成实际的函数实现代码。在链接阶段，链接器在符号表中找不到对应的函数实现，就会导致链接错误。</strong></p> <br></blockquote> <br><h3> 类模板的实例化</h3> <br><p>类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟<>，然后将实例化的 类型放在<>中即可，<span style="color:#ff9900;">类模板名字不是真正的类，而实例化的结果才是真正的类</span>。</p> <br><pre><code class="language-cpp">// Stack是类名，Stack<int>才是类型<br>Stack<int> st1; // int<br>Stack<double> st2; // double</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong> </p>