<blockquote> <br> <p style="text-align:center;"> <img alt="" height="412" src="https://i-blog.csdnimg.cn/direct/6cba51481e444fb6b602b9ddab2084cd.png" width="854" /></p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12841400.html?spm=1001.2014.3001.5482" title="MySql">MySql</a>✨✨</p> <br></blockquote> <br><p>我们知道，数据库里面会有成千上万条数据，我们会对这些数据进行CURD操作，如果我要在海量数据中查找一条特定的数据，不可能让数据库遍历这些数据。那么在数据库底层一定有一种数据结构，以便于我们快速查找，检索信息。</p> <br><p>那么这种数据结构是什么？它是怎么和信息匹配到一起的？它和本文要说的索引是什么关系？</p> <br><p>这一切的开始，我们先来认识一下磁盘，也就是数据库存储数据的地方。</p> <br><h2>认识磁盘</h2> <br><p>MySql给用户提供数据存储服务，存储的数据都放在磁盘上，磁盘是计算机的一个机械设备，相较于其他电子元件，磁盘的IO效率是较低的。再加上IO本身对操作系统的资源消耗，<span style="color:#b95514;"><strong>如何提高IO效率</strong></span>就成为了MySql的一个重要话题。</p> <br><p class="img-center"><img alt="" height="481" src="https://i-blog.csdnimg.cn/direct/9d54293f17564ec2b81eee3e11fe48e9.png" width="695" /></p> <br><h3 style="background-color:transparent;">盘片</h3> <br><p class="img-center"><img alt="" height="522" src="https://i-blog.csdnimg.cn/direct/e5b235cc9def48bbb7321cae55344e2c.png" width="888" /></p> <br><h3>扇区</h3> <br><p>数据库文件，本质其实就是保存在磁盘的盘片中，也就是上面的一个个小格子中，也就是扇区。数据库很大，也很多，一定需要占用很多个扇区。</p> <br><blockquote> <br> <ul><li>从上图可以看出，靠近盘中间的扇区的空间越小，距离圆心越远，扇区越大。</li><li>那么所有扇区都默认都是512字节吗？目前我们就这样认为，因为一个扇区多大是由比特位密度决定的。</li><li>但是最新的磁盘技术，已经可以让扇区的大小不同了，但是我们暂时不考虑。</li></ul> <br></blockquote> <br><p>我们在使用Linux，所看到的大部分目录或者文件，其实都是保存在硬盘中的（不考虑内存级文件系统，如proc，sys等）</p> <br><p>所以，找到一个文件的全部，本质就是找到其在磁盘上的扇区。</p> <br><p>如果我们能定位一个扇区，那么就能找到所有扇区，因为它们的寻找方式都是一样的。</p> <br><h3>定位扇区</h3> <br><p class="img-center"><img alt="" height="422" src="https://i-blog.csdnimg.cn/direct/f0b2b63f157a44a98b90172b5d92d2ea.png" width="658" /></p> <br><ul><li>柱面（磁道）：多盘磁盘，每盘都是双面，大小完全相等。那么同半径的磁道，整体便构成了一个柱面</li><li>每个盘面都有一个磁头，盘面和磁头的关系是一对一的</li><li>所以我们只需要知道，磁头Heads、柱面Cylinder（等价于磁道）、扇区Sector对应的编号。即可在磁盘上定位所要访问的扇区。这种磁盘定位方式叫做CHS。不过实际系统软件使用的并不是CHS，而是LBA，一种线性地址，可以想象成虚拟地址与物理地址。系统将 LBA 地址最后会转化成为 CHS ，交给磁盘去进行数据读取。但是这并不重要，知道就好。</li></ul> <br><p>那么我们在系统软件上是否就是以一个扇区（512或4096字节）进行IO交互吗？并不是</p> <br><ul><li>如果操作系统直接使用硬件提供的数据大小进行交互，那么系统的IO代码和硬件强相关，如果硬件发生变化，系统就必须跟着变。</li><li>从目前来看，单次512字节还是太小了。这意味这访问同样的数据内容，需要进行更多次的磁盘访问，带来效率降低。</li><li>文件系统的基本读取单位也不是扇区，而是数据块。</li></ul> <br><p>所以<span style="color:#b95514;"><strong>系统读取磁盘，是以块为单位的，基本单位是4KB。</strong></span></p> <br><h3>随机磁盘访问(Random Access)与连续磁盘访问(Sequential Access)</h3> <br><p><span style="color:#b95514;"><strong>随机访问：</strong></span>本次IO所给出的扇区地址与上次IO给出的扇区地址不连续，这样的话磁头在两次IO操作之间需要做比较大的移动动作才能重新开始读/写数据。</p> <br><p><span style="color:#b95514;"><strong>连续访问：</strong></span><span style="color:#333333;">如果当次IO</span><span style="color:#333333;">给出的扇区地址与上次</span><span style="color:#333333;">IO</span><span style="color:#333333;">结束的扇区地址是连续的，那磁头就能很快的开始这次 IO操作，这样的多个</span><span style="color:#333333;">IO</span><span style="color:#333333;">操作称为连续访问。</span></p> <br><p><span style="color:#333333;">因此尽管相邻的两次IO</span><span style="color:#333333;">操作在同一时刻发出，但如果它们的请求的扇区地址相差很大的话也只能称为随机访问，而非连续访问。</span></p> <br><p>磁盘是通过机械运动进行寻址的，随机访问需要过多的定位，所以故障率比较高</p> <br><h2>MySql与磁盘交互的基本单位</h2> <br><p>MySql作为一款应用软件，可以想象成一种特殊的文件系统。它有着更高的IO场景，为了提高基本的IO效率，<span style="color:#b95514;"><strong>MySql进行IO的基本单位是16KB</strong></span>。这个基本数据单元，在MySql这里叫做page（注意和系统的page区分）</p> <br><h2>共识</h2> <br><ul><li><span style="color:#333333;">MySQL</span><span style="color:#333333;">中的数据文件，是以</span><span style="color:#333333;">page</span><span style="color:#333333;">为单位保存在磁盘当中的。 </span></li><li><span style="color:#333333;">MySQL </span><span style="color:#333333;">的 </span><span style="color:#333333;">CURD </span><span style="color:#333333;">操作，都需要通过</span><span style="color:#b95514;"><strong>计算</strong></span><span style="color:#333333;">，找到对应的插入位置，或者找到对应要修改或者查询数据。 </span></li><li><span style="color:#333333;">而只要涉及计算，就需要</span><span style="color:#333333;">CPU</span><span style="color:#333333;">参与，而为了便于</span><span style="color:#333333;">CPU</span><span style="color:#333333;">参与，一定要能够</span><span style="color:#b95514;"><strong>先将数据移动到内存中。 </strong></span></li><li><span style="color:#333333;">所以在特定时间内，数据一定是磁盘中有，内存中也有。后续操作完内存数据之后，以特定的刷新策略，刷新到磁盘。而这时，就涉及到磁盘和内存的数据交互，也就是IO</span><span style="color:#333333;">了。而此时</span><span style="color:#333333;">IO</span><span style="color:#333333;">的基本单位就是Page</span><span style="color:#333333;">。 </span></li><li><span style="color:#333333;">为了更好的进行上面的操作， MySQL </span><span style="color:#333333;">服务器在内存中运行的时候，在服务器内部，就申请了被称为 Buffer Pool</span><span style="color:#333333;">的大内存空间，来进行各种缓存。其实就是很大的内存空间，来和磁盘数据进</span><span style="color:#333333;">行</span><span style="color:#333333;">IO</span><span style="color:#333333;">交互。 </span></li><li><span style="color:#333333;">为了更高的效率，一定要</span><span style="color:#b95514;"><strong>尽可能的减少系统和磁盘IO的次数</strong></span></li></ul> <br><h2>索引的理解</h2> <br><p>为何MySql与磁盘IO交互要以page为单位，为什么不用多少加载多少呢？</p> <br><p>假如我们在查id为1的记录，查完了马上又要查id为2的记录，用多少加载多少的话，这样就需要两次IO，如果我们把id为1到10都存在一个page里面。一次性加载进来，后面如果再需要查的话就直接在内存里面读取，就不用再进行磁盘IO了。</p> <br><p>那你怎么能保证，用户下次要查的数据就在这个page里面呢？我们肯定不能严格保证，但有很大概率，因为计算机的<span style="color:#be191c;"><strong>局部性原理</strong></span>：即在<span style="color:#b95514;"><strong>一段时间</strong></span>内，程序的执行通常会集中在<strong><span style="color:#b95514;">某个较小的内存区域内。</span></strong></p> <br><p>往往IO效率低下的最主要矛盾不是单词IO的数据量大小，而是IO次数。</p> <br><h3>理解单个page</h3> <br><p class="img-center"><img alt="" height="789" src="https://i-blog.csdnimg.cn/direct/1b8dfe029df04d6e8393f1aa9c60dae8.png" width="851" /></p> <br><p>在MySql中，不同的page都是16KB，使用prev和next构成双向链表。</p> <br><p>因为有主键，MySql会默认按照主键给我们的数据进行排序，从上面的Page内数据记录可以看出，<strong><span style="color:#b95514;">数据是有序并且彼此关联的。</span></strong></p> <br><p>插入数据时对数据进行排序，是为了<span style="color:#b95514;"><strong>方便查找</strong></span>，一个page里面存放数据的模块，实质上也是一个链表结构，<span style="color:#b95514;"><strong>链表的特点就是增删快，查询修改慢，所以优化查询效率是必须的。</strong></span></p> <br><p>因为有序，从前往后查找的每一次都是有效查找，没有任何一次查找是浪费的，并且有可能提前结束查找过程。</p> <br><h3>理解多个page</h3> <br><ul><li><span style="color:#333333;">通过上面的分析，我们知道，上面页模式中，只有一个功能，就是</span><span style="color:#b95514;"><strong>在查询某条数据的时候直接将一整页的数据加载到内存中，以减少硬盘IO次数，从而提高性能。</strong></span><span style="color:#333333;">但是，我们也可以看到，现在的页</span><span style="color:#333333;">模式内部，实际上是采用了链表的结构，前一条数据指向后一条数据，本质上还是通过数据的逐条</span><span style="color:#333333;">比较来取出特定的数据。 </span></li><li><span style="color:#333333;">如果有</span><span style="color:#333333;">1</span><span style="color:#333333;">千万条数据，一定需要多个</span><span style="color:#333333;">Page</span><span style="color:#333333;">来保存</span><span style="color:#333333;">1</span><span style="color:#333333;">千万条数据，多个</span><span style="color:#333333;">Page</span><span style="color:#333333;">彼此使用双链表链接起</span><span style="color:#333333;">来，而且每个</span><span style="color:#333333;">Page</span><span style="color:#333333;">内部的数据也是基于链表的。那么，查找特定一条记录，也一定是线性查找。这效率也太低了。</span></li></ul> <br><h3>页目录</h3> <br><div> <br> <span style="color:#333333;">我们在看《谭浩强</span> <br> <span style="color:#333333;">C</span> <br> <span style="color:#333333;">程序设计》这本书的时候，如果我们要看</span> <br> <span style="color:#333333;"><</span> <br> <span style="color:#333333;">指针章节</span> <br> <span style="color:#333333;">></span> <br> <span style="color:#333333;">，找到该章节有两种做法 </span> <br></div> <br><ul><li><span style="color:#333333;">从头逐页的向后翻，直到找到目标内容 </span></li><li><span style="color:#333333;">通过书提供的目录，发现指针章节在</span><span style="color:#333333;">234</span><span style="color:#333333;">页</span><span style="color:#333333;">(</span><span style="color:#333333;">假设</span><span style="color:#333333;">)</span><span style="color:#333333;">，那么我们便直接翻到</span><span style="color:#333333;">234</span><span style="color:#333333;">页。同时，查找目录的</span><span style="color:#333333;">方案，可以顺序找，不过因为目录肯定少，所以可以快速提高定位 </span></li><li><span style="color:#333333;">本质上，书中的目录，是多花了纸张的，但是却提高了效率 </span></li><li><span style="color:#333333;">所以，</span><span style="color:#b95514;"><strong>目录，是一种“空间换时间的做法”</strong></span></li></ul> <br><h3>单页情况</h3> <br><p>所以针对上面的单页page我们也可以引入目录。</p> <br><p class="img-center"><img alt="" height="821" src="https://i-blog.csdnimg.cn/direct/54d0c7c049db4ecfbdfe61200bebb1f7.png" width="951" /></p> <br><p>当前，我们在一个page内部引入了目录。如果这是我们要查找id为4的数据，之前必须遍历4次，才能拿到结果，现在直接通过目录2定位新的起始位置，提高了效率。现在可以正式回答为何MySql会对插入的数据进行键值自动排序？因为可以方便引入目录。</p> <br><h3 style="background-color:transparent;">多页情况</h3> <br><div> <br> <span style="color:#333333;">MySQL </span> <br> <span style="color:#333333;">中每一页的大小只有 </span> <br> <span style="color:#333333;">16KB </span> <br> <span style="color:#333333;">，单个</span> <br> <span style="color:#333333;">Page</span> <br> <span style="color:#333333;">大小固定，所以随着数据量不断增大， </span> <br> <span style="color:#333333;">16KB </span> <br> <span style="color:#333333;">不可能存下所有的数据，那么必定会有多个页来存储数据。</span> <br></div> <br><p class="img-center"><img alt="" height="717" src="https://i-blog.csdnimg.cn/direct/fd5ce8fec75c441585895e9984ee5e5e.png" width="1200" /></p> <br><p><span style="color:#333333;">在单表数据不断被插入的情况下， </span><span style="color:#333333;">MySQL </span><span style="color:#333333;">会在容量不足的时候，自动开辟新的</span><span style="color:#333333;">Page</span><span style="color:#333333;">来保存新的数据，然后通过指针的方式，将所有的Page</span><span style="color:#333333;">组织起来。</span></p> <br><p><span style="color:#333333;">需要注意，上面的图，是理想结构，目前要保证整体有序，那么新插入的数据，不一定会在新Page</span><span style="color:#333333;">上面，这里仅仅做演示。 </span></p> <br><div> <br> <span style="color:#333333;">这样，我们就可以通过多个</span> <br> <span style="color:#333333;">Page</span> <br> <span style="color:#333333;">遍历，</span> <br> <span style="color:#333333;">Page</span> <br> <span style="color:#333333;">内部通过目录来快速定位数据。可是，貌似这样也有效率问题，在Page</span> <br> <span style="color:#333333;">之间，也是需要 </span> <br> <span style="color:#333333;">MySQL </span> <br> <span style="color:#333333;">遍历的，遍历意味着依旧需要进行大量的</span> <br> <span style="color:#333333;">IO</span> <br> <span style="color:#333333;">，将下一个</span> <br> <span style="color:#333333;">Page</span> <br> <span style="color:#333333;">加载到内存，进行线性检测。这样就显得我们之前的Page</span> <br> <span style="color:#333333;">内部的目录，有点杯水车薪了。 </span> <br></div> <br><div> <br> <span style="color:#333333;">那么如何解决呢？解决方案，其实就是我们之前的思路，给</span> <br> <span style="color:#333333;">Page</span> <br> <span style="color:#333333;">也带上目录。</span> <br></div> <br><ul><li><span style="color:#333333;">使用一个目录项来指向某一页，而这个目录项存放的就是将要指向的页中存放的最小数据的键值。 </span></li><li><span style="color:#333333;">和页内目录不同的地方在于，这种目录管理的级别是页，而页内目录管理的级别是行。 </span></li><li><span style="color:#333333;">其中，每个目录项的构成是：键值</span><span style="color:#333333;">+</span><span style="color:#333333;">指针。图中没有画全。</span></li></ul> <br><p> ​​​​</p> <br><p class="img-center"><img alt="" height="788" src="https://i-blog.csdnimg.cn/direct/ebf9f19d6e3d4980935979ba0965df8a.png" width="1200" /></p> <br><div> <br> <span style="color:#333333;">存在一个目录页来管理页目录，目录页中的数据存放的就是指向的那一页中最小的数据。有数据，就可通过比较，找到该访问那个Page</span> <br> <span style="color:#333333;">，进而通过指针，找到下一个</span> <br> <span style="color:#333333;">Page</span> <br> <span style="color:#333333;">。 </span> <br></div> <br><div> <br> <span style="color:#333333;">其实</span> <br> <span style="color:#b95514;"><strong>目录页的本质也是页，普通页中存的数据是用户数据，而目录页中存的数据是普通页的地址。 </strong></span> <br></div> <br><div> <br> <span style="color:#333333;">可是，我们每次检索数据的时候，该从哪里开始呢？虽然顶层的目录页少了，但是还要遍历啊？不用担心，可以在加目录页 </span> <br></div> <br><p class="img-center"><img alt="" height="927" src="https://i-blog.csdnimg.cn/direct/84bd9549585e4f53a6c95af3ebe6b383.png" width="1200" /></p> <br><div> <br> <span style="color:#333333;">这货就是</span> <br> <span style="color:#be191c;"><strong>传说中的B+树啊！</strong></span> <br> <span style="color:#333333;">没错，至此，我们已经给我们的表</span> <br> <span style="color:#333333;">user</span> <br> <span style="color:#333333;">构建完了主键索引。 </span> <br></div> <br><div> <br> <span style="color:#333333;">随便找一个</span> <br> <span style="color:#333333;">id=</span> <br> <span style="color:#333333;">？我们发现，现在查找的</span> <br> <span style="color:#333333;">Page</span> <br> <span style="color:#333333;">数一定减少了，也就意味着</span> <br> <span style="color:#333333;">IO</span> <br> <span style="color:#333333;">次数减少了，那么效率也就提高了。</span>  <br></div> <br><p><span style="color:#333333;">Page分为目录页和数据页。目录页只放各个下级</span><span style="color:#333333;">Page</span><span style="color:#333333;">的最小键值。 </span></p> <br><div> <br> <span style="color:#333333;">那么查找的时候，自定向下找，只需要加载部分目录页到内存，即可完成算法的整个查找过程，大大减少了IO</span> <br> <span style="color:#333333;">次数</span> <br></div> <br><div></div> <br><div> <br> <span style="color:#333333;">InnoDB <strong>在建立索引结构来管理数据的时候，其他数据结构为何不行？ </strong></span> <br></div> <br><ul><li><span style="color:#333333;">链表？线性遍历 </span></li><li><span style="color:#333333;">二叉搜索树？退化问题，可能退化成为线性结构 </span></li><li><span style="color:#333333;">AVL </span><span style="color:#333333;">&&</span><span style="color:#333333;">红黑树？虽然是平衡或者近似平衡，但是毕竟是二叉结构，相比较多阶</span><span style="color:#333333;">B+</span><span style="color:#333333;">，意味着树</span><span style="color:#be191c;"><strong>整体过高</strong></span><span style="color:#333333;">，大家都是</span><span style="color:#be191c;"><strong>自顶向下找，层高越低，意味着系统与硬盘更少的IO Page交互。</strong></span><span style="color:#333333;">虽然你很秀，但</span><span style="color:#333333;">是有更秀的。 </span></li><li><span style="color:#333333;">Hash</span><span style="color:#333333;">？官方的索引实现方式中， </span><span style="color:#333333;">MySQL </span><span style="color:#333333;">是支持</span><span style="color:#333333;">HASH</span><span style="color:#333333;">的，不过 </span><span style="color:#333333;">InnoDB </span><span style="color:#333333;">和 </span><span style="color:#333333;">MyISAM </span><span style="color:#333333;">并不支持</span><span style="color:#333333;">.Hash</span><span style="color:#333333;">跟</span><span style="color:#333333;">进其算法特征，决定了虽然有时候也很快</span><span style="color:#333333;">(O(1))</span><span style="color:#333333;">，不过，在面对</span><span style="color:#be191c;"><strong>范围查找</strong></span><span style="color:#333333;">就明显不行，另外还有其</span><span style="color:#333333;">他差别。</span></li></ul> <br><p class="img-center"><img alt="" height="601" src="https://i-blog.csdnimg.cn/direct/3f2ea736889e4b128bda89bea76af454.png" width="1180" /></p> <br><h3 style="background-color:transparent;">B vs B+ </h3> <br><p class="img-center"><img alt="" height="1080" src="https://i-blog.csdnimg.cn/direct/90a894207f604cc9a92947876cd3836e.png" width="1200" /></p> <br><p>这两颗树的主要区别是 </p> <br><ul><li><span style="color:#0d0016;"><strong>B树节点，既有数据，又有Page指针，而B+，只有叶子节点有数据，其他目录页，只有键值和Page指针 </strong></span></li><li><span style="color:#0d0016;"><strong>B树插入和删除操作可能导致节点的分裂和合并，并且可能影响到多个层次的节点，操作相对复杂，维护成本较高。</strong></span></li><li><span style="color:#0d0016;"><strong>B+树非叶子节点不存储数据，相同大小的节点可以容纳更多的键值，从而减少了树的高度。</strong></span></li><li><span style="color:#0d0016;"><strong>B+叶子节点，全部相连，而B没有 </strong></span></li></ul> <br><div> <br> <span style="color:#333333;">为何选择</span> <br> <span style="color:#333333;">B+ </span> <br></div> <br><ul><li><strong><span style="color:#0d0016;">节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。 </span></strong></li><li><strong><span style="color:#0d0016;">叶子节点相连，更便于进行</span></strong><span style="color:#be191c;"><strong>范围查找</strong></span></li></ul> <br><h3>聚簇索引和非聚簇索引</h3> <br><div> <br> <span style="color:#333333;">MyISAM </span> <br> <span style="color:#333333;">存储引擎</span> <br> <span style="color:#333333;">-</span> <br> <span style="color:#333333;">主键索引 </span> <br></div> <br><div> <br> <span style="color:#333333;">MyISAM </span> <br> <span style="color:#333333;">引擎同样使用</span> <br> <span style="color:#333333;">B+</span> <br> <span style="color:#333333;">树作为索引结果，</span> <br> <span style="color:#b95514;"><strong>叶节点的data域存放的是数据记录的地址。</strong></span> <br> <span style="color:#333333;">下图为 </span> <br> <span style="color:#333333;">MyISAM 表的主索引， Col1</span> <br> <span style="color:#333333;">为主键。</span> <br></div> <br><div> <br> <p class="img-center"><img alt="" height="890" src="https://i-blog.csdnimg.cn/direct/83e737b1232543a4813c26beaae59b0e.png" width="1200" /></p> <br></div> <br><p><span style="color:#333333;">其中， MyISAM </span><span style="color:#333333;">最大的特点是，将索引</span><span style="color:#333333;">Page</span><span style="color:#333333;">和数据</span><span style="color:#333333;">Page</span><span style="color:#333333;">分离，也就是叶子节点没有数据，只有对应数据的地址。</span></p> <br><p><span style="color:#333333;">相较于 MyISAM索引， InnoDB </span><span style="color:#333333;">是将索引和数据放在一起的。</span></p> <br><pre><code class="language-sql">--终端A<br>mysql> create database myisam_test; --创建数据库<br>Query OK, 1 row affected (0.00 sec)<br>mysql> use myisam_test;<br>Database changed<br>mysql> create table mtest(<br>-> id int primary key,<br>-> name varchar(11) not null<br>-> )engine=MyISAM; --使用engine=MyISAM<br>Query OK, 0 rows affected (0.01 sec)<br>--终端B<br>[root@VM-0-3-centos mysql]# ls myisam_test/ -al --mysql数据目录下<br>total 28<br>drwxr-x--- 2 mysql mysql 4096 Jun 13 13:33 .<br>drwxr-x--x 13 mysql mysql 4096 Jun 13 13:32 ..<br>-rw-r----- 1 mysql mysql 61 Jun 13 13:32 db.opt<br>-rw-r----- 1 mysql mysql 8586 Jun 13 13:33 mtest.frm --表结构数据<br>-rw-r----- 1 mysql mysql 0 Jun 13 13:33 mtest.MYD --该表对应的数据，当前没有数<br>据，所以是0<br>-rw-r----- 1 mysql mysql 1024 Jun 13 13:33 mtest.MYI --该表对应的主键索引数据</code></pre> <br><p>其中<span style="color:#333333;">， </span><span style="color:#333333;">MyISAM </span><span style="color:#333333;">这种用户数据与索引数据分离的索引方案，叫做非聚簇索引</span></p> <br><pre><code class="language-sql">--终端A<br>mysql> create database innodb_test; --创建数据库<br>Query OK, 1 row affected (0.00 sec)<br>mysql> use innodb_test;<br>Database changed<br>mysql> create table itest(<br>-> id int primary key,<br>-> name varchar(11) not null<br>-> )engine=InnoDB; --使用engine=InnoDB<br>Query OK, 0 rows affected (0.02 sec)<br>--终端B<br>[root@VM-0-3-centos mysql]# ls innodb_test/ -al<br>total 120<br>drwxr-x--- 2 mysql mysql 4096 Jun 13 13:39 .<br>drwxr-x--x 14 mysql mysql 4096 Jun 13 13:38 ..<br>-rw-r----- 1 mysql mysql 61 Jun 13 13:38 db.opt<br>-rw-r----- 1 mysql mysql 8586 Jun 13 13:39 itest.frm --表结构数据<br>-rw-r----- 1 mysql mysql 98304 Jun 13 13:39 itest.ibd --该表对应的主键索引和用户<br>数据，虽然现在一行数据没有，但是该表并不为0，因为有主键索引数据</code></pre> <br><p><span style="color:#333333;">其中， InnoDB </span><span style="color:#333333;">这种用户数据与索引数据在一起索引方案，叫做聚簇索引 </span></p> <br><div> <br> <span style="color:#333333;">当然， </span> <br> <span style="color:#333333;">MySQL </span> <br> <span style="color:#333333;">除了默认会建立主键索引外，我们用户也有可能建立按照其他列信息建立的索引，一般这种索引可以叫做</span> <br> <span style="color:#b95514;"><strong>辅助（普通）索引。 </strong></span> <br></div> <br><div> <br> <span style="color:#333333;">对于 </span> <br> <span style="color:#333333;">MyISAM </span> <br> <span style="color:#333333;">,</span> <br> <span style="color:#333333;">建立辅助（普通）索引和主键索引没有差别，无非就是主键不能重复，而非主键可重复。 </span> <br></div> <br><div> <br> <span style="color:#333333;">下图就是基于 </span> <br> <span style="color:#333333;">MyISAM </span> <br> <span style="color:#333333;">的 </span> <br> <span style="color:#333333;">Col2 </span> <br> <span style="color:#333333;">建立的索引，和主键索引没有差别</span> <br></div> <br><p class="img-center"><img alt="" height="578" src="https://i-blog.csdnimg.cn/direct/bec0f6d9ab4e47e6a286fc980abf90e0.png" width="846" /></p> <br><p><span style="color:#333333;">同样， InnoDB </span><span style="color:#333333;">除了主键索引，用户也会建立辅助（普通）索引，我们以上表中的 </span><span style="color:#333333;">Col3 </span><span style="color:#333333;">建立对应的辅助.</span></p> <br><p><span style="color:#333333;">索引如下图：</span></p> <br><p class="img-center"><img alt="" src="https://i-blog.csdnimg.cn/direct/81ce8db7303d43b29115d849b0ca765f.jpeg" /></p> <br><div> <br> <span style="color:#333333;">可以看到，</span> <br> <span style="color:#b95514;"><strong>InnoDB 的非主键索引中叶子节点并没有数据，而只有对应记录的key值。 </strong></span> <br></div> <br><div></div> <br><div> <br> <span style="color:#333333;">所以通过辅助（普通）索引，找到目标记录，需要两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。这种过程，就叫做</span> <br> <span style="color:#b95514;"><strong>回表查询 </strong></span> <br></div> <br><div></div> <br><div> <br> <span style="color:#333333;">为何 </span> <br> <span style="color:#333333;">InnoDB </span> <br> <span style="color:#333333;">针对这种辅助（普通）索引的场景，不给叶子节点也附上数据呢？原因就是太浪费空间了。</span> <br></div> <br><div></div> <br><h2> 索引操作</h2> <br><h3>创建主键索引</h3> <br><p>方式一</p> <br><pre><code class="language-sql">-- 在创建表的时候，直接在字段名后指定 primary key<br>create table user1(id int primary key, name varchar(30));</code></pre> <br><p>方式二</p> <br><pre><code class="language-sql">-- 在创建表的最后，指定某列或某几列为主键索引<br>create table user2(id int, name varchar(30), primary key(id));</code></pre> <br><p>方式三</p> <br><pre><code class="language-sql">create table user3(id int, name varchar(30));<br>-- 创建表以后再添加主键<br>alter table user3 add primary key(id);</code></pre> <br><p>主键索引的特点</p> <br><ul><li><span style="color:#333333;">一个表中，最多有一个主键索引，当然可以是复合主键 </span></li><li><span style="color:#333333;">主键索引的效率高（主键不可重复） </span></li><li><span style="color:#333333;">创建主键索引的列，它的值不能为</span><span style="color:#333333;">null</span><span style="color:#333333;">，且不能重复 </span></li><li><span style="color:#333333;">主键索引的列基本上是</span><span style="color:#333333;">int</span></li></ul> <br><h3>唯一索引的创建</h3> <br><p>方式一</p> <br><pre><code class="language-sql">-- 在表定义时，在某列后直接指定unique唯一属性。<br>create table user4(id int primary key, name varchar(30) unique);</code></pre> <br><p>方式二</p> <br><pre><code class="language-sql">-- 创建表时，在表的后面指定某列或某几列为unique<br>create table user5(id int primary key, name varchar(30), unique(name));</code></pre> <br><p>方式三</p> <br><pre><code class="language-sql">create table user6(id int primary key, name varchar(30)）；<br>alter table user6 add unique(name);</code></pre> <br><p>唯一索引的特点</p> <br><ul><li><span style="color:#333333;">一个表中，可以有多个唯一索引 </span></li><li><span style="color:#333333;">查询效率高 </span></li><li><span style="color:#333333;">如果在某一列建立唯一索引，必须保证这列不能有重复数据 </span></li><li><span style="color:#333333;">如果一个唯一索引上指定</span><span style="color:#333333;">not null</span><span style="color:#333333;">，等价于主键索引</span></li></ul> <br><p>普通索引的创建</p> <br><p>方式一</p> <br><pre><code class="language-sql">create table user8(id int primary key,<br>    name varchar(20),<br>    email varchar(30),<br>    index(name) --在表的定义最后，指定某列为索引<br>);</code></pre> <br><p>方式二</p> <br><pre><code class="language-sql">create table user9(id int primary key, name varchar(20), email<br>varchar(30));<br>alter table user9 add index(name); --创建完表以后指定某列为普通索引</code></pre> <br><p>方式三 </p> <br><pre><code class="language-sql">create table user10(id int primary key, name varchar(20), email<br>varchar(30));<br>-- 创建一个索引名为 idx_name 的索引<br>create index idx_name on user10(name);</code></pre> <br><p>普通索引的特点</p> <br><ul><li><span style="color:#333333;">一个表中可以有多个普通索引，</span><span style="color:#0d0016;"><strong>普通索引在实际开发中用的比较多 </strong></span></li><li><span style="color:#333333;">如果某列需要创建索引，但是该列有重复的值，那么我们就应该使用普通索引</span></li></ul> <br><h3>全文索引的创建</h3> <br><p><span style="color:#333333;">当对文章字段或有大量文字的字段进行检索时，会使用到全文索引。MySQL</span><span style="color:#333333;">提供全文索引机制，但是有要求，要求表的存储引擎必须是MyISAM</span><span style="color:#333333;">，而且默认的全文索引支持英文，不支持中文。如果对中文进行全文检索，可以使用sphinx</span><span style="color:#333333;">的中文版</span><span style="color:#333333;">(coreseek)</span><span style="color:#333333;">。</span></p> <br><pre><code class="language-sql">CREATE TABLE articles (<br>    id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,<br>    title VARCHAR(200),<br>    body TEXT,<br>    FULLTEXT (title,body)<br>)engine=MyISAM;</code></pre> <br><pre><code class="language-sql">INSERT INTO articles (title,body) VALUES<br>('MySQL Tutorial','DBMS stands for DataBase ...'),<br>('How To Use MySQL Well','After you went through a ...'),<br>('Optimizing MySQL','In this tutorial we will show ...'),<br>('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),<br>('MySQL vs. YourSQL','In the following database comparison ...'),<br>('MySQL Security','When configured properly, MySQL ...');</code></pre> <br><ul><li>查询有database的数据</li></ul> <br><pre><code class="language-sql">mysql> select * from articles where body like '%database%';</code></pre> <br><p><span style="color:#333333;">如果使用这种查询方式，虽然查询出数据，但是没有使用到全文索引</span></p> <br><p><span style="color:#333333;">可以用</span><span style="color:#333333;">explain</span><span style="color:#333333;">工具看一下，是否使用到索引</span></p> <br><pre><code class="language-sql">mysql> explain select * from articles where body like '%database%'\G<br>*************************** 1. row ***************************<br>id: 1<br>select_type: SIMPLE<br>table: articles<br>type: ALL<br>possible_keys: NULL<br>key: NULL            <== key为null表示没有用到索引<br>key_len: NULL<br>ref: NULL<br>rows: 6<br>Extra: Using where<br>1 row in set (0.00 sec)</code></pre> <br><p>如何使用全文索引呢？</p> <br><pre><code class="language-sql">mysql> SELECT * FROM articles<br>    -> WHERE MATCH (title,body) AGAINST ('database');<br>+----+-------------------+------------------------------------------+<br>| id | title             | body                                     |<br>+----+-------------------+------------------------------------------+<br>| 5  | MySQL vs. YourSQL | In the following database comparison ... |<br>| 1  | MySQL Tutorial    | DBMS stands for DataBase ...             |<br>+----+-------------------+------------------------------------------+</code></pre> <br><p>通过<span style="color:#333333;">explain</span><span style="color:#333333;">来分析这个</span><span style="color:#333333;">sql</span><span style="color:#333333;">语句</span></p> <br><pre><code class="language-sql">mysql> explain SELECT * FROM articles WHERE MATCH (title,body) AGAINST<br>('database')\G<br>*************************** 1. row ***************************<br>id: 1<br>select_type: SIMPLE<br>table: articles<br>type: fulltext<br>possible_keys: title<br>key: title            <= key用到了title<br>key_len: 0<br>ref:<br>rows: 1<br>Extra: Using where</code></pre> <br><h3 style="background-color:transparent;">查询索引</h3> <br><p>方式一</p> <br><pre><code class="language-sql">show keys from 表名</code></pre> <br><pre><code class="language-sql">mysql> show keys from goods\G<br>*********** 1. row ***********<br>        Table: goods <= 表名<br>   Non_unique: 0 <= 0表示唯一索引<br>     Key_name: PRIMARY <= 主键索引<br> Seq_in_index: 1<br>  Column_name: goods_id <= 索引在哪列<br>    Collation: A<br>  Cardinality: 0<br>     Sub_part: NULL<br>       Packed: NULL<br>         Null:<br>   Index_type: BTREE <= 以B树（其实就是B+树）形式的索引<br>      Comment:<br>1 row in set (0.00 sec)</code></pre> <br><p>方式二</p> <br><pre><code class="language-sql">show index from 表名;</code></pre> <br><p>方式三</p> <br><pre><code class="language-sql">desc 表名；</code></pre> <br><h3>删除索引</h3> <br><p>方式一 -- 删除主键索引</p> <br><pre><code class="language-sql">alter table 表名 drop primary key;</code></pre> <br><p>方式二 -- 删除其他索引</p> <br><pre><code class="language-sql">alter table 表名 drop index <br>索引名； 索引名就是show keys from 表名中的 Key_name 字段</code></pre> <br><p>方式三</p> <br><pre><code class="language-sql">drop index 索引名 on 表名</code></pre> <br><p>索引创建原则</p> <br><ul><li><span style="color:#333333;">比较频繁作为查询条件的字段应该创建索引 </span></li><li><span style="color:#333333;">唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件 </span></li><li><span style="color:#333333;">更新非常频繁的字段不适合作创建索引 </span></li><li><span style="color:#333333;">不会出现在</span><span style="color:#333333;">where</span><span style="color:#333333;">子句中的字段不该创建索引</span></li></ul> <br><h2>复合索引</h2> <br><p>复合索引是一种数据库索引类型，它由表中的多个列组合而成，用于提高在这些列上进行查询的性能。以下从多个方面详细介绍复合索引：</p> <br><h3>定义与原理</h3> <br><p>在数据库中，当单个列的索引无法满足复杂查询的性能需求时，就可以创建复合索引。复合索引将多个列按照特定的顺序组合在一起，形成一个索引结构。数据库系统在使用复合索引时，会根据索引中列的顺序依次进行匹配和查找，从而快速定位到满足条件的行。</p> <br><h3>示例</h3> <br><p>假设有一个 “员工信息表”（employees），包含 “姓名”（name）、“部门”（department）、“入职时间”（hire_date）等列。如果经常需要执行类似 “查询某个部门中入职时间在特定范围内的员工” 这样的查询：</p> <br><pre><code>SELECT * FROM employees<br>WHERE department = '销售部' AND hire_date BETWEEN '2020-01-01' AND '2023-12-31';<br></code></pre> <br><p>为了提高这个查询的效率，可以在 “department” 和 “hire_date” 列上创建复合索引：</p> <br><pre><code>CREATE INDEX idx_department_hire_date ON employees (department, hire_date);<br></code></pre> <br><p>在这个复合索引中，“department” 是第一列，“hire_date” 是第二列。数据库在执行查询时，会先根据 “department” 列进行筛选，缩小查询范围，然后再在筛选后的结果中根据 “hire_date” 列进一步筛选，从而快速找到符合条件的员工记录。</p> <br><h3>注意事项</h3> <br><ul><li><strong>索引列顺序</strong>：复合索引中列的顺序非常重要。一般来说，将选择性高（即该列的值具有较多不同的取值）的列放在前面，这样可以更有效地缩小查询范围。例如，如果 “department” 列的取值种类比 “hire_date” 列多，那么将 “department” 列放在复合索引的第一列。</li><li><span style="color:#ff9900;"><strong>最左前缀原则</strong></span>：复合索引<span style="color:#be191c;"><strong>遵循最左前缀原则</strong></span>，即只有查询条件中使用了复合索引的最左边的列时，索引才会被使用。例如，上述创建的复合索引 “idx_department_hire_date”，如果查询语句是 “SELECT * FROM employees WHERE hire_date BETWEEN '2020-01-01' AND '2023-12-31';”，由于没有使用到 “department” 列（复合索引的最左边列），这个复合索引将不会被使用。</li><li><strong>维护成本</strong>：复合索引虽然可以提高查询性能，但也会增加索引的维护成本。每次对表中的数据进行插入、更新或删除操作时，数据库不仅要更新表数据，还要更新相应的复合索引，因此需要谨慎使用，避免创建过多不必要的复合索引。</li><li><span style="color:#ff9900;"><strong>索引覆盖</strong></span>：如果查询列都包含在复合索引里，数据库引擎可以直接从该索引中获取满足条件的数据，不会从其他索引中获取。但这会增加维护成本和存储空间。</li></ul> <br><div style="text-align:center;"> <br> <strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong>  <br></div>