<blockquote> <br> <p style="text-align:center;"><img alt="" height="412" src="https://i-blog.csdnimg.cn/direct/6cba51481e444fb6b602b9ddab2084cd.png" width="854" /></p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12841400.html?spm=1001.2014.3001.5482" title="MySql">MySql</a>✨✨</p> <br></blockquote> <br><p style="text-align:center;"><em><span style="color:#be191c;"><strong>本文的代码中， [ ] 里面的都可以省略</strong></span></em></p> <br><p>在 MySQL 中，<strong>CRUD</strong> 是数据库操作的核心，代表以下四种基本操作：</p> <br><ul><li><strong>C</strong>（Create）：创建、插入、数据。</li><li><strong>R</strong>（<span style="color:#333333;">Retrieve</span>）：检索、恢复、查询数据。</li><li><strong>U</strong>（Update）：更新数据。</li><li><strong>D</strong>（Delete）：删除数据。</li></ul> <br><h2>Create</h2> <br><ul><li>单行插入</li></ul> <br><p>        语法：</p> <br><pre><code class="language-sql">INSERT INTO 表名 (column1, column2, ...) VALUES (value1, value2, ...);</code></pre> <br><ul><li>多行插入</li></ul> <br><p>        语法：</p> <br><pre><code class="language-sql">INSERT INTO 表名 (column1, column2, ...) VALUES <br>(value1, value2, ...),<br>(value1, value2, ...)...;</code></pre> <br><p>在插入时，有时会遇到主键或唯一键冲突，而导致插入失败。这时我们可以：</p> <br><ul><li>使用 <code>INSERT IGNORE</code></li></ul> <br><p>忽略冲突并跳过报错</p> <br><pre><code class="language-sql">INSERT IGNORE INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);<br></code></pre> <br><blockquote> <br> <p>如果插入的记录导致主键或唯一键冲突，MySQL 会<span style="color:#b95514;"><strong>忽略这条记录，不会插入，也不会报错</strong></span>。</p> <br> <p>适合场景：只需确保数据唯一性，冲突时无需更新数据。</p> <br></blockquote> <br><ul><li>使用 <code>ON DUPLICATE KEY UPDATE</code></li></ul> <br><p>当冲突发生时，执行更新操作</p> <br><pre><code class="language-sql">INSERT INTO table_name (column1, column2, ...) <br>VALUES (value1, value2, ...)<br>ON DUPLICATE KEY UPDATE column2 = value2, column3 = value3;<br></code></pre> <br><blockquote> <br> <p>如果插入的记录导致主键或唯一键冲突，MySQL 会<strong><span style="color:#b95514;">更新指定的字段</span></strong>，而不是插入新记录。</p> <br> <p>适合场景：需要更新已存在的数据时。</p> <br></blockquote> <br><ul><li>使用 <code>REPLACE INTO</code></li></ul> <br><p>替换已有记录</p> <br><pre><code class="language-sql">REPLACE INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);<br></code></pre> <br><blockquote> <br> <p>如果记录已存在，MySQL 会删除原有记录，然后插入新记录。</p> <br> <p>适合场景：插入时确保数据完整替换。</p> <br></blockquote> <br><p><span style="color:#be191c;"><strong><code>REPLACE</code> 是先删除再插入，可能导致主键递增和触发器等副作用</strong></span></p> <br><h2> Retrieve</h2> <br><p>语法：</p> <br><pre><code class="language-sql">SELECT<br>[DISTINCT] {* | {column [, column] ...}<br>[FROM table_name]<br>[WHERE ...]<br>[ORDER BY column [ASC | DESC], ...]<br>LIMIT ...</code></pre> <br><ul><li>全列查询 </li></ul> <br><pre><code class="language-sql">SELECT * FROM table_name;</code></pre> <br><ul><li> 指定列查询</li></ul> <br><pre><code class="language-sql">SELECT column1, column2, column3 FROM table_name;</code></pre> <br><ul><li>查询字段为表达式</li></ul> <br><pre><code class="language-sql">SELECT column1, column2, column1+column2 FROM table_name;</code></pre> <br><ul><li>为查询结果指定别名</li></ul> <br><pre><code class="language-sql">SELECT column [AS] alias_name [...] FROM table_name;</code></pre> <br><ul><li>结果去重</li></ul> <br><pre><code class="language-sql">SELECT DISTINCT column FROM table_name</code></pre> <br><h3>条件筛选（WHERE子句）</h3> <br><p>比较运算符：</p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>运算符</td><td>说明</td></tr><tr><td>>、>=、<、<=</td><td>大于，大于等于，小于，小于等于</td></tr><tr><td>=</td><td>等于，NULL不安全，例如NULL=NULL的结果是NULL</td></tr><tr><td><=></td><td>等于，NULL安全，例如NULL=NULL的结果是TRUE(1)</td></tr><tr><td>!=<></td><td>不等于</td></tr><tr><td>BETWEEN a0 AND a1</td><td>范围匹配，[a0,a1]，如果a0 <= value <= a1，返回TRUE(1)</td></tr><tr><td>IN (option, ...)</td><td>如果是option中的任意一个，返回TRUE(1)</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr><tr><td>IS NOT NULL</td><td>不是NULL</td></tr><tr><td>LIKE</td><td> <p>模糊匹配，%表示任意多个（包括0个）任意字符，</p> <p>_表示任意一个字符</p> </td></tr></tbody></table> <br><p> 逻辑运算符：</p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>运算符</td><td>说明</td></tr><tr><td>AND</td><td>多个条件必须都为TRUE(1)，结果才是TRUE(1)</td></tr><tr><td>OR</td><td>任意一个条件为TRUE(1)，结果才为TRUE(1)</td></tr><tr><td>NOT</td><td>条件为TRUE(1)，结果为FALSE(0)</td></tr></tbody></table> <br><p>案例：</p> <br><p>假如我们有以下表结构和数据 </p> <br><p><img alt="" height="224" src="https://i-blog.csdnimg.cn/direct/d15499d1c1894dedab82ebc107f83116.png" width="621" /></p> <br><p><img alt="" height="264" src="https://i-blog.csdnimg.cn/direct/ea156bb329db403aa9ced431c68b3eb1.png" width="435" /></p> <br><ul><li>英语不及格的同学及其英语成绩（< 60）</li></ul> <br><pre><code class="language-sql">select name, english from exam_result where english < 60;</code></pre> <br><ul><li>语文成绩在[80，90]分的同学及其语文成绩</li></ul> <br><pre><code class="language-sql">select name, chinese from exam_result where chinese>=80 and chinese<=90;<br><br>select name, chinese from exam_result where chinese between 80 and 90;</code></pre> <br><ul><li><span style="color:#333333;">数学成绩是</span><span style="color:#333333;"> 58 </span><span style="color:#333333;">或者</span><span style="color:#333333;"> 59 </span><span style="color:#333333;">或者</span><span style="color:#333333;"> 98 </span><span style="color:#333333;">或者</span><span style="color:#333333;"> 99 </span><span style="color:#333333;">分的同学及其数学成绩</span></li></ul> <br><pre><code class="language-sql">select name, math from exam_result  <br>    where math = 58 <br>    or math = 59<br>    or math = 98<br>    or math = 99;<br><br>select name, math from exam_result where math in (58,59,98,99);</code></pre> <br><ul><li>姓孙的同学 及 孙某同学</li></ul> <br><pre><code class="language-sql">select name from exam_result where name like '孙%';<br><br>select name from exam_result where name like '孙_';</code></pre> <br><ul><li>语文成绩好于英语成绩的同学</li></ul> <br><pre><code class="language-sql">select name,chinese,english from exam_result where chinese>english;</code></pre> <br><ul><li>总分在200以下的同学</li></ul> <br><pre><code class="language-sql">select name,chinese+english+math total from exam_result <br>    where chinese+math+english<200;</code></pre> <br><ul><li style="text-align:center;"> <em><span style="color:#be191c;"><strong>WHERE 子句中使用表达式，别名不能用在 WHERE 子句中</strong></span></em></li><li>语文成绩 >80 并且不姓孙的同学</li></ul> <br><pre><code class="language-sql">select name,chinese from exam_result where chinese>80 and name not like '孙%';</code></pre> <br><p>孙某同学，否则要求总成绩 > 200 并且 语文成绩 < 数学成绩 并且  英语成绩 > 80</p> <br><pre><code class="language-sql">select name,chinese,math,english,chinese+math+english total <br>from exam_result <br>where name like '孙_' <br>or (chinese+math+english>200 and chinese<math and english>80);</code></pre> <br><h3> NULL的查询</h3> <br><ul><li>查询已知语文成绩的同学</li></ul> <br><pre><code class="language-sql">select name,chinese from exam_result where chinese is not NULL;</code></pre> <br><ul><li>NULL和NULL的比较，=和<=>的区别</li></ul> <br><p><img alt="" height="339" src="https://i-blog.csdnimg.cn/direct/bc771582d656487b843510b42cf4982a.png" width="428" /></p> <br><h3>结果排序（ORDER BY）</h3> <br><p>语法：</p> <br><pre><code class="language-sql">SELECT column1, column2, ...<br>FROM table_name<br>WHERE condition<br>ORDER BY column_name [ASC|DESC];<br><br>// ASC为升序<br>// DESC为降序</code></pre> <br><p style="text-align:center;"><span style="color:#be191c;"><em> <strong>没有 ORDER BY 子句的查询，返回的顺序是未定义的，永远不要依赖这个顺序</strong></em></span></p> <br><ul><li> 同学及其数学成绩，按数学成绩升序显示</li></ul> <br><pre><code class="language-sql">select name,math from exam_result order by math asc;</code></pre> <br><ul><li>如果需要先按一列排序，再对另一列排序，可以指定多列</li></ul> <br><pre><code class="language-sql">SELECT name, age, city<br>FROM users<br>ORDER BY city ASC, age DESC;<br></code></pre> <br><ul><li><span style="color:#333333;">查询同学各门成绩，依次按 数学降序，英语升序，语文升序的方式显示</span></li></ul> <br><pre><code class="language-sql">select name,chinese,math,english from exam_result <br>    order by math desc,english asc,chinese asc;</code></pre> <br><ul><li>查询同学总分，由高到低</li></ul> <br><pre><code class="language-sql">select name,chinese+math+english total from exam_result <br>    order by chinese+math+english desc;<br><br>select name,chinese+math+english total from exam_result <br>    order by total desc;</code></pre> <br><div style="text-align:center;"> <br> <em><span style="color:#be191c;"><strong>ORDER BY子句中可以使用表达式，也可以使用列别名</strong></span></em> <br></div> <br><ul><li><span style="color:#333333;">查询姓孙的同学或者姓曹的同学数学成绩，结果按数学成绩由高到低显示</span></li></ul> <br><pre><code class="language-sql">select name,math from exam_result <br>    where name like '孙%' or name like '曹%' <br>    order by math desc;</code></pre> <br><h3>筛选分页结果（LIMIT）</h3> <br><p>语法：</p> <br><pre><code class="language-sql">-- 起始下标为 0<br><br>-- 从 s 开始，筛选 n 条结果<br>SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT s, n;<br><br>-- 从 0 开始，筛选 n 条结果<br>SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n;<br><br>-- 从 s 开始，筛选 n 条结果，比第二种用法更明确，建议使用<br>SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n OFFSET s;</code></pre> <br><p style="text-align:center;"><em><span style="color:#be191c;"><strong>对未知表进行查询时，最好加一条 LIMIT 1，避免因为表中数据过大，查询全表数据导致数据库卡死</strong></span></em></p> <br><ul><li><span style="color:#333333;">按</span><span style="color:#333333;"> id </span><span style="color:#333333;">进行分页，每页</span><span style="color:#333333;"> 3 </span><span style="color:#333333;">条记录，分别显示 第</span><span style="color:#333333;"> 1</span><span style="color:#333333;">、</span><span style="color:#333333;">2</span><span style="color:#333333;">、</span><span style="color:#333333;">3 </span><span style="color:#333333;">页</span> </li></ul> <br><p><img alt="" height="594" src="https://i-blog.csdnimg.cn/direct/a776bbb470394f9eb23804a39b625dec.png" width="813" /></p> <br><h2>Update</h2> <br><pre><code class="language-sql">UPDATE table_name SET column = expr [, column = expr ...]<br>[WHERE ...] [ORDER BY ...] [LIMIT ...]</code></pre> <br><p><span style="color:#b95514;"><strong>对查询到的结果进行列值更新</strong></span></p> <br><ul><li>将孙悟空的数学成绩变更为80分</li></ul> <br><pre><code class="language-sql">update exam_result set math = 80 where name='孙悟空';</code></pre> <br><ul><li>将曹孟德同学的数学成绩变更为60分，语文成绩变更为70分</li></ul> <br><pre><code class="language-sql">update exam_result set math = 60, chinese = 70 where name = '曹孟德';</code></pre> <br><ul><li>将总成绩倒数前三的三位同学的数学成绩加上30分</li></ul> <br><pre><code class="language-sql">update exam_result set math = math+30 <br>    order by math+english+chinese asc limit 3;</code></pre> <br><p style="text-align:center;"><em><span style="color:#be191c;"><strong>数据更新不支持 math += 30 这种语法</strong></span></em></p> <br><ul><li>将所有同学的语文成绩更新为原来的二倍<span style="color:#ff9900;"><strong>（全表更新的语句慎用啊！大人！）</strong></span></li></ul> <br><pre><code class="language-sql">update exam_result set chinese = chinese*2;</code></pre> <br><h2>Delete</h2> <br><p>语法：</p> <br><pre><code class="language-sql">DELETE FROM table_name [WHERE ...] [ORDER BY ...] [LIMIT ...]</code></pre> <br><p>案例：</p> <br><ul><li>删除孙悟空的考试成绩</li></ul> <br><pre><code class="language-sql">delete from exam_result where name = '孙悟空';</code></pre> <br><ul><li>删除整张表数据<span style="color:#ff9900;"><strong>（删除整表的操作要慎用啊！大人！）</strong></span></li></ul> <br><p><img alt="" height="495" src="https://i-blog.csdnimg.cn/direct/595ff72e52b74edeb49863844e52397c.png" width="597" /></p> <br><p> 这时我们再插入一条数据</p> <br><p><img alt="" height="237" src="https://i-blog.csdnimg.cn/direct/8ddc1c893e7a4b55a8c7011981541d42.png" width="544" /></p> <br><p>查看表结构</p> <br><p><img alt="" height="217" src="https://i-blog.csdnimg.cn/direct/fb3f88b41748498b95622909f281c526.png" width="795" /></p> <br><h3>截断表</h3> <br><p>语法：</p> <br><pre><code class="language-sql">TRUNCATE [TABLE] table_name</code></pre> <br><div> <br> <span style="color:#ff9900;"><strong>注意：这个操作慎用 </strong></span> <br></div> <br><ol><li><span style="color:#333333;">只能对整表操作，不能像</span><span style="color:#333333;"> DELETE </span><span style="color:#333333;">一样针对部分数据操作； </span></li><li><span style="color:#333333;">实际上</span><span style="color:#333333;"> MySQL </span><span style="color:#333333;">不对数据操作，所以比</span><span style="color:#333333;"> DELETE </span><span style="color:#333333;">更快，但是</span><span style="color:#333333;">TRUNCATE</span><span style="color:#333333;">在删除数据的时候，并经过真正的事物，所以无法回滚 </span></li><li><span style="color:#333333;">会重置</span><span style="color:#333333;"> AUTO_INCREMENT项</span></li></ol> <br><p><img alt="" height="569" src="https://i-blog.csdnimg.cn/direct/13abdee38e324bdd8677bcebd7a88764.png" width="709" /></p> <br><p><img alt="" height="456" src="https://i-blog.csdnimg.cn/direct/4043729184be454bbe06ce64c38e1ee8.png" width="793" /></p> <br><h3>truncate和delete的区别</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>操作</td><td>TRUNCATE</td><td>DELETE</td></tr><tr><td>作用</td><td> <p>删除表中的所有数据，</p> <p>同时重置自增列（如果存在）</p> </td><td> <p>删除表中满足条件的数据，</p> <p>可选择性删除</p> </td></tr><tr><td>SQL语法</td><td>TRUNCATE TABLE 表名;</td><td>DELETE FROM 表名 WHERE 条件;</td></tr><tr><td>速度</td><td>更快（直接重置表，无需逐行删除）</td><td>较慢（逐行删除，可能触发触发器）</td></tr><tr><td>日志记录</td><td> <p>最小化日志记录</p> <p>（DDL：数据定义语言）</p> </td><td> <p>详细日志记录</p> <p>（DML：数据操作语言 ）</p> </td></tr><tr><td>事务支持</td><td>不支持事务回滚</td><td>支持事务回滚（需显式开启事务）</td></tr></tbody></table> <br><h2>插入查询结果</h2> <br><p>语法：</p> <br><pre><code class="language-sql">INSERT INTO table_name [(column [, column ...])] SELECT ...</code></pre> <br><p>案例：</p> <br><ul><li>删除表中的重复记录，重复的数据只能有一份</li></ul> <br><pre><code class="language-sql">-- 创建一张空表 no_duplicate_table，结构和 duplicate_table 一样<br>CREATE TABLE no_duplicate_table LIKE duplicate_table;<br>Query OK, 0 rows affected (0.00 sec)<br><br>-- 将 duplicate_table 的去重数据插入到 no_duplicate_table<br>INSERT INTO no_duplicate_table SELECT DISTINCT * FROM duplicate_table;<br>Query OK, 3 rows affected (0.00 sec)<br>Records: 3 Duplicates: 0 Warnings: 0<br><br>-- 通过重命名表，实现原子的去重操作<br>RENAME TABLE duplicate_table TO old_duplicate_table,<br>no_duplicate_table TO duplicate_table;<br>Query OK, 0 rows affected (0.00 sec)<br><br>-- 查看最终结果<br>SELECT * FROM duplicate_table;<br>+------+------+<br>| id   | name |<br>+------+------+<br>| 100  | aaa  |<br>| 200  | bbb  |<br>| 300  | ccc  |<br>+------+------+<br>3 rows in set (0.00 sec)</code></pre> <br><p><img alt="" height="783" src="https://i-blog.csdnimg.cn/direct/e599c157cba0488ba3b2290a9be5fabb.png" width="599" /></p> <br><h2>聚合函数</h2> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数</td><td>说明</td></tr><tr><td>COUNT([DISTINCT] expr)</td><td>返回查询到的数据的数量</td></tr><tr><td>SUM([DISTINCT expr])</td><td>返回查询到的数据的总和，不是数字没有意义</td></tr><tr><td>AVG([DISTINCT expr])</td><td>返回查询到的数据的平均值，不是数字没有意义</td></tr><tr><td>MAX([DISTINCT expr])</td><td>返回查询到的数据的最大值，不是数字没有意义</td></tr><tr><td>MIN([DISTINCT expr])</td><td>返回查询到的数据的最小值，不是数字没有意义</td></tr></tbody></table> <br><p>案例：</p> <br><ul><li>统计班级共有多少位同学</li></ul> <br><pre><code class="language-sql">SELECT COUNT(*) FROM students;<br><br>SELECT COUNT(1) FROM students;</code></pre> <br><ul><li>统计班级收集的qq号有多少（NULL不会被计入结果）</li></ul> <br><pre><code class="language-sql">SELECT COUNT(qq) FROM students;</code></pre> <br><ul><li>统计本次考试数学成绩分数个数</li></ul> <br><pre><code class="language-sql">--COUNT(math) 统计的是全部成绩<br>SELECT COUNT(math) FROM exam_result;<br><br>--COUNT(DISTINCT math) 统计的是去重成绩数量<br>SELECT COUNT(DISTINCT math) FROM exam_result;</code></pre> <br><ul><li>统计数学成绩总分</li></ul> <br><pre><code class="language-sql">SELECT SUM(math) FROM exam_result;</code></pre> <br><ul><li>统计平均总分</li></ul> <br><pre><code class="language-sql">SELECT AVG(chinese + math + english) 平均总分 FROM exam_result;</code></pre> <br><ul><li>返回英语最高分</li></ul> <br><pre><code class="language-sql">SELECT MAX(english) FROM exam_result;</code></pre> <br><ul><li>返回 >70 分以上的数学最低分</li></ul> <br><pre><code class="language-sql">SELECT MIN(math) FROM exam_result WHERE math > 70;</code></pre> <br><h2>group by子句</h2> <br><div> <br> <span style="color:#333333;">在</span> <br> <span style="color:#333333;">select</span> <br> <span style="color:#333333;">中使用</span> <br> <span style="color:#333333;">group by </span> <br> <span style="color:#333333;">子句可以对指定列进行分组查询</span> <br></div> <br><pre><code class="language-sql">select column1, column2, .. from table group by column;</code></pre> <br><div> <br> <span style="color:#333333;">案例： </span> <br></div> <br><p><span style="color:#333333;">准备工作，创建一个雇员信息表（来自</span><span style="color:#333333;">oracle 9i</span><span style="color:#333333;">的经典测试表） </span></p> <br><ul><li><span style="color:#333333;">EMP</span><span style="color:#333333;">员工表 </span></li><li><span style="color:#333333;">DEPT</span><span style="color:#333333;">部门表 </span></li><li><span style="color:#333333;">SALGRADE</span><span style="color:#333333;">工资等级表 </span></li></ul> <br><p><img alt="" height="185" src="https://i-blog.csdnimg.cn/direct/204f175f00944b38add0f4772daa97bb.png" width="344" /><img alt="" height="182" src="https://i-blog.csdnimg.cn/direct/82e5a911c2c54382a43b65a4d50fdf44.png" width="259" /><img alt="" height="425" src="https://i-blog.csdnimg.cn/direct/7ee50eef37a74e65ab7d11ee38689d95.png" width="829" /></p> <br><ul><li><span style="color:#333333;">如何显示每个部门的平均工资和最高工资</span></li></ul> <br><pre><code class="language-sql">select deptno,avg(sal),max(sal) from EMP group by deptno;</code></pre> <br><ul><li><span style="color:#333333;">显示每个部门的每种岗位的平均工资和最低工资</span></li></ul> <br><pre><code class="language-sql">select avg(sal),min(sal),job, deptno from EMP group by deptno, job;</code></pre> <br><ul><li><span style="color:#333333;">显示平均工资低于</span><span style="color:#333333;">2000</span><span style="color:#333333;">的部门和它的平均工资</span></li></ul> <br><pre><code class="language-sql">统计各个部门的平均工资<br>select avg(sal) from EMP group by deptno;<br><br>having和group by配合使用，对group by结果进行过滤<br>select avg(sal) as myavg from EMP group by deptno having myavg<2000;</code></pre> <br><div> <br> <span style="color:#0d0016;"><em>having经常和group by搭配使用，作用是对分组进行筛选，作用有些像where。但与where又有些不同</em></span> <br></div> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>特性</td><td>WHERE</td><td>HAVING</td></tr><tr><td>作用阶段</td><td>用于在GROUP BY之前过滤数据</td><td>用于在GROUP BY之后过滤数据</td></tr><tr><td>适用对象</td><td>适用于单行数据或未分组的记录</td><td>适用于分组后的聚合数据（如 SUM、AVG等）</td></tr><tr><td>语法位置</td><td>在GROUP BY或HAVING之前</td><td>在GROUP BY之后，ORDER BY之前</td></tr><tr><td>过滤目标</td><td>直接作用于表中的列</td><td>作用于聚合函数的结果或分组</td></tr><tr><td>性能差异</td><td>过滤数据的阶段较早，减少了数据处理量，性能更高</td><td>在分组后过滤，处理量可能较大</td></tr></tbody></table> <br><p style="text-align:center;"> <strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>