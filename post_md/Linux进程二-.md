<blockquote> <br> <p style="text-align:center;"><img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/a46182e6318c4593a5c674f2bf9439d4.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12799988.html" title="Linux">Linux</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2> 进程退出</h2> <br><h3><span style="color:#1f2329;">进程退出场景</span></h3> <br><p>进程退出无非以下三种情况：</p> <br><ul><li><span style="color:#646a73;">代码运⾏完毕，结果正确</span></li><li><span style="color:#646a73;">代码运⾏完毕，结果不正确</span></li><li><span style="color:#646a73;">代码异常终止</span></li></ul> <br><h3><span style="color:#1f2329;">进程退出码</span></h3> <br><p>在编程中，我们通常认为<em>main</em>函数是代码的入口，但实际上它只是用户级别代码的入口。<em>main</em>函数是被其他函数间接调用的，例如在<em>VS2013</em>中，<em>main</em>函数由<em>__tmainCRTStartup</em>函数调用，而<em>__tmainCRTStartup</em>函数又是通过加载器被操作系统调用。所以，<em>main</em>函数是间接性被操作系统所调用。</p> <br><p>由于main函数是这样被调用的，当main函数调用结束后，应该给操作系统返回相应的退出信息。这个退出信息以退出码的形式作为<em>main</em>函数的返回值返回。一般情况下，我们以0表示代码成功执行完毕，以非0表示代码执行过程中出现错误。这就是为什么我们常在<em>main</em>函数的最后返回0。</p> <br><p>执行以下代码： </p> <br><pre><code class="language-cpp">#include<stdio.h><br><br>int main()<br>{<br>    printf("hello Qin\n");<br>    return 0;<br>}</code></pre> <br><p> 我们可以通过<em>echo $?</em> 查看最近进程的退出码</p> <br><p><img alt="" height="110" src="https://i-blog.csdnimg.cn/direct/03b7afe88bb64e448fe869709cb19fcb.png" width="510" /></p> <br><p>进程正常退出返回0，如果进程不是正常退出就会返回其对应的退出码，在C语言中我们可以通过<em>strerror</em>函数打印出对应的错误信息。</p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<string.h><br>int main()<br>{<br>    for(int i = 0; i < 150; i++)<br>    {<br>        printf("[%d]->%s\n",i,strerror(i));<br>    }<br>    return 0;<br>}</code></pre> <br><p><img alt="" height="759" src="https://i-blog.csdnimg.cn/direct/ac24ef2674e04bfca4d146e606800736.png" width="608" /></p> <br><p>需要注意的是： 退出码都有对应的字符串含义，帮助用户确认执行失败的原因，而这些退出码具体代表什么含义是人为规定的，<span style="color:#b95514;">不同环境下相同的退出码的字符串含义可能不同。</span> </p> <br><h3>exit与_exit函数</h3> <br><p> <img alt="" height="219" src="https://i-blog.csdnimg.cn/direct/b4c1f22f8fa94c60b0bd39d851da6d0a.png" width="536" /><img alt="" height="219" src="https://i-blog.csdnimg.cn/direct/4fd3eaae08674d1ab86e9761f9315f48.png" width="550" /></p> <br><p><em>exit</em>函数可以在代码中的任何地方退出进程，并且<em>exit</em>函数在退出进程前会做一系列工作：</p> <br><ol><li>执行用户通过<em>atexit</em>或<em>on_exit</em>定义的清理函数。</li><li>关闭所有打开的流，所有的缓存数据均被写入。</li><li>调用<em>_exit</em>函数终止进程。</li></ol> <br><p><img alt="" height="650" src="https://i-blog.csdnimg.cn/direct/ab1683471b744225b8ed4364f448d53f.png" width="1050" /></p> <br><p> 例如以下代码：</p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<stdlib.h><br>int main()<br>{<br>    printf("hello Qin!");<br>    exit(1);<br>    return 0;<br>}</code></pre> <br><p> <img alt="" height="106" src="https://i-blog.csdnimg.cn/direct/fa6eefc6024d4fa585319dd950975138.png" width="633" /></p> <br><p> 如果我们使用的是<em>_exit</em>函数，那么进程就会直接退出，并不会做任何处理。（缓冲区不会刷新……）</p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<stdlib.h><br>int main()<br>{<br>    printf("hello Qin!");<br>    _exit(1);<br>    return 0;<br>}</code></pre> <br><p><img alt="" height="238" src="https://i-blog.csdnimg.cn/direct/778623af0cbb4eb4b92c2ed9c1bcc41c.png" width="1200" /></p> <br><p>总结： </p> <br><ul><li>首先只有在<em>main</em>函数当中的<em>return</em>才能起到退出进程的作用，子函数当中<em>return</em>不能退出进程，而<em>exit</em>函数和<em>_exit</em>函数在代码中的任何地方使用都可以起到退出进程的作用。</li><li>使用<em>exit</em>函数退出进程前，<em>exit</em>函数会执行用户定义的清理函数、冲刷缓冲，关闭流等操作，然后再终止进程，而<em>_exit</em>函数会直接终止进程，不会做任何收尾工作。</li></ul> <br><h2 style="background-color:transparent;"> 进程等待</h2> <br><h3>为什么？ </h3> <br><div> <br> <span style="color:#ed7976;">之前讲过，⼦进程退出，⽗进程如果不管不顾，就可能造成‘僵⼫进程’的问题，进⽽造成内存泄漏。 另外，进程⼀旦变成僵⼫状态，那就⼑枪不⼊，“杀⼈不眨眼”的<em>kill -9</em> 也⽆能为⼒，因为谁也 没有办法杀死⼀个已经死去的进程。最后，⽗进程派给⼦进程的任务完成的如何，我们需要知道。如，⼦进程运⾏完成，结果对还是不对，或者是否正常退出。⽗进程通过进程等待的⽅式，回收⼦进程资源，获取⼦进程退出信息</span> <br></div> <br><h3> 怎么做？</h3> <br><p><img alt="" height="335" src="https://i-blog.csdnimg.cn/direct/e0787d8900424e78b416cc670948b8a3.png" width="864" /></p> <br><h4>status参数</h4> <br><p>其中这两个关于进程等待的函数都有一个共同的参数<em>status</em>，如果对<em>status</em>参数传入<em>NULL</em>，表示不关心子进程的退出状态信息。否则，操作系统会通过该参数，将子进程的退出信息反馈给父进程。 </p> <br><p>*status虽然是一个整型变量，但*status不能简单的当作整型来看待，因为status的不同比特位所代表的信息不同，一般我们只考虑低的16个比特位。</p> <br><p>在*status的低16比特位当中，高8位表示进程的退出状态，即退出码。进程若是被信号所杀，则低7位表示终止信号，而第8位比特位是core dump标志。</p> <br><p> <img alt="" height="680" src="https://i-blog.csdnimg.cn/direct/0da76b59daa04202a318873aee47617c.png" width="1200" /></p> <br><p> 一般我们可以通过相关的位运算得到进程的退出码与退出信号。</p> <br><pre><code class="language-cpp">exitCode = (status >> 8) & 0xFF; //退出码 11111111<br>exitSignal = status & 0x7F;      //退出信号 01111111<br></code></pre> <br><p> 为了降低用户的使用成本，操作系统也为我们提供了两个宏表示对应的退出码与退出信号。</p> <br><blockquote> <br> <ul><li><em><strong>WIFEXITED(status)</strong></em>：用于查看进程是否是正常退出，本质是检查是否收到信号。</li><li><em><strong>WEXITSTATUS(status)</strong></em>：用于获取进程的退出码。</li></ul> <br></blockquote> <br><h4><span style="color:#1f2329;">wait</span></h4> <br><pre><code class="language-cpp">pid_t wait(int* status);<br>// 返回值:<br>//     成功返回被等待进程pid，失败返回-1。<br>// 参数:<br>//     输出型参数，获取子进程退出状态,不关⼼则可以设置成为NULL</code></pre> <br><p> 下面的代码我们用父进程一直等待子进程，然后获取其退出信息。</p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<unistd.h><br>#include<stdlib.h><br>#include<sys/wait.h><br>#include<sys/types.h><br>int main()<br>{<br>    pid_t id = fork();//创建子进程<br>    if(id==0)<br>    {<br>        //chlld<br>        int count = 5;<br>        while(count--)<br>        {<br>            printf("我是子进程，pid:%d，ppid:%d\n",getpid(),getppid());<br>            sleep(1);<br>        }<br>        exit(0);<br>    }<br>    //father<br>    int status = 0;<br>    pid_t ret = wait(&status);<br>    //如果等待成功<br>    if(ret>0)<br>    {<br>        printf("等待成功！\n");<br>        if(WIFEXITED(status))<br>        {<br>            //退出正常<br>            printf("exit code:%d\n",WEXITSTATUS(status));<br>        }<br>        else<br>        {<br>            printf("exit signal:%d\n",status&0x7f);<br>        }<br>    }<br>    sleep(5);<br>    return 0;<br>}<br></code></pre> <br><p> 子进程正常退出，父进程等待子进程退出后获取退出信息，没有出现僵尸。</p> <br><p><img alt="" height="209" src="https://i-blog.csdnimg.cn/direct/fe620805c8cd492bbd2c673fe0898426.png" width="440" /> <img alt="" height="319" src="https://i-blog.csdnimg.cn/direct/68df940f240446b68ed4f737b69e9bed.png" width="1200" /></p> <br><p>我们用<em>kiil -9</em>杀死父进程也能回收退出信息 </p> <br><p><img alt="" height="40" src="https://i-blog.csdnimg.cn/direct/5e6535b3898045a4998e35efe7cf3fdf.png" width="274" /> </p> <br><p> <img alt="" height="106" src="https://i-blog.csdnimg.cn/direct/87a25e51653149bdbc8874505dab5a40.png" width="464" /></p> <br><h4><span style="color:#1f2329;">waitpid</span></h4> <br><pre><code class="language-cpp">pid_ t waitpid(pid_t pid, int *status, int options);<br>// 返回值：<br>//     当正常返回的时候waitpid返回收集到的子进程的进程ID；<br>//     如果设置了选项WNOHANG,⽽调⽤中waitpid发现没有已退出的子进程可收集,则返回0；<br>//     如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；<br>// 参数：<br>//     pid：<br>//         Pid = -1,等待任意一个子进程。与wait等效。<br>//         Pid > 0.等待其进程ID与pid相等的子进程。<br>//     status: 输出型参数<br>//         WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。<br>//                             （查看进程是否是正常退出）<br>//         WEXITSTATUS(status): 若WIFEXITED⾮零，提取⼦进程退出码。<br>//                             （查看进程的退出码）<br>//     options:默认为0，表示阻塞等待<br>// <br>//     WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。<br>//              若正常结束，则返回该子进程的ID。（非阻塞）</code></pre> <br><ul><li><span style="color:#646a73;">如果⼦进程已经退出，调⽤<em>wait</em>/<em>waitpid</em>时，<em>wait</em>/<em>waitpid</em>会⽴即返回，并且释放资源，获得⼦ </span><span style="color:#646a73;">进程退出信息。 </span></li><li><span style="color:#646a73;">如果在任意时刻调⽤<em>wait</em>/<em>waitpid</em>，⼦进程存在且正常运⾏，则进程可能阻塞。 </span></li><li><span style="color:#646a73;">如果不存在该⼦进程，则⽴即出错返回。</span> </li></ul> <br><p>下面的代码创建子进程后，父进程可使用<em>waitpid</em>函数一直等待子进程（此时将<em>waitpid</em>的第三个参数设置为0），直到子进程退出后读取子进程的退出信息。 </p> <br><pre><code class="language-cpp">#include <stdio.h><br>#include <stdlib.h><br>#include <unistd.h><br>#include <sys/wait.h><br>#include <sys/types.h><br>int main()<br>{<br>	pid_t id = fork();<br>	if (id == 0){<br>		//child          <br>		int count = 10;<br>		while (count--){<br>            printf("我是子进程，pid:%d，ppid:%d\n",getpid(),getppid());<br>			sleep(1);<br>		}<br>		exit(0);<br>	}<br>	//father           <br>	int status = 0;<br>	pid_t ret = waitpid(id, &status, 0);<br>	if (ret >= 0){<br>		//wait success                    <br>		printf("等待成功！\n");<br>		if (WIFEXITED(status)){<br>			//退出正常                                <br>			printf("exit code:%d\n", WEXITSTATUS(status));<br>		}<br>		else{                             <br>			printf("eixt siganl %d\n", status & 0x7F);<br>		}<br>	}<br>	sleep(10);<br>	return 0;<br>}<br></code></pre> <br><p> 并且我们还可以创建多个进程，父进程等待多个子进程。</p> <br><pre><code class="language-cpp">#include <stdio.h><br>#include <stdlib.h><br>#include <unistd.h><br>#include <sys/types.h><br>#include <sys/wait.h><br>int main()<br>{<br>	pid_t ids[10]={0};<br>	for (int i = 0; i < 10; i++){<br>		pid_t id = fork();<br>		if (id == 0){<br>			//child<br>			printf("child process created successfully...PID:%d\n", getpid());<br>			sleep(3);<br>			exit(i); //将子进程的退出码设置为该子进程PID在数组ids中的下标<br>		}<br>		//father<br>		ids[i] = id;<br>	}<br>	for (int i = 0; i < 10; i++){<br>		int status = 0;<br>		pid_t ret = waitpid(ids[i], &status, 0);<br>		if (ret >= 0){<br>			//wait child success<br>			printf("wait child success..PID:%d\n", ids[i]);<br>			if (WIFEXITED(status)){<br>				//exit normal<br>				printf("exit code:%d\n", WEXITSTATUS(status));<br>			}<br>			else{<br>				//signal killed<br>				printf("exit signal %d\n", status & 0x7F);<br>			}<br>		}<br>	}<br>	return 0;<br>}<br></code></pre> <br><p><img alt="" height="804" src="https://i-blog.csdnimg.cn/direct/2fe5cd900b9148b3924ad608fbdd3413.png" width="605" /></p> <br><h3>非阻塞轮询 </h3> <br><p>在传统的父子进程关系中，当子进程未退出时，父进程通常处于阻塞等待状态，在此期间父进程不能进行其他操作。</p> <br><p>然而，我们可以采用非阻塞等待的方式。具体做法是在调用<em>waitpid</em>函数时，向第三个参数<em>options</em>传入<em>WNOHANG（不要夯住）</em>。这样，如果等待的子进程没有结束，<em>waitpid</em>函数将直接返回 <em>0</em>，父进程不进行等待，可以去做自己的事情。而当等待的子进程正常结束时，<em>waitpid</em>函数会返回该子进程的<em>pid</em>，此时父进程可以读取子进程的退出信息。</p> <br><p> </p> <br><pre><code class="language-cpp">#include <stdio.h><br>#include <stdlib.h><br>#include <unistd.h><br>#include <sys/types.h><br>#include <sys/wait.h><br>int main()<br>{<br>    pid_t id=fork();//创建子进程<br>    if(id==0)<br>    {<br>        //child<br>        int count=3;<br>        while(count--)<br>        {<br>            printf("child do something\n");<br>            sleep(3);<br>        }<br>        exit(0);<br>    }<br>    //father<br>    while(1)<br>    {<br>        int status=0;<br>        pid_t ret=waitpid(id,&status,WNOHANG);<br>        if(ret>0)<br>        {<br>            printf("wait success\n");<br>            printf("exit code:%d\n",WEXITSTATUS(status));<br>            break;<br>        }<br>        else if(ret==0)<br>        {<br>            printf("father do other things\n");<br>            sleep(1);<br>        }<br>        else<br>        {<br>            //wait error<br>            break;<br>        }<br>    }<br>    return 0;<br>}<br></code></pre> <br><p><img alt="" height="365" src="https://i-blog.csdnimg.cn/direct/9286a8de1a2b4e0a8a344916b106d6ba.png" width="353" /> </p> <br><h2>进程替换 </h2> <br><h3>概念 </h3> <br><p>我们前面知道，父子进程是共享代码与数据的，如果修改子进程的数据就会发生写实拷贝。而今天我们需要修改子进程的代码，则需要进行进程替换。</p> <br><p>当进程替换时，该进程的用户空间代码和数据完全被新程序替换，并从新程序的启动例程开始执行。</p> <br><p><img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/4e68a9933a844b63b6c0d98ea9103c58.png" width="1200" /></p> <br><p>如果父子进程共享数据与代码，当对子进程进行进程替换时就会发生写实拷贝，所以对子进程就行进程替换并不会影响父进程。 </p> <br><h3>进程替换函数 </h3> <br><p>以下六个函数可以进行进程替换 </p> <br><p><img alt="" height="384" src="https://i-blog.csdnimg.cn/direct/7a7b346a05ec447dab9d0c891ecb69f1.png" width="875" /></p> <br><p> 如果替换失败函数返回 -1 ，替换成功什么也不返回，如果要返回，那返回给谁呢？源程序的代码都被替换了。</p> <br><p><span style="color:#be191c;"><strong>命名理解 </strong></span></p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td><span style="color:#646a73;">l(list)</span></td><td><span style="color:#646a73;">表示参数采⽤列表</span></td></tr><tr><td><span style="color:#646a73;">v(vector)</span></td><td><span style="color:#646a73;">参数⽤数组</span></td></tr><tr><td><span style="color:#646a73;">p(path) </span></td><td><span style="color:#646a73;">有p⾃动搜索环境变量PATH</span></td></tr><tr><td><span style="color:#646a73;">e(env)</span></td><td><span style="color:#646a73;">表示⾃⼰维护环境变量</span></td></tr></tbody></table> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>函数名</td><td>参数格式</td><td>是否带路径</td><td>是否使用当前环境变量</td></tr><tr><td>execl</td><td>列表</td><td>不是</td><td>是</td></tr><tr><td>execlp</td><td>列表</td><td>是</td><td>是</td></tr><tr><td>execle</td><td>列表</td><td>不是</td><td>不是，自己组装环境变量</td></tr><tr><td>execv</td><td>数组</td><td>不是</td><td>是</td></tr><tr><td>execvp</td><td>数组</td><td>是</td><td>是</td></tr><tr><td>execvpe</td><td>数组</td><td>是</td><td>不是，自己组装环境变量</td></tr></tbody></table> <br><h4> execl举例：</h4> <br><ul><li><em>path</em>是要执行程序的路径，<em>arg</em>是可变参数列表，表示你要如何执行这个程序, 注意以<em>NULL</em>为参数传递的结尾。 </li></ul> <br><pre><code class="language-cpp">#include <stdio.h><br>#include <unistd.h><br>#include <stdlib.h><br>#include <sys/wait.h><br>#include <sys/types.h><br>int main() <br>{<br>    pid_t id = fork();<br>    if (id < 0) <br>    {<br>        perror("fork failed");<br>        return 1;<br>    } <br>    else if (id == 0) <br>    {<br>        // child<br>        if (execl("/usr/bin/ls","ls","-l","-a", NULL) == -1) <br>        {<br>            perror("execl failed");<br>            exit(-1);<br>        }<br>    } <br>    else <br>    {<br>        // father<br>        int status;<br>        pid_t ret = waitpid(id, &status, 0);<br>        if (ret < 0) {<br>            perror("waitpid failed");<br>            return 1;<br>        }<br>        if (WIFEXITED(status)) {<br>            printf("wait success\n");<br>            printf("exit code：%d\n", WEXITSTATUS(status));<br>        }<br>    }<br>    return 0;<br>}</code></pre> <br><p> <img alt="" height="208" src="https://i-blog.csdnimg.cn/direct/4c7664760a6d479383923c633e8e150e.png" width="604" /></p> <br><p>并且我们也可能通过该接口，调用其他语言的脚本，如python，shell脚本。</p> <br><h4>execle举例</h4> <br><ul><li><em>int execle(const char *path, const char *arg, …, char *const envp[]); </em></li><li><em>path</em>是要执行程序的路径，<em>arg</em>是可变参数列表，表示你要如何执行这个程序, 注意以<em>NULL</em>为参数传递的结尾，envp是你自己设置的环境变量</li></ul> <br><p>例如，你设置了<em>MYVAL</em>环境变量，在<em>MYCMD</em>程序内部就可以使用该环境变量 </p> <br><pre><code class="language-cpp">char* myenvp[] = { "MYVAL=2021", NULL };<br>execle("./mycmd", "mycmd", NULL, myenvp);//执行./mycmd<br></code></pre> <br><h4>execv举例</h4> <br><ul><li><em>int execv(const char *path, char *const argv[]); </em></li><li><em>path</em>是要执行程序的路径，<em>argv</em>是一个指针数组，数组当中的内容表示你要如何执行这个程序，数组以<em>NULL</em>结尾 </li></ul> <br><pre><code class="language-cpp">char* myargv[] = { "ls", "-a", "-i", "-l", NULL };<br>execv("/usr/bin/ls", myargv);//执行ls -a -i -l<br></code></pre> <br><p> 事实上，在系统调用中，只有<em>execve</em>才是真正的系统调用，其他五个函数（如<em>execl、execle、execlp、execv、execvp</em>）都是对<em>execve</em>函数的封装，目的是为了满足不同用户的需求。<span style="color:#b95514;">这也导致了在<em>man</em>手册中，<em>execve</em>位于第 2 节，而其他五个函数在第 3 节。</span></p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>