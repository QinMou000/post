<blockquote> <br> <p><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/9e66b67c73ef431f887a88a78f972ea7.png" width="1024" /></p> <br> <p style="text-align:center;"></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>继承的概念</h2> <br><p>继承(inheritance)机制是⾯向对象程序设计使代码可以复⽤的最重要的⼿段，它允许我们在保持原有类特性的基础上进⾏扩展，增加⽅法(成员函数)和属性(成员变量)，这样产⽣新的类，称派⽣类。继承呈现了⾯向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的函数层次的复⽤，继承是类设计层次的复⽤。</p> <br><p>没有继承之前我们设计了两个类<u><strong>Student和Teacher</strong></u>，Student和Teacher都有姓名/地址/ 电话/年龄等成员变量，都有identity⾝份认证的成员函数，<span style="color:#be191c;"><strong>设计到两个类⾥⾯就是冗余的</strong></span>。当然他们也有⼀些不同的成员变量和函数，⽐如⽼师独有成员变量是职称，学⽣的独有成员变量是学号；学⽣的独有成员函数是学习，⽼师的独有成员函数是授课。</p> <br><p>下⾯我们公共的成员都放到Person类中，Student和teacher都继承Person，就可以复⽤这些成员，就 不需要重复定义了，省去了很多⿇烦</p> <br><pre><code class="language-cpp">class person<br>{<br>public:<br>	// 进⼊校园/图书馆/实验室刷⼆维码等⾝份认证<br>	void identity()<br>	{<br>		cout << "void identity()" << _name << endl;<br>	}<br>protected:<br>	string _name = "张三"; // 姓名<br>	int _age = 18; // 年龄<br>	string _address; // 地址<br>	string _tel; // 电话<br>};<br><br>class Student :public person<br>{<br>public:<br>	// 学习<br>	void study()<br>	{<br>		// ...<br>	}<br>protected:<br>	int _stuid; // 学号<br>};<br>class Teacher :public person<br>{<br>public:<br>	// 授课<br>	void teaching()<br>	{<br>		//...<br>	}<br>protected:<br>	string _title; // 职称<br>};<br>int main()<br>{<br>	Student s;<br>	Teacher t;<br>	s.identity();<br>	t.identity();<br><br>	return 0;<br>}</code></pre> <br><h2>继承定义</h2> <br><h3>定义格式</h3> <br><p>下⾯我们看到Person是基类，也称作⽗类。Student是派⽣类，也称作⼦类。(因为翻译的原因，所以 既叫基类/派⽣类，也叫⽗类/⼦类)</p> <br><p><img alt="" height="411" src="https://i-blog.csdnimg.cn/direct/b3e49c7fc44a4fdd8bd5fd341a4fd7f8.png" width="784" /></p> <br><p> <img alt="" height="472" src="https://i-blog.csdnimg.cn/direct/bddf5b3a1f2b478cbbfcf6aaa6cdae31.png" width="1200" /></p> <br><h3>继承基类成员访问方式的变化</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td>类成员/继承方式</td><td>public继承</td><td>protected继承</td><td>private继承</td></tr><tr><td>基类的public成员</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的protected成员</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的private成员</td><td>在派生类中不可见</td><td>在派生类中不可见</td><td>在派生类中不可见</td></tr></tbody></table> <br><blockquote> <br> <p>1. 基类private成员在派⽣类中⽆论以什么⽅式继承都是不可⻅的。这⾥的不可⻅是指基类的私有成员还是被继承到了派⽣类对象中，但是语法上限制派⽣类对象不管在类⾥⾯还是类外⾯都不能去访问它。</p> <br> <p>2. 基类private成员在派⽣类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派⽣类中能访问，就定义为protected。可以看出<span style="color:#be191c;"><strong>保护成员限定符是因继承才出现的。</strong></span></p> <br> <p>3. 实际上⾯的表格我们进⾏⼀下总结会发现，基类的私有成员在派⽣类都是不可⻅。基类的其他成员在派⽣类的访问⽅式 == Min(成员在基类的访问限定符，继承⽅式)，public > protected > private。</p> <br> <p>4. 使⽤关键字class时默认的继承⽅式是private，使⽤struct时默认的继承⽅式是public，不过最好显示的写出继承⽅式。</p> <br> <p>5. 在实际运⽤中⼀般使⽤都是public继承，⼏乎很少使⽤protetced/private继承，也不提倡使⽤ protetced/private继承，因为protetced/private继承下来的成员都只能在派⽣类的类⾥⾯使⽤，实际中扩展维护性不强。 </p> <br></blockquote> <br><h3>继承类模板 </h3> <br><pre><code class="language-cpp">// stack和vector的关系，既符合is-a，也符合has-a<br>template<class T><br>class stack : public std::vector<T><br>{<br>public:<br>	void push(const T& x)<br>	{<br>		// 基类是类模板时，需要指定⼀下类域，<br>		// 否则编译报错:error C3861: “push_back”: 找不到标识符<br><br>		// 因为stack<int>实例化时，也实例化vector<int>了<br>		// 但是模版是按需实例化，push_back等成员函数未实例化，所以找不到<br>		vector<T>::push_back(x);<br>		//push_back(x);<br>	}<br>};</code></pre> <br><h2>基类和派⽣类间的转换 </h2> <br><p> • public继承的派⽣类对象<span style="color:#be191c;"><strong>可以赋值给基类的指针 / 基类的引⽤</strong></span>。这⾥有个形象的说法叫切⽚或者切割。寓意把派⽣类中基类那部分切出来，基类指针或引⽤指向的是派⽣类中切出来的基类那部分。</p> <br><p>• 基类对象不能赋值给派⽣类对象。</p> <br><p>• 基类的指针或者引⽤可以通过强制类型转换赋值给派⽣类的指针或者引⽤。但是必须是基类的指针是指向派⽣类对象时才是安全的。这⾥基类如果是多态类型，可以使⽤RTTI(Run-Time Type Information)的dynamic_cast 来进⾏识别后进⾏安全转换。（ps：这个我们后⾯类型转换章节再 单独专⻔讲解，这⾥先提⼀下）</p> <br><p><img alt="" height="298" src="https://i-blog.csdnimg.cn/direct/0524234e0f6743d28f4b4c6246c590d1.png" width="793" /></p> <br><pre><code class="language-cpp">class Person<br>{<br>protected:<br>	string _name; // 姓名<br>	string _sex; // 性别<br>	int _age; // 年龄<br>};<br>class Student : public Person<br>{<br>public:<br>	int _No; // 学号<br>};<br>int main()<br>{<br>	Student sobj;<br>	// 1.派⽣类对象可以赋值给基类的指针/引⽤<br>	Person* pp = &sobj;<br>	Person& rp = sobj;<br>	// ⽣类对象可以赋值给基类的对象是通过调⽤后⾯会讲解的基类的拷⻉构造完成的<br>	Person pobj = sobj;<br>	//2.基类对象不能赋值给派⽣类对象，这⾥会编译报错<br>	sobj = pobj;<br>	return 0;<br>}</code></pre> <br><h2> 继承中的作用域</h2> <br><p>1. 在继承体系中基类和派⽣类都有独⽴的作⽤域。</p> <br><p>2. 派⽣类和基类中有同名成员，派⽣类成员将<strong>屏蔽基类对同名成员的直接访问</strong>，这种情况叫<span style="color:#be191c;"><strong>隐藏。</strong></span> （在派⽣类成员函数中，可以使⽤基类::基类成员显示访问）</p> <br><p>3. 需要注意的是如果是成员函数的隐藏，只需要<strong>函数名相同就构成隐藏。</strong></p> <br><p>4. 注意在实际中在继承体系⾥⾯最好不要定义同名的成员。</p> <br><pre><code class="language-cpp">// Student的_num和Person的_num构成隐藏关系，可以看出这样代码虽然能跑，但是⾮常容易混淆<br>class Person<br>{<br>protected:<br>	string _name = "⼩李⼦"; // 姓名<br>	int _num = 111; // ⾝份证号<br>};<br>class Student : public Person<br>{<br>public:<br>	void Print()<br>	{<br>		cout << " 姓名:" << _name << endl;<br>		cout << " ⾝份证号:" << Person::_num << endl;<br>		cout << " 学号:" << _num << endl;<br>	}<br>protected:<br>	int _num = 999; // 学号<br>};<br>int main()<br>{<br>	Student s1;<br>	s1.Print();<br>	return 0;<br>};</code></pre> <br><p>来做两道题： </p> <br><p>（1）A和B类中的两个func构成什么关系（） A. 重载 B. 隐藏 C.没关系</p> <br><p>（2）下⾯程序的编译运⾏结果是什么（） A. 编译报错 B. 运⾏报错 C. 正常运⾏ </p> <br><pre><code class="language-cpp">class A<br>{<br>public:<br>	void fun()<br>	{<br>		cout << "func()" << endl;<br>	}<br>};<br>class B : public A<br>{<br>public:<br>	void fun(int i)<br>	{<br>		cout << "func(int i)" << i << endl;<br>	}<br>};<br>int main()<br>{<br>	B b;<br>	b.fun(10);<br>	b.fun();<br>	return 0;<br>};</code></pre> <br><p>解析：</p> <br><p>（1）子类父类成员函数名相同构成隐藏。</p> <br><p>（2）在不指定域的情况下A中的fun函数被隐藏是调不到A中的fun函数的所以fun（）缺少，参数编译报错。（error C2660: “B::fun”: 函数不接受 0 个参数）</p> <br><h2>派生类的四个常见的默认成员函数</h2> <br><p>6个默认成员函数<a href="https://blog.csdn.net/2301_80194476/article/details/140407660?spm=1001.2014.3001.5501" title="（C++初阶：类和对象（二）-CSDN博客）">（C++初阶：类和对象（二）-CSDN博客）</a>，默认的意思就是指我们不写，编译器会变我们⾃动⽣成⼀个，那么在派⽣类中，这⼏个成员函数是如何⽣成的呢？<img alt="" height="790" src="https://i-blog.csdnimg.cn/direct/c4bf321a58fd45b9aa372ecb00e9e732.png" width="1200" /></p> <br><p>1. 派⽣类的构造函数<span style="color:#be191c;"><strong>必须调⽤基类的构造函数</strong></span>初始化基类的那⼀部分成员。如果基类没有默认的构造函数，则必须在派⽣类构造函数的<span style="color:#be191c;"><strong>初始化列表阶段显⽰调⽤。</strong></span></p> <br><p>2. 派⽣类的拷⻉构造函数<span style="color:#be191c;"><strong>必须调⽤基类的拷⻉构造</strong></span>完成基类的拷⻉初始化。</p> <br><p>3. 派⽣类的operator=必须要调<span style="color:#be191c;"><strong>⽤基类的operator=</strong></span>完成基类的复制。需要注意的是派⽣类的 operator=<span style="color:#ff9900;"><strong>隐藏</strong></span>了基类的operator=，所以显⽰调⽤基类的operator=，需要<span style="color:#be191c;"><strong>指定基类作⽤域</strong></span></p> <br><p>4. 派⽣类的析构函数会在被调⽤完成后<span style="color:#be191c;"><strong>⾃动调⽤</strong></span>基类的析构函数清理基类成员。因为这样才能保证派⽣类对象先清理派⽣类成员再清理基类成员的顺序。</p> <br><p>5. 派⽣类对象初始化先调⽤基类构造再调派⽣类构造。</p> <br><p>6. 派⽣类对象析构清理先调⽤派⽣类析构再调基类的析构。</p> <br><p>7. 因为多态中⼀些场景析构函数需要构成重写，重写的条件之⼀是函数名相同(这个在后续的多态章节会详细说明)。那么编译器会对析构函数名进⾏特殊处理，处理成destructor()，所以基类析构函数不加virtual的情况下，派⽣类析构函数和基类析构函数构成隐藏关系。</p> <br><p> <img alt="" height="623" src="https://i-blog.csdnimg.cn/direct/b1f06f58c0614ceba687c28012a99985.png" width="1015" /></p> <br><pre><code class="language-cpp">class Person<br>{<br>public:<br>	Person(const char* name = "peter")<br>		: _name(name)<br>	{<br>		cout << "Person()" << endl;<br>	}<br>	Person(const Person& p)<br>		: _name(p._name)<br>	{<br>		cout << "Person(const Person& p)" << endl;<br>	}<br>	Person& operator=(const Person& p)<br>	{<br>		cout << "Person operator=(const Person& p)" << endl;<br>		if (this != &p)<br>			_name = p._name;<br>		return *this;<br>	}<br>	~Person()<br>	{<br>		cout << "~Person()" << endl;<br>	}<br>protected:<br>	string _name; // 姓名<br>};<br>class Student : public Person<br>{<br>public:<br>	Student(const char* name, int num)<br>		: Person(name)<br>		, _num(num)<br>	{<br>		cout << "Student()" << endl;<br>	}<br>	Student(const Student& s)<br>		: Person(s)<br>		, _num(s._num)<br>	{<br>		cout << "Student(const Student& s)" << endl;<br>	}<br>	Student& operator = (const Student& s)<br>	{<br>		cout << "Student& operator= (const Student& s)" << endl;<br>		if (this != &s)<br>		{<br>			// 构成隐藏，所以需要显⽰调⽤<br>			Person::operator =(s);<br>			_num = s._num;<br>		}<br>		return *this;<br>	}<br>	~Student()<br>	{<br>		cout << "~Student()" << endl;<br>	}<br>protected:<br>	int _num; //学号<br>};<br>int main()<br>{<br>	Student s1("jack", 18);<br>	Student s2(s1);<br>	Student s3("rose", 17);<br>	s1 = s3;<br>	return 0;<br>}</code></pre> <br><h2> 实现一个不能被继承的类</h2> <br><p>⽅法1：<strong><span style="color:#be191c;">基类的构造函数私有</span></strong>，派⽣类的构成必须调⽤基类的构造函数，但是基类的构成函数私有化以 后，派⽣类看不⻅就不能调⽤了，那么派⽣类就⽆法实例化出对象。</p> <br><p>⽅法2：C++11新增了⼀个<span style="color:#be191c;"><strong>final关键字</strong></span>，final修改基类，派⽣类就不能继承了。</p> <br><pre><code class="language-cpp">// C++11的⽅法<br>class Base final<br>{<br>public:<br>	void func5() { cout << "Base::func5" << endl; }<br>protected:<br>	int a = 1;<br>private:<br>	// C++98的⽅法<br>	/*Base()<br>	{}*/<br>};<br><br>class Derive :public Base<br>{<br>	void func4() { cout << "Derive::func4" << endl; }<br>protected:<br>	int b = 2;<br>};<br>int main()<br>{<br>	Base b;<br>	Derive d;<br>	return 0;<br>}</code></pre> <br><h2>继承与友元</h2> <br><p>友元关系不能继承，也就是说基类友元不能访问派⽣类私有和保护成员 。</p> <br><pre><code class="language-cpp">class Student;<br>class Person<br>{<br>public:<br>	friend void Display(const Person& p, const Student& s);<br>protected:<br>	string _name; // 姓名<br>};<br>class Student : public Person<br>{<br>protected:<br>	int _stuNum; // 学号<br>};<br>void Display(const Person& p, const Student& s)<br>{<br>	cout << p._name << endl;<br>	cout << s._stuNum << endl;<br>}<br>int main()<br>{<br>	Person p;<br>	Student s;<br>	// 编译报错：error C2248: “Student::_stuNum”: ⽆法访问 protected 成员<br>	// 解决⽅案：Display也变成Student 的友元即可<br>	Display(p, s);<br>	return 0;<br>}</code></pre> <br><h2>继承与静态成员</h2> <br><blockquote> <br> <p>基类定义了static静态成员，则整个继承体系⾥⾯只有⼀个这样的成员。⽆论派⽣出多少个派⽣类，都只有⼀个static成员实例。</p> <br></blockquote> <br><pre><code class="language-cpp">class Person<br>{<br>public:<br>	string _name;<br>	static int _count;<br>};<br>int Person::_count = 0;<br>class Student : public Person<br>{<br>protected:<br>	int _stuNum;<br>};<br>int main()<br>{<br>	Person p;<br>	Student s;<br>	// 这⾥的运⾏结果可以看到⾮静态成员_name的地址是不⼀样的<br>	// 说明派⽣类继承下来了，⽗派⽣类对象各有⼀份<br>	cout << &p._name << endl;<br>	cout << &s._name << endl;<br>	// 这⾥的运⾏结果可以看到静态成员_count的地址是⼀样的<br>	// 说明派⽣类和基类共⽤同⼀份静态成员<br>	cout << &p._count << endl;<br>	cout << &s._count << endl;<br>	// 公有的情况下，⽗派⽣类指定类域都可以访问静态成员<br>	cout << Person::_count << endl;<br>	cout << Student::_count << endl;<br>	return 0;<br>}</code></pre> <br><h2> 多继承及其菱形继承问题</h2> <br><h3>继承模型</h3> <br><p>单继承：⼀个派⽣类只有⼀个直接基类时称这个继承关系为单继承</p> <br><p>多继承：⼀个派⽣类有两个或以上直接基类时称这个继承关系为多继承，多继承对象在内存中的模型是，先继承的基类在前⾯，后⾯继承的基类在后⾯，派⽣类成员在放到最后⾯。</p> <br><p>菱形继承：菱形继承是多继承的⼀种特殊情况。菱形继承的问题，从下⾯的对象成员模型构造，可以看出菱形继承有数据冗余和⼆义性的问题，在Assistant的对象中Person成员会有两份。⽀持多继承就 ⼀定会有菱形继承，像Java就直接不⽀持多继承，规避掉了这⾥的问题，所以实践中我们也是不建议设计出菱形继承这样的模型的。 </p> <br><p><img alt="" height="396" src="https://i-blog.csdnimg.cn/direct/e8b8ffd8937b4815b12eef2830d92d42.png" width="1200" /></p> <br><p><img alt="" height="501" src="https://i-blog.csdnimg.cn/direct/d55b2e47a36f40f9a0770ad38cacf0b4.png" width="1200" /></p> <br><pre><code class="language-cpp">class Person<br>{<br>public:<br>	string _name; // 姓名<br>};<br>class Student : public Person<br>{<br>protected:<br>	int _num; //学号<br>};<br>class Teacher : public Person<br>{<br>protected:<br>	int _id; // 职⼯编号<br>};<br>class Assistant : public Student, public Teacher<br>{<br>protected:<br>	string _majorCourse; // 主修课程<br>};<br>int main()<br>{<br>	// 编译报错：error C2385: 对“_name”的访问不明确<br>	Assistant a;<br>	a._name = "peter";<br>	// 需要显⽰指定访问哪个基类的成员可以解决⼆义性问题，但是数据冗余问题⽆法解决<br>	a.Student::_name = "xxx";<br>	a.Teacher::_name = "yyy";<br>	return 0;<br>}</code></pre> <br><h2> 虚继承</h2> <br><p>有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，<span style="color:#be191c;"><strong>底层实现就很复杂</strong></span>，性能也会有⼀些损失，所以最好不要设计出菱形继承。</p> <br><pre><code class="language-cpp">class Person<br>{<br>public:<br>	string _name; // 姓名<br>	/*int _tel;<br>	 int _age;<br>	string _gender;<br>	string _address;*/<br>	// ...<br>};<br>// 使⽤虚继承Person类<br>class Student : virtual public Person<br>{<br>protected:<br>	int _num; //学号<br>};<br>// 使⽤虚继承Person类<br>class Teacher : virtual public Person<br>{<br>protected:<br>	int _id; // 职⼯编号<br>};<br>// 教授助理<br>class Assistant : public Student, public Teacher<br>{<br>protected:<br>	string _majorCourse; // 主修课程<br>};<br>int main()<br>{<br>	// 使⽤虚继承，可以解决数据冗余和⼆义性<br>	Assistant a;<br>	a._name = "peter";<br>	return 0;<br>}<br></code></pre> <br><p>多继承中指针偏移问题？下⾯说法正确的是( )</p> <br><p>A：p1 == p2 == p3 B：p1 < p2 < p3 C：p1 == p3 != p2 D：p1 != p2 != p3</p> <br><pre><code class="language-cpp">class Base1 { public: int _b1; };<br>class Base2 { public: int _b2; };<br>class Derive : public Base1, public Base2 { public: int _d; };<br>int main()<br>{<br>    Derive d;<br>    Base1* p1 = &d;<br>    Base2* p2 = &d;<br>    Derive* p3 = &d;<br>    return 0;<br>}<br></code></pre> <br><p><img alt="" height="554" src="https://i-blog.csdnimg.cn/direct/1e38288b79ab47e1b3e706ee713c230d.png" width="1176" /></p> <br><h2>继承与组合 </h2> <br><p>• public继承是⼀种is-a的关系。也就是说每个派⽣类对象都是⼀个基类对象。</p> <br><p>• 组合是⼀种has-a的关系。假设B组合了A，每个B对象中都有⼀个A对象。</p> <br><p>• 继承允许你根据基类的实现来定义派⽣类的实现。这种通过⽣成派⽣类的复⽤通常被称为⽩箱复⽤ (white-box reuse)。术语“⽩箱”是相对可视性⽽⾔：在继承⽅式中，基类的内部细节对派⽣类可 ⻅ 。继承⼀定程度破坏了基类的封装，基类的改变，对派⽣类有很⼤的影响。派⽣类和基类间的依赖关系很强，耦合度⾼。</p> <br><p>• 对象组合是类继承之外的另⼀种复⽤选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接⼝。这种复⽤⻛格被称为⿊箱复⽤(black-box reuse)， 因为对象的内部细节是不可⻅的。对象只以“⿊箱”的形式出现。 组合类之间没有很强的依赖关系，耦合度低。优先使⽤对象组合有助于你保持每个类被封装。</p> <br><p>• <span style="color:#be191c;"><strong>优先使⽤组合，⽽不是继承。实际尽量多去⽤组合，组合的耦合度低，代码维护性好。</strong></span>不过也不太那么绝对，类之间的关系就适合继承(is-a)那就⽤继承，另外要实现多态，也必须要继承。类之间的关系既适合⽤继承(is-a)也适合组合(has-a)，就⽤组合。</p> <br><pre><code class="language-cpp">class Tire {<br>protected:<br>	string _brand = "Michelin"; // 品牌<br>	size_t _size = 17; // 尺⼨<br>};<br>class Car {<br>protected:<br>	string _colour = "⽩⾊"; // 颜⾊<br>	string _num = "陕ABIT00"; // ⻋牌号<br>	Tire _t1; // 轮胎<br>	Tire _t2; // 轮胎<br>	Tire _t3; // 轮胎<br>	Tire _t4; // 轮胎<br>};<br>class BMW : public Car {<br>public:<br>	void Drive() { cout << "好开-操控" << endl; }<br>};<br>// Car和BMW/Benz更符合is-a的关系<br>class Benz : public Car {<br>public:<br>	void Drive() { cout << "好坐-舒适" << endl; }<br>};<br>template<class T><br>class vector<br>{};<br>// stack和vector的关系，既符合is-a，也符合has-a<br>template<class T><br>class stack : public vector<T><br>{};<br>template<class T><br>class stack<br>{<br>public:<br>	vector<T> _v;<br>};<br>int main()<br>{<br>	return 0;<br>}</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>