<blockquote> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/a1e2fd8531ae4fbab004f1ecd1a2c8b1.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><p><strong><span style="color:#be191c;">  学习STL要多看文档<a href="https://legacy.cplusplus.com/reference/vector/vector/?kw=vector" rel="nofollow" title="vector - C++ Reference (cplusplus.com)">vector - C++ Reference (cplusplus.com)</a> </span></strong></p> <br><h2> vector的介绍</h2> <br><p>vector和我们之前学的顺序表的结构是差不多的，用一个动态开辟的数组来储存管理数据。vector的底层和顺序表有点区别。（后续会讲到）</p> <br><h2> vector的使用 </h2> <br><h3>构造函数</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>constructor<strong>构造函数声明</strong></td><td>接口说明</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/?kw=vector" rel="nofollow" title="vector">vector</a>()（重点）</td><td>无参构造</td></tr><tr><td> <p>vector(size_t n , const value_type& val =</p> <p>value_type())</p> </td><td>构造并初始化n个val</td></tr><tr><td>vector(const vector& v)（重点）</td><td>拷贝构造</td></tr><tr><td>vector(iterator first , iterator last)</td><td>使用迭代器的初始化构造</td></tr></tbody></table> <br><h3>迭代器</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/begin/" rel="nofollow" title="begin()">begin()</a></td><td>获取第一个数据位置的iterator/const_iterator</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/end/" rel="nofollow" title="end()">end()</a></td><td>获取最后一个数据的下一个位置的iterator/const_iterator</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/rbegin/" rel="nofollow" title="rbegin()">rbegin()</a></td><td>获取最后一个数据位置的reverse_iterator</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/rend/" rel="nofollow" title="rend()">rend()</a></td><td>获取第一个数据前一个位置 的reverse_iterator</td></tr></tbody></table> <br><p><img alt="" height="244" src="https://i-blog.csdnimg.cn/direct/7100d4a3c4864d0aa3be49e8035222f5.png" width="873" /></p> <br><h3> 空间管理</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/size/" rel="nofollow" title="size()">size()</a></td><td>获取数据个数</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/capacity/" rel="nofollow" title="capacity()">capacity()</a></td><td>获取容量大小</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/empty/" rel="nofollow" title="empty()">empty()</a></td><td>判断是否为空</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/resize/" rel="nofollow" title="resize()">resize()</a></td><td>改变vector的size</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/reserve/" rel="nofollow" title="reserve()">reserve()</a></td><td>改变vector的capacity</td></tr></tbody></table> <br><blockquote> <br> <p>（1）capacity的代码在vs和g++下分别运行会发现，vs下capacity是按1.5倍增长的，g++是按2 倍增长的。这个问题很经典，不要固化的认为，vector增容都是2倍，具体增长多少是根据具体的需求定义的。vs是PJ版本STL，g++是SGI版本STL。</p> <br> <p>（2）reserve只负责开辟空间，如果确定知道需要用多少空间，reserve可以缓解vector增容的代价缺陷问题。（多次少量扩容的效率低下）</p> <br> <p>（3）resize在开空间的同时还会进行初始化，影响size。 </p> <br></blockquote> <br><pre><code class="language-cpp">// 测试vector的默认扩容机制<br>void TestVectorExpand()<br>{<br>	size_t sz;<br>	vector<int> v;<br>	sz = v.capacity();<br>	cout << "making v grow:\n";<br>	for (int i = 0; i < 100; ++i)<br>	{<br>		v.push_back(i);<br>		if (sz != v.capacity())<br>		{<br>			sz = v.capacity();<br>			cout << "capacity changed: " << sz << '\n';<br>		}<br>	}<br>}</code></pre> <br><figure class="image"> <br> <img alt="" height="482" src="https://i-blog.csdnimg.cn/direct/4522c3e4cbab47e29d2a448fa6e3b317.png" width="996" /> <br> <figcaption><br>   环境：WIN11 VS2022 <br> </figcaption> <br></figure> <br><h3>增删查改</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/push_back/" rel="nofollow" title="push_back()">push_back()</a></td><td>尾插</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/pop_back/" rel="nofollow" title="pop_back()">pop_back()</a></td><td>尾删</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/insert/" rel="nofollow" title="insert()">insert()</a></td><td>在pos位置之前插入val</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/erase/" rel="nofollow" title="erase()">erase()</a></td><td> <p>删除pos位置的数据</p> </td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/swap/" rel="nofollow" title="swap()">swap()</a></td><td>交换两个vector的数据空间</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/vector/vector/operator%5B%5D/" rel="nofollow" title="operator[]">operator[]</a></td><td>像数组一样下标访问（随机访问）</td></tr><tr><td><a href="https://legacy.cplusplus.com/reference/algorithm/find/?kw=find" rel="nofollow" title="find()">find()</a></td><td>查找（属于算法库不是vector内部接口）</td></tr></tbody></table> <br><h2>迭代器失效</h2> <br><blockquote> <br> <p>迭代器的主要作用就是让算法能够不用关心底层数据结构，其底层实际就是一个指针，或者是对 指针进行了封装，比如：vector的迭代器就是原生态指针T* 。因此迭代器失效，实际就是迭代器 底层对应指针所指向的空间被销毁了，而使用一块已经被释放的空间，造成的后果是程序崩溃。</p> <br></blockquote> <br><p> （1）会引起其底层空间改变的操作，都有可能是迭代器失效，比如：resize、reserve、insert、 assign、push_back等。</p> <br><pre><code class="language-cpp">#include <iostream><br>using namespace std;<br>#include <vector><br><br>int main()<br>{<br>	vector<int> v{ 1,2,3,4,5,6 };<br>	auto it = v.begin();<br>	// 将有效元素个数增加到100个，多出的位置使用8填充，操作期间底层会扩容<br>	// v.resize(100, 8);<br><br>	// reserve的作用就是改变扩容大小但不改变有效元素个数，操作期间可能会引起底层容量改变<br>	// v.reserve(100);<br>		<br>	// 插入元素期间，可能会引起扩容，而导致原空间被释放<br>	// v.insert(v.begin(), 0);<br>	// v.push_back(8);<br>	<br>	// 给vector重新赋值，可能会引起底层容量改变<br>		v.assign(100, 8);<br>	/*<br>	出错原因：以上操作，都有可能会导致vector扩容，也就是说vector底层原理旧空间被释<br>	放掉，而在打印时，it还使用的是释放之间的旧空间，在对it迭代器操作时，实际操作的是一块<br>	已经被释放的空间，而引起代码运行时崩溃。<br>	解决方式：在以上操作完成之后，如果想要继续通过迭代器操作vector中的元素，只需给<br>	it重新赋值即可。<br>	*/<br>	while (it != v.end())<br>	{<br>		cout << *it << " ";<br>		++it;<br>	}<br>	cout << endl;<br>	return 0;<br>}</code></pre> <br><p><img alt="" height="630" src="https://i-blog.csdnimg.cn/direct/3facedb93dd345fb80888faafffe08eb.png" width="1200" /></p> <br><p>（2） 指定位置元素的删除操作--erase</p> <br><pre><code class="language-cpp">#include <iostream><br>using namespace std;<br>#include <vector><br>int main()<br>{<br>	int a[] = { 1, 2, 3, 4 };<br>	vector<int> v(a, a + sizeof(a) / sizeof(int));//迭代器初始化<br>	// 使用find查找3所在位置的iterator<br>	vector<int>::iterator pos = find(v.begin(), v.end(), 3);<br>	// 删除pos位置的数据，导致pos迭代器失效。<br>	v.erase(pos);<br>	cout << *pos << endl; // 此处会导致非法访问<br>	return 0;<br>}</code></pre> <br><blockquote> <br> <p>erase删除pos位置元素后，pos位置之后的元素会往前搬移，没有导致底层空间的改变，理论上讲迭代器不应该会失效，但是：如果pos刚好是最后一个元素，删完之后pos刚好是end 的位置，而end位置是没有元素的，那么pos就失效了。因此删除vector中任意位置上元素 时，vs就认为该位置迭代器失效了。</p> <br></blockquote> <br><p><img alt="" height="714" src="https://i-blog.csdnimg.cn/direct/abb3d9c5c4814013a6ffb742c86c5f7a.png" width="1200" /></p> <br><p>（3）<span style="color:#be191c;"><strong>注意：</strong></span>Linux下g++编译器对迭代器失效的检测并不是非常严格，处理也没有vs下极端。</p> <br><pre><code class="language-cpp">// 1. 扩容之后，迭代器已经失效了，程序虽然可以运行，但是运行结果已经不对了<br>int main()<br>{<br>	vector<int> v{ 1,2,3,4,5 };<br>	for (size_t i = 0; i < v.size(); ++i)<br>		cout << v[i] << " ";<br>	cout << endl;<br>	auto it = v.begin();<br>	cout << "扩容之前，vector的容量为: " << v.capacity() << endl;<br>	// 通过reserve将底层空间设置为100，目的是为了让vector的迭代器失效<br>	v.reserve(100);<br>	cout << "扩容之后，vector的容量为: " << v.capacity() << endl;<br>	// 经过上述reserve之后，it迭代器肯定会失效，在vs下程序就直接崩溃了，但是linux下不会<br>	// 虽然可能运行，但是输出的结果是不对的<br>	while (it != v.end())<br>	{<br>		cout << *it << " ";<br>		++it;<br>	}<br>	cout << endl;<br>	return 0;<br>}<br>//程序输出：（Linux）<br>//1 2 3 4 5<br>//扩容之前，vector的容量为: 5<br>//扩容之后，vector的容量为: 100<br>//0 2 3 4 5 409 1 2 3 4 5</code></pre> <br><pre><code class="language-cpp"> //2. erase删除任意位置代码后，linux下迭代器并没有失效<br> //因为空间还是原来的空间，后序元素往前搬移了，it的位置还是有效的<br>#include <vector><br>#include <algorithm><br>int main()<br>{<br>	vector<int> v{ 1,2,3,4,5 };<br>	vector<int>::iterator it = find(v.begin(), v.end(), 3);<br>	v.erase(it);<br>	cout << *it << endl;<br>	while (it != v.end())<br>	{<br>		cout << *it << " ";<br>		++it;<br>	}<br>	cout << endl;<br>	return 0;<br>}<br>//程序可以正常运行，并打印：<br>//4<br>//4 5</code></pre> <br><pre><code class="language-cpp">// 3: erase删除的迭代器如果是最后一个元素，删除之后it已经超过end<br>// 此时迭代器是无效的，++it导致程序崩溃<br>int main()<br>{<br>	vector<int> v{ 1,2,3,4,5 };<br>	// vector<int> v{1,2,3,4,5,6};<br>	auto it = v.begin();<br>	while (it != v.end())<br>	{<br>		if (*it % 2 == 0)<br>			v.erase(it);<br>		++it;<br>	}<br>	for (auto e : v)<br>		cout << e << " ";<br>	cout << endl;<br>	return 0;<br>}<br>//========================================================<br>// 使用第一组数据时，程序可以运行<br>//[sly@VM - 0 - 3 - centos 20220114]$ g++ testVector.cpp - std = c++11<br>//[sly@VM - 0 - 3 - centos 20220114]$ . / a.out<br>//1 3 5<br>//======================================================== =<br> 使用第二组数据时，程序最终会崩溃<br>//[sly@VM - 0 - 3 - centos 20220114]$ vim testVector.cpp<br>//[sly@VM - 0 - 3 - centos 20220114]$ g++ testVector.cpp - std = c++11<br>//[sly@VM - 0 - 3 - centos 20220114]$ . / a.out<br>//Segmentation fault</code></pre> <br><p>(Linux)SGI STL中，迭代器失效后，代码并不一定会崩溃，但是运行结果肯定不对，如果it不在begin和end范围内，肯定会崩溃的。 </p> <br><p>（4）与vector类似，string在插入+扩容操作+erase之后，迭代器也会失效</p> <br><pre><code class="language-cpp">#include <string><br>void TestString()<br>{<br>	string s("hello");<br>	auto it = s.begin();<br>	// 放开注释之后代码会崩溃，因为resize到20会string会进行扩容<br>	// 扩容之后，it指向之前旧空间已经被释放了，该迭代器就失效了<br>	// 后序打印时，再访问it指向的空间程序就会崩溃<br>	//s.resize(20, '!');<br>	while (it != s.end())<br>	{<br>		cout << *it;<br>		++it;<br>	}<br>	cout << endl;<br>	it = s.begin();<br>	while (it != s.end())<br>	{<br>		it = s.erase(it);<br>		// 按照下面方式写，运行时程序会崩溃，因为erase(it)之后<br>		// it位置的迭代器就失效了<br>		// s.erase(it);<br>		++it;<br>	}<br>}<br></code></pre> <br><h2>模拟实现vector </h2> <br><p><a href="https://gitee.com/wang-qin928/c-learning/blob/master/function/vector%E7%B1%BB/vector.h" rel="nofollow" title="function/vector类/vector.h · 钦某/C++learning - 码云 - 开源中国 (gitee.com)">function/vector类/vector.h · 钦某/C++learning - 码云 - 开源中国 (gitee.com)</a></p> <br><blockquote> <br> <p>这里挑一个重点问题来思考：<strong>假设模拟实现的vector中的reserve接口中，使用memcpy进行的拷贝，以下代码会发生什么问题？</strong></p> <br> <p></p> <br> <p>1. memcpy是内存的二进制格式拷贝，将一段内存空间中内容原封不动的拷贝到另外一段内存 空间中</p> <br> <p>2. 如果拷贝的是自定义类型的元素，memcpy既高效又不会出错，但如果拷贝的是自定义类型 元素，并且自定义类型元素中涉及到资源管理时，就会出错，因为memcpy的拷贝实际是浅拷贝。</p> <br></blockquote> <br><p>那么如果对象中涉及到资源管理时，千万不能使用memcpy进行对象之间的拷贝，因为memcpy是浅拷贝，否则可能会引起内存泄漏甚至程序崩溃。</p> <br><p><u><strong>这时我们可以直接用赋值，如果是内部类型，那就直接赋值，如果是自定义类型就会调用它自己的赋值重载，它会自己开新空间并拷贝</strong></u></p> <br><pre><code class="language-cpp">void reserve(size_t n)<br>{<br>	if (n > capacity())<br>	{<br>		T* tmp = new T[n];<br>		//memcpy(tmp, _start, size() * sizeof(T));<br>		for (size_t i = 0; i < size(); i++)<br>		{<br>			tmp[i] = _start[i]// 如果victor里面是string，这个赋值调用的是string的赋值重载，它会自己开新空间<br>		}<br>		delete[] _start;<br><br>		_finish = size() + tmp;// 一定要先改finish再是start，是size()里面的finish失效的问题<br>		_start = tmp;<br>		_end_of_shorage = tmp + n;<br>	}<br>}</code></pre> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>