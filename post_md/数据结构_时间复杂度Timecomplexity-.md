<blockquote> <br> <p style="text-align:center;"><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/6f2b920cd38b273e9349974209147fee.png" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12634416.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>什么是时间复杂度？</h2> <br><p>时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。</p> <br><h2>如何计算时间复杂度？</h2> <br><p>即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。</p> <br><pre><code class="language-cpp">void func1(int n)<br>{<br>	int count = 0;<br>	for (int i = 0; i < n; i++)<br>	{<br>		for (int j = 0; j < n; j++)<br>		{<br>			count++;<br>		}<br>	}<br><br>	for (int k = 0; k < 2*n; k++)<br>	{<br>		count++;<br>	}<br><br>	int x = 10;<br>	while (x--)<br>	{<br>		count++;<br>	}<br>	printf("%d\n",count);<br>}</code></pre> <br><blockquote> <br> <p>在func1中count++执行了多少次？</p> <br> <p>答：F（n）= n^2 + 2*n +10</p> <br></blockquote> <br><p> 在上面的问题中:</p> <br><table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>N</td><td>F(N)</td></tr><tr><td>10</td><td>130</td></tr><tr><td>100</td><td>10210</td></tr><tr><td>1000</td><td>1002010</td></tr></tbody></table> <br><p>我们发现，当n越来越大，对最终结果最具有影响的项为：N^2（最高阶项）</p> <br><blockquote> <br> <p>有的同学会问：那如果n等于一个很小的数呢？（比如1，2，3……）</p> <br> <p>答：随着计算机的发展，由于计算机速度很快，当n很小的时候计算时间还不到1ms，可以忽略不计了。</p> <br></blockquote> <br><p> 我们看下面的结果：（时间单位都为ms）</p> <br><p style="text-align:center;"><img alt="" height="105" src="https://i-blog.csdnimg.cn/blog_migrate/9a1f766c2c652a9a1e4c87cabf5ea663.jpeg" width="142" /><img alt="" height="102" src="https://i-blog.csdnimg.cn/blog_migrate/82acb409e35960c74ee7fcd8ef45a8c2.png" width="149" /><img alt="" height="100" src="https://i-blog.csdnimg.cn/blog_migrate/28721e82ae64132775a7a8952960e876.png" width="146" /><img alt="" height="100" src="https://i-blog.csdnimg.cn/blog_migrate/04fe0171296bd5d2b7474fab5b8a1fdd.png" width="147" /></p> <br><p> 所以我们在计算时间复杂读度的时候，只保留对结果影响最大的一项。</p> <br><p>具体计算方法看下面的大O渐近表示法。</p> <br><h3> 大O的渐进表示法</h3> <br><p>大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。<br /> 推导大O阶方法：<br /> 1、用常数1取代运行时间中的所有加法常数。<br /> 2、在修改后的运行次数函数中，只保留最高阶项。<br /> 3、如果最高阶项存在且不是1，<strong>则去除与这个项目相乘的常数</strong>。得到的结果就是大O阶。</p> <br><blockquote> <br> <p>使用大O的渐进表示法以后，Func1的时间复杂度为：O（n）</p> <br></blockquote> <br><p> 通过上面我们会发现大O的渐进表示法去掉了那些<strong>对结果影响不大的项</strong>，简洁明了的表示出了执行次数。</p> <br><p>另外有些算法的时间复杂度存在最好、平均和最坏情况：</p> <br><blockquote> <br> <p>最坏情况：任意输入规模的最大运行次数(上界)<br /> 平均情况：任意输入规模的期望运行次数<br /> 最好情况：任意输入规模的最小运行次数(下界)</p> <br></blockquote> <br><blockquote> <br> <p>例如：在一个长度为N数组中搜索一个数据x<br /> 最好情况：1次找到<br /> 最坏情况：N次找到<br /> 平均情况：N/2次找到</p> <br></blockquote> <br><p><strong>在实际中一般情况关注的是算法的<span style="color:#fe2c24;">最坏</span>运行情况，所以数组中搜索数据时间复杂度为O(N)</strong></p> <br><h3>计算冒泡排序的时间复杂度</h3> <br><pre><code class="language-cpp">void BubbleSort(int* a, int n)<br>{<br>    assert(a);<br>    for (size_t end = n; end > 0; --end)<br>    {<br>        int exchange = 0;<br>        for (size_t i = 1; i < end; ++i)<br>        {<br>            if (a[i-1] > a[i])<br>            {<br>                Swap(&a[i-1], &a[i]);//两数交换<br>                exchange = 1;<br>            }<br>        }    <br>        if (exchange == 0)<br>        break;<br>    }<br>}</code></pre> <br><p>基本操作执行最好情况N次，最坏执行了(N*(N+1)/2次，通过推导大O阶方法+时间复杂度一般看最<br /> 坏，时间复杂度为 O(N^2）</p> <br><blockquote> <br> <p>注意：最坏情况展开是：(n^2)/2 + n/2 我们选最高次项(n^2)/2，这里前面的因数1/2直接舍去（对结果影响不大）</p> <br></blockquote> <br><h3>计算二分查找的时间复杂度 </h3> <br><pre><code class="language-cpp">int BinarySearch(int* a, int n, int x)<br>{<br>    assert(a);<br>    int begin = 0;<br>    int end = n-1;<br>    // [begin, end]：begin和end是左闭右闭区间，因此有=号<br>    while (begin <= end)<br>    {<br>        int mid = begin + ((end-begin)>>1);<br>        if (a[mid] < x)<br>            begin = mid+1;<br>        else if (a[mid] > x)<br>            end = mid-1;<br>        else<br>            return mid;<br>    }<br>    return -1;<br>}</code></pre> <br><p>基本操作执行最好1次（中间数即为要查找的数），最坏O(logN)次（直到最后一次查找才查找出来），时间复杂度为 O(logN)。<span style="color:#ed7976;">(logN在算法分析中表示是底数为2)</span></p> <br><blockquote> <br> <p>为什么最坏是log(n)次?</p> <br> <p>答：假设最坏查找x次，一共N个数，每次查找都要除去1/2的数，最后仅剩一个数，就有N((1/2)^x )= 1。化简取对数得x = log(N).</p> <br></blockquote> <br><h3>计算阶乘递归Fac的时间复杂度</h3> <br><pre><code class="language-cpp">long long Fac(size_t N)<br>{<br>    if(0 == N)<br>        return 1;<br>    return Fac(N-1)*N;<br>}</code></pre> <br><p> 基本操作递归执行了N次（每一次调用函数都需要前一个函数的基础，直到调用到fac(1)停止），时间复杂度为O(N)</p> <br><h3>计算斐波那契递归Fib的时间复杂度</h3> <br><pre><code class="language-cpp">long long Fib(size_t N)<br>{<br>    if(N < 3)<br>        return 1;<br>    return Fib(N-1) + Fib(N-2);<br>}</code></pre> <br><p>基本操作递归执行了2^N次（每一次调用都需要前面两个函数的值为基础，类似于杨辉三角）时间复杂度为O(2^N)</p> <br><p style="text-align:center;"><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/9916ed22bcd678aa82382d1a23746997.png" /></p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>