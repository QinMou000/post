<blockquote> <br> <p style="text-align:center;"><img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/a46182e6318c4593a5c674f2bf9439d4.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12799988.html" title="Linux">Linux</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2 style="background-color:transparent;">版本控制器</h2> <br><p>为了能够更⽅便我们管理这些不同版本的⽂件，便有了版本控制器。所谓的版本控制器，就是能让你了解到⼀个⽂件的历史，以及它的发展过程的系统。通俗的讲就是⼀个可以记录⼯程的每⼀次改动和版本迭代的⼀个管理系统，同时也⽅便多⼈协同作业。 <span style="color:#be191c;"><strong>⽬前最主流的版本控制器就是 Git </strong></span>。Git 可以控制电脑上所有格式的⽂件，例如 doc、excel、dwg、 dgn、rvt等等。对于我们开发⼈员来说，Git 最重要的就是可以帮助我们管理软件开发项⽬中的源代码⽂件！ </p> <br><h2 style="background-color:transparent;">git 简史</h2> <br><p>同⽣活中的许多伟⼤事物⼀样，Git 诞⽣于⼀个极富纷争⼤举创新的年代。 Linux 内核开源项⽬有着为数众多的参与者。 绝⼤多数的 Linux 内核维护⼯作都花在了提交补丁和保存归档的繁琐事务上（1991−2002年间）。 到 2002 年，整个项⽬组开始启⽤⼀个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使⽤ BitKeeper 的权⼒。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使⽤ BitKeeper 时的经验教训，开发出⾃⼰的版本系统。 他们对新的系统制订了若⼲⽬标：</p> <br><ul><li>速度</li><li>简单的设计</li><li>对⾮线性开发模式的强⼒⽀持（允许成千上万个并⾏开发的分⽀）</li><li>完全分布式</li><li>有能⼒⾼效管理类似 Linux 内核⼀样的超⼤规模项⽬（速度和数据量）</li></ul> <br><p>⾃诞⽣于 2005 年以来，Git ⽇臻成熟完善，在⾼度易⽤的同时，仍然保留着初期设定的⽬标。 它的速度⻜快，极其适合管理⼤项⽬，有着令⼈难以置信的⾮线性分⽀管理系统。 </p> <br><h2> git的简单使用</h2> <br><h3>克隆仓库 </h3> <br><p>下载好git后。我们进入gitee或者github，新建一个仓库</p> <br><p><img alt="" height="218" src="https://i-blog.csdnimg.cn/direct/baf35413ef4b4ce5b5c11041326bc1e5.png" width="985" /></p> <br><p><img alt="" height="176" src="https://i-blog.csdnimg.cn/direct/a316a58bb13146f8a9663803ee9aa35b.png" width="1200" /></p> <br><p>将新建仓库的路径复制下来</p> <br><p>在本地打开cmd窗口输入</p> <br><pre><code class="hljs">git clone https://github.com/QinMou000/Code.git</code></pre> <br><p><img alt="" height="76" src="https://i-blog.csdnimg.cn/direct/46a9439e878f4f809b1aa26ed7b418a0.png" width="854" /></p> <br><p>你的当前目录下就会新建一个新文件了</p> <br><blockquote> <br> <p>其实在你新建仓库的时候，在云端为你新建了一个文件夹，这个新文件就是从云端的仓库克隆下来的。</p> <br></blockquote> <br><h3> 上传文件</h3> <br><p> 在里面新建一个.c文件<img alt="" height="316" src="https://i-blog.csdnimg.cn/direct/1c0e0f6dd9e44617b4550d939a00873d.png" width="914" /></p> <br><p> 在当前页面打开cmd窗口输入</p> <br><pre><code class="language-cpp">git add test.c // 你要上传的文件<br>git commit -m "这是一个测试" // 这次上传你做了什么工作<br>git push // 将代码上传到云端</code></pre> <br><p><img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/38a959d1314d49e4bf917ae0c2601277.png" width="730" /></p> <br><p>如果一切正常，再次打开github就会在你的仓库里看到你刚刚上传的文件了 </p> <br><p><img alt="" height="289" src="https://i-blog.csdnimg.cn/direct/6c01ff70f4a445b9998c98adffad8c63.png" width="1144" /><img alt="" height="254" src="https://i-blog.csdnimg.cn/direct/7dc0996a49784a01b946e74e0a5646e7.png" width="730" /></p> <br><blockquote> <br> <p>在我们本地仓库有一个隐形文件 .git 这个文件里面管理和记录了你本地仓库的所有提交，命令commit就是把你本地的更改记录到 .git 里面。push指令就是将本地的更改同步到云端。</p> <br></blockquote> <br><blockquote> <br> <p>那如果有两个人A B在管理这个仓库，今天上传了一个文件，B不知道A上传了，B也准备上传文件，但是此时B的本地仓库和云端仓库不一样，一个陌生的文件出现在了云端（A上传的）并且这个文件在B的本地没有任何记录，此时B就会上传失败。此时B的解决方法就是将本地与云端同步一次，也就是git pull指令。但这并不会删除B原来准备上传的文件，相当于把A上传的文件和上传记录拷了下来。这时B在git push 就没有任何问题了</p> <br></blockquote> <br><h2 style="background-color:transparent;">调试器 - gdb/cgdb使⽤</h2> <br><p>程序的发布⽅式有两种， debug 模式和 release 模式， Linux gcc/g++ 出来的⼆进制程序，默认是 release模式。</p> <br><p>要使⽤gdb调试，必须在源代码⽣成⼆进制程序的时候, 加上 -g 选项，如果没有添加，程序⽆法被 编译</p> <br><pre><code class="language-cpp">gcc test -o test.c -g<br></code></pre> <br><h3>常见指令</h3> <br><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>命令</td><td>作用</td><td>样例</td></tr><tr><td>list/l</td><td>显示源代码+数字表示行数</td><td>list/l 10</td></tr><tr><td>list/l 函数名</td><td>列出指定函数代码</td><td>list/l main</td></tr><tr><td>list/l 文件名:行号</td><td>列出指定文件的源代码</td><td>list/l test.c:2</td></tr><tr><td>r/run</td><td>从程序开始连续执行</td><td>run</td></tr><tr><td>n/next</td><td>单步执行，不进入函数内部</td><td>next</td></tr><tr><td>s/step</td><td>单步执行，进入函数内部</td><td> <p>step</p> </td></tr><tr><td>break/b 文件名:行号</td><td>在指定行号设置断点</td><td> <p>break test.c:10</p> <p>b 10</p> </td></tr><tr><td>break/b 函数名</td><td>在函数开头设置断点</td><td>break fun</td></tr><tr><td>info break/b</td><td>查看当前所有断点信息</td><td>info b</td></tr><tr><td>finish</td><td>执行到当前函数返回然后停止</td><td>finish</td></tr><tr><td>print/p</td><td>打印表达式的值</td><td>print start+end</td></tr><tr><td>p变量</td><td>打印指定变量的值</td><td>p x</td></tr><tr><td>set var 变量 = 值</td><td>修改变量的值</td><td>set var i = 10</td></tr><tr><td>continue/c</td><td>从当前位置开始连续执行程序</td><td>continue</td></tr><tr><td>delete/d breakpoints</td><td>删除所有断点</td><td>delete breakpoints</td></tr><tr><td>delete/d breakpoints n</td><td> <p>删除序号为n的断点</p> </td><td> <p>delete breakpoints 1</p> </td></tr><tr><td>disable breakpoints</td><td>禁⽤所有断点</td><td>disable breakpoints</td></tr><tr><td>enable breakpoints</td><td>启⽤所有断点</td><td>enable breakpoints</td></tr><tr><td>info/i breakpoints</td><td>查看当前设置的断点列表</td><td>info breakpoints</td></tr><tr><td>display 变量名</td><td>跟踪显示指定变量的值（每次停⽌时）</td><td>display x</td></tr><tr><td>undisplay 编号</td><td>取消对指定编号的变量的跟踪显⽰</td><td>undisplay 1</td></tr><tr><td>until x⾏号</td><td>执⾏到指定⾏号</td><td>until 20</td></tr><tr><td>backtrace/bt</td><td>查看当前执⾏栈的各级函数调⽤及参数</td><td>backtrace</td></tr><tr><td>info/i locals</td><td>查看当前栈帧的局部变量值</td><td>info locals</td></tr><tr><td>quit</td><td>退出GDB调试器</td><td>quit</td></tr></tbody></table> <br><h3>watch</h3> <br><p>执⾏时监视⼀个表达式（如变量）的值。如果监视的表达式在程序运⾏期间的值发⽣变化，GDB 会暂停程序的执⾏，并通知使⽤者。如果你有⼀些变量不应该修改，但是你怀疑它修改导致了问题，你可以watch它，如果变化了，就会通知你.</p> <br><h3>条件断点添加常⻅两种⽅式：</h3> <br><ol><li>新增</li><li>给已有断点追加</li></ol> <br><ul><li><span style="color:#be191c;"><strong>注意两者的语法有区别，不要写错了。 </strong></span></li><li><span style="color:#be191c;"><strong>新增： b ⾏号/⽂件名:⾏号/函数名 if i == 30(条件) </strong></span></li><li><span style="color:#be191c;"><strong>给已有断点追加：condition 2 i==30， 其中2是已有断点编号，没有if</strong></span></li></ul> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong> </p>