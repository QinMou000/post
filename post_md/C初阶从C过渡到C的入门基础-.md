<blockquote> <br> <p></p> <br> <p style="text-align:center;"><img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/a1e2fd8531ae4fbab004f1ecd1a2c8b1.jpeg" width="1024" /></p> <br> <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12723828.html?spm=1001.2014.3001.5482" title="C++">C++</a>✨✨</p> <br> <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> <br></blockquote> <br><h2>C++发展历史</h2> <br><p>        C++的起源可以追溯到1979年，当时BjarneStroustrup(本贾尼·斯特劳斯特卢普，这个翻译的名字不同的地⽅可能有差异)在⻉尔实验室从事计算机科学和软件⼯程的研究⼯作。⾯对项⽬中复杂的软件开发任务，特别是模拟和操作系统的开发⼯作，他感受到了现有语⾔（如C语⾔）在表达能⼒、可维护性和可扩展性⽅⾯的不⾜。<br />         1983年，BjarneStroustrup在C语⾔的基础上添加了⾯向对象编程的特性，设计出了C++语⾔的雏形，此时的C++已经有了类、封装、继承等核⼼概念，为后来的⾯向对象编程奠定了基础。这⼀年该语⾔被正式命名为C++。<br />         在随后的⼏年中，C++在学术界和⼯业界的应⽤逐渐增多。⼀些⼤学和研究所开始将C++作为教学和研究的⾸选语⾔，⽽⼀些公司也开始在产品开发中尝试使⽤C++。这⼀时期，C++的标准库和模板等特性也得到了进⼀步的完善和发展。<br />         C++的标准化⼯作于1989年开始，并成⽴了⼀个ANSI和ISO（International Standards Organization）国际标准化组织的联合标准化委员会。1994年标准化委员会提出了第⼀个标准化草<br /> 案。在该草案中，委员会在保持斯特劳斯特卢普最初定义的所有特征的同时，还增加了部分新特征。<br />         在完成C++标准化的第⼀个草案后不久，STL（Standard Template Library）是惠普实验室开发的⼀系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室⼯作时所开发出来的。在通过了标准化第⼀个草案之后，联合标准化委员会投票并通过了将STL包含到C++标准中的提议。STL对C++的扩展超出C++的最初定义范围。虽然在标准中增加STL是个很重要的决定，但也因此延缓了C++标准化的进程。<br />         1997年11⽉14⽇，联合标准化委员会通过了该标准的最终草案。1998年，C++的ANSI/IS0标准被投⼊使⽤。</p> <br><h3>C++祖师爷</h3> <br><p><img alt="" height="395" src="https://i-blog.csdnimg.cn/direct/9b47086b2159441da1370a388ba18729.png" width="600" /></p> <br><h3>1、起源与初期阶段（1980s）</h3> <br><p>​        C++的故事开始于上世纪80年代初，比尔·古德斯特（Bjarne Stroustrup）在贝尔实验室工作，他开始着手创建一种新的编程语言。他的目标是建立一种语言，能够充分利用C语言的优势，同时克服C语言的一些限制。在这个过程中，C++作为C的扩展逐渐形成，首个正式版本于1985年发布。</p> <br><h3>2、标准化与C++98（1990s）</h3> <br><p>        ​C++在初期经历了多个版本的迭代和改进，但真正的转折点发生在1998年，C++的第一个国际标准（ISO/IEC 14882:1998）正式发布。这一标准定义了许多现代C++的特性，包括模板、命名空间、异常处理等，使得C++成为一门更强大、更灵活的编程语言。C++98的发布标志着C++开始进入广泛接受的阶段。</p> <br><h3>3、技术进步与C++11（2011年）</h3> <br><p>        ​2011年，C++标准委员会发布了C++11标准，这是C++的一次巨大飞跃，引入了许多重要的新特性，如智能指针、lambda表达式、并发编程支持等。这一版本的发布对C++社区产生了深远的影响，使得C++在现代软件开发中更具竞争力。</p> <br><h3>4、C++14和C++17（2014年和2017年）</h3> <br><p>        ​C++14在2014年发布，它对C++11进行了一些小的改进和修复。</p> <br><p>        而在2017年，C++标准委员会发布了C++17标准，引入了一系列新特性，如变量模板、文件系统库、并行算法等，进一步提升了C++的功能和性能。</p> <br><h3>5、C++20和C++23（2020年和2023年）</h3> <br><p>        C++20是C++标准的最新版本，于2020年发布。它引入了许多新特性，包括概念、协程、范围基于的for循环等，进一步提高了C++的表达力和可读性。未来，C++标准委员会将继续推动C++的发展，以适应不断变化的软件开发需求。</p> <br><p>        C++23是一个小版本更新，进一步完善和改进现有特性，增加了if consteval、数、falt_map，import std导入标准库等</p> <br><h3>6、C++26（制定中……）</h3> <br><h2>命名空间</h2> <br><h3>为什么要有命名空间</h3> <br><p>        在C/C++中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全局作⽤域中，可能会导致很多冲突。使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。<br />         c语⾔项⽬类似下⾯程序这样的命名冲突是普遍存在的问题，C++引⼊namespace就是为了更好的解决这样的问题</p> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<stdlib.h><br><br>int rand = 10;<br><br>int main()<br>{<br>	printf("%d\n",rand);<br>	// 编译报错：error C2365: “rand”: 重定义；以前的定义是“函数”<br>	return 0;<br>}</code></pre> <br><h3> namespace的定义</h3> <br><p>        定义命名空间，需要使⽤到namespace关键字，后⾯跟命名空间的名字，然后接⼀对{}即可，{}中即为命名空间的成员。命名空间中<span style="color:#be191c;">可以定义变量/函数/类型</span>等。<br />         namespace本质是定义出⼀个<span style="color:#be191c;">域</span>，这个域跟全局域各⾃独⽴，不同的域可以定义同名变量，所以下⾯的rand不再冲突了。<br />         C++中域有<strong>函数局部域，全局域，命名空间域，类域；</strong>域影响的是编译时语法查找⼀个变量/函数/类型出处(声明或定义)的逻辑，所以有了域隔离，名字冲突就解决了。局部域和全局域除了会影响编译查找逻辑，还会影响变量的生命周期，命名空间域和类域不影响变量生命周期。</p> <br><blockquote> <br> <p>namespace只能定义在全局，当然他还可以<span style="color:#be191c;">嵌套定义。</span></p> <br> <p>项⽬⼯程中多⽂件中定义的<span style="color:#be191c;">同名</span>namespace会认为是⼀个namespace，不会冲突。</p> <br> <p>C++标准库都放在⼀个叫std(standard)的命名空间中。</p> <br></blockquote> <br><h4>常规命名空间的定义 </h4> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<stdlib.h><br>namespace Qinmou<br>{<br>	int rand = 0;<br>	int Add(int a, int b)<br>	{<br>		return a + b;<br>	}<br>	struct Node {<br>		int a;<br>		struct Node* next;<br>	};<br>}<br><br>int main()<br>{<br>	// 这⾥默认是访问的是全局的rand函数指针<br>	printf("%p\n", rand);<br>	// 这⾥指定Qinmou命名空间中的rand<br>	printf("%d\n", Qinmou::rand);<br><br>	return 0;<br>}</code></pre> <br><h4>嵌套命名空间</h4> <br><pre><code class="language-cpp">#include<stdio.h><br>#include<stdlib.h><br>namespace Qinmou<br>{<br>	namespace Qin {<br>		int a = 0;<br>		int Add(int a, int b)<br>		{<br>			return a + b;<br>		}<br>	}<br>	namespace Wang {<br>		int a = 1;<br>		int Add(int a, int b)<br>		{<br>			return (a + b) * 10;<br>		}<br>	}<br>}<br>int main()<br>{<br>	printf("%d\n", Qinmou::Qin::a);<br>	printf("%d\n", Qinmou::Wang::a);<br><br>	printf("%d\n", Qinmou::Qin::Add(1, 2));<br>	printf("%d\n", Qinmou::Wang::Add(1, 2));<br><br>	return 0;<br>}</code></pre> <br><p><strong>另外多文件中可以定义同名namespace，编译器会将他们默认合并到一起，等同于一个namespace。</strong></p> <br><h3>命名空间使⽤</h3> <br><p>编译查找⼀个变量的声明/定义时，默认只会在局部或者全局查找，不会到命名空间⾥⾯去查找。所以下⾯程序会编译报错。所以我们要使⽤命名空间中定义的变量/函数，有三种⽅式：</p> <br><blockquote> <br> <p>• 指定命名空间访问，项⽬中推荐这种⽅式。<br /> • using将命名空间中某个成员展开，项⽬中经常访问的不存在冲突的成员推荐这种⽅式。<br /> • 展开命名空间中全部成员，项⽬不推荐，冲突⻛险很⼤，⽇常⼩练习程序为了⽅便推荐使⽤。</p> <br></blockquote> <br><pre><code class="language-cpp">#include<stdio.h><br>namespace Qin<br>{<br>	int a = 0;<br>	int b = 1;<br>} <br>int main()<br>{<br>	// 编译报错：error C2065: “a”: 未声明的标识符<br>	printf("%d\n", a);<br>	return 0;<br>}</code></pre> <br><h4>指定命名空间访问</h4> <br><pre><code class="language-cpp">int main()<br>{<br>	printf("%d\n", Qin::a);<br>	return 0;<br>}</code></pre> <br><h4>using将命名空间中的某个成员展开</h4> <br><pre><code class="language-cpp">using Qin::b;<br>int main()<br>{<br>	printf("%d\n", Qin::a);<br>	printf("%d\n", b);<br>	return 0;<br>}</code></pre> <br><h4> 展开命名空间中全部成员</h4> <br><pre><code class="language-cpp">using namespace Qin;<br>int main()<br>{<br>	printf("%d\n", a);<br>	printf("%d\n", b);<br>	return 0;<br>}</code></pre> <br><h2> C++输入&输出</h2> <br><blockquote> <br> <p>• <iostream>是Input Output Stream的缩写，是标准的输⼊、输出流库，定义了标准的输⼊、输<br /> 出对象。<br /> • std::cin是istream类的对象，它主要⾯向窄字符（narrow characters(of type char)）的标准输<br /> ⼊流。<br /> • std::cout是ostream类的对象，它主要⾯向窄字符的标准输出流。<br /> • std::endl是⼀个函数，流插⼊输出时，相当于插⼊⼀个换⾏字符加刷新缓冲区。<br /> • <<是流插⼊运算符，>>是流提取运算符。（C语⾔还⽤这两个运算符做位运算左移/右移）<br /> • 使⽤C++输⼊输出更⽅便，不需要像printf/scanf输⼊输出时那样，需要⼿动指定格式，C++的输⼊<br /> 输出可以⾃动识别变量类型(本质是通过函数重载实现的，这个以后会讲到)，其实最重要的是<br /> C++的流能更好的⽀持⾃定义类型对象的输⼊输出。<br /> • IO流涉及类和对象，运算符重载、继承等很多⾯向对象的知识，这些知识我们还没有讲解，所以这<br /> ⾥我们只能简单认识⼀下C++IO流的⽤法，后⾯我们会有专⻔的⼀个章节来细节IO流库。<br /> • cout/cin/endl等都属于C++标准库，C++标准库都放在⼀个叫std(standard)的命名空间中，所以要<br /> 通过命名空间的使⽤⽅式去⽤他们。<br /> • ⼀般⽇常练习中我们可以using namespace std，实际项⽬开发中不建议using namespace std。<br /> • 这⾥我们没有包含<stdio.h>，也可以使⽤printf和scanf，在包含<iostream>间接包含了。vs系列<br /> 编译器是这样的，其他编译器可能会报错。</p> <br></blockquote> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br><br>int main()<br>{<br>	int a;<br>	double b;<br>	char c;<br>	cin >> a >> b >> c;//可以自动识别变量的类型<br>	cout << a << " " << b << " " << c << endl;<br>	return 0;<br>}</code></pre> <br><p>另外在io需求比较高的地方，如部分大量输入的竞赛题中，加上以下三行代码可以提高C++IO效率（具体原因目前我无法解释……）</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br><br>int main()<br>{<br>	ios_base::sync_with_stdio(false);<br>	cin.tie(nullptr);<br>	cout.tie(nullptr);<br>	return 0;<br>}</code></pre> <br><h2>缺省参数</h2> <br><pre><code class="language-cpp">void fun(int a = 10, int b = 20, int c = 30)//全缺省<br>{<br>	cout << a << " " << b << " " << c << endl;<br>}<br><br>void fun(int a, int b = 20, int c = 30)//半缺省<br>{<br>	cout << a << " " << b << " " << c << endl;<br>}</code></pre> <br><blockquote> <br> <p>• 缺省参数是声明<span style="color:#be191c;"><strong>或</strong></span>定义函数时为函数的参数指定⼀个缺省值。在调⽤该函数时，如果没有指定实参则采⽤该形参的缺省值，否则使⽤指定的实参，缺省参数分为全缺省和半缺省参数。（有些地⽅把缺省参数也叫默认参数）<br /> • 全缺省就是全部形参给缺省值，半缺省就是部分形参给缺省值。<span style="color:#be191c;"><strong>C++规定半缺省参数必须从右往左依次连续缺省，不能间隔跳跃给缺省值。</strong></span><br /> • <span style="color:#be191c;"><strong>带缺省参数的函数调⽤，C++规定必须从左到右依次给实参，不能跳跃给实参。</strong></span><br /> • <strong><span style="color:#be191c;">函数声明和定义分离时，缺省参数不能在函数声明和定义中同时出现，规定必须函数声明给缺省值。</span></strong></p> <br></blockquote> <br><p> 之前在写顺序表的时候，每次数据满了就需要扩容，当我们需要一次存储1000个整型数据，那么就要扩容将近10次。如果直接这样写：</p> <br><pre><code class="language-cpp">void STInit(St* ps, int n = 4);</code></pre> <br><p>在调用时可以直接把n赋值成1000。这样一次就把空间开完了，避免了一些不必要的重复操作。 </p> <br><h2>函数重载</h2> <br><p>C++⽀持在同⼀作⽤域中出现同名函数，但是要求这些同名函数的<strong>形参不同</strong>，可以是<strong>参数个数不同或者类型不同</strong>。这样C++函数调⽤就表现出了<strong>多态</strong>⾏为，使⽤更灵活。但是C语⾔是不⽀持同⼀作⽤域中出现同名函数的。</p> <br><p><strong>参数类型不同：</strong></p> <br><pre><code class="language-cpp">int Add(int a, int b)<br>{<br>	return a + b;<br>}<br>double Add(double a, double b)<br>{<br>	return a + b;<br>}</code></pre> <br><p><strong>参数个数不同：</strong></p> <br><pre><code class="language-cpp">void fun()<br>{<br>	cout << "fun()" << endl;<br>}<br>void fun(int a)<br>{<br>	cout << "fun(int a)" << endl;<br>}</code></pre> <br><p><strong>参数顺序不同： </strong></p> <br><pre><code class="language-cpp">void fun(int a, char b)<br>{<br>	cout << "fun(int a,char b)" << endl;<br>}<br>void fun(char a, int b)<br>{<br>	cout << "fun(char a,int b)" << endl;<br>}</code></pre> <br><blockquote> <br> <p><span style="color:#be191c;"><strong>注意：返回值不同不能作为重载条件，因为调用的方式不同，无法区分</strong></span></p> <br></blockquote> <br><p><strong><span style="color:#956fe7;"> 特殊的：下面两个函数构成重载（参数个数不同）。</span></strong></p> <br><blockquote> <br> <p>无参数时：两个函数都可以调用，编译器不知道调用谁。</p> <br> <p>有参数时：调用第二个缺省函数</p> <br></blockquote> <br><pre><code class="language-cpp">void f()<br>{<br>	cout << "f()" << endl;<br>}<br><br>void f(int a = 10)<br>{<br>	cout << "f(int a = 10)" << endl;<br>}</code></pre> <br><h2>引用</h2> <br><h3>引用的概念、定义</h3> <br><p>引⽤不是新定义⼀个变量，⽽是给已存在变量取了⼀个别名，编译器不会为引⽤变量开辟内存空间，它和它引⽤的变量共⽤同⼀块内存空间。⽐如：⽔壶传中李逵，宋江叫"铁⽜"，江湖上⼈称"⿊旋⻛"；林冲，外号豹⼦头；</p> <br><blockquote> <br> <p>类型&引⽤别名 = 引⽤对象;</p> <br></blockquote> <br><p>C++中为了避免引⼊太多的运算符，会复⽤C语⾔的⼀些符号，⽐如前⾯的 << 和 >> ，这⾥引⽤也和取地址使⽤了同⼀个符号&，⼤家注意区分。</p> <br><pre><code class="language-cpp">int main()<br>{<br>	int a = 0;<br><br>	int& b = a;<br>	int& c = a;<br>	int& d = b;<br><br>	++d;<br><br>	cout << &a << endl;<br>	cout << &b << endl;<br>	cout << &c << endl;<br>	cout << &d << endl;//地址是一样的，因为没有新变量，只是别名，给我记清楚了！！！<br><br>	return 0;<br>}</code></pre> <br><h3>引用的特性</h3> <br><blockquote> <br> <p>• 引⽤在定义时必须初始化<br /> • ⼀个变量可以有多个引⽤<br /><span style="color:#be191c;">• 引⽤⼀旦引⽤⼀个实体，再不能引⽤其他实体</span></p> <br></blockquote> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br><br>int main()<br>{<br>	int a = 0;<br><br>	int& b = a;<br><br>	int c = 20;<br><br>	b = c;//这里不是让b引用c，C++的引用不能改变指向<br>	      //这里是将c的值赋值给a（b是别名！！！）<br>	return 0;<br>}</code></pre> <br><h3>引用的使用</h3> <br><blockquote> <br> <p>• 引⽤在实践中主要是于引⽤传参和引⽤做返回值中<strong>减少拷⻉提⾼效率和改变引⽤对象时同时改变被引⽤对象。</strong><br /> • 引⽤传参跟指针传参功能是类似的，引⽤传参相对更⽅便⼀些。<br /> • 引⽤和指针在实践中相辅相成，功能有重叠性，但是各有特点，互相不可替代。C++的引⽤跟其他语⾔的引⽤(如Java)是有很⼤的区别的，<strong>除了⽤法，最⼤的点，C++引⽤定义后不能改变指向，Java的引⽤可以改变指向。</strong></p> <br></blockquote> <br><p>之前我们经常用的交换数据的函数可以用引用这样写：</p> <br><pre><code class="language-cpp">int Swap(int& a, int& b)<br>{<br>	int tmp = a;<br>	a = b;<br>	b = tmp;<br>}</code></pre> <br><p>之前我们写链表尾插的时候，我们传的是二级指针（可以改变一级指针的值），我们也可以传一级指针的引用来改变一级指针的值，这样就不需要传二级指针。</p> <br><pre><code class="language-cpp">void ListPushBack(LTNode** phead, int x);<br>void ListPushBack(LTNode*& phead, int x);</code></pre> <br><h3>const引用</h3> <br><blockquote> <br> <p>• 可以引⽤⼀个const对象，但是必须⽤const引⽤。const引⽤也可以引⽤普通对象，因为<strong>对象的访问权限在引⽤过程中可以缩⼩，但是不能放⼤。</strong></p> <br></blockquote> <br><pre><code class="language-cpp">int main()<br>{<br>	int a = 2;<br>	const int& rb = a * 3;//a*3的结果会先保存在一个临时对象中<br><br>    // 编译报错: “初始化”: ⽆法从“int”转换为“int &”<br>    // int& rb = a * 3;<br><br>	double d = 12.34;<br>	const int& rd = d;//类型转换中也会产生临时对象<br><br>    // 编译报错：“初始化”: ⽆法从“double”转换为“int &”<br>    // int& rd = d;<br><br>	return 0;<br>}</code></pre> <br><p>rb和rd引⽤的都是临时对象，⽽C++规定临时对象具有常性，所以这⾥就触发了<strong>权限放⼤</strong>，必须要⽤常引⽤才可以。（对象的权限可以减小，但是不能放大）</p> <br><pre><code class="language-cpp">int mian()<br>{<br>	const int a = 2;<br><br>	//int& ra = a; “初始化”: 无法从“const int”转换为“int &”<br>    //这里权限放大了    <br><br>	const int ra = a;<br>	//ra++; “++”需要左值<br><br>	return 0;<br>}</code></pre> <br><blockquote> <br> <p>所谓临时对象就是编译器需要⼀个空间暂存表达式的求值结果时临时创建的⼀个未命名的对象，C++中把这个未命名对象叫做临时对象。</p> <br></blockquote> <br><h3>指针和引用的关系</h3> <br><p> C++中指针和引⽤就像两个性格迥异的亲兄弟，指针是哥哥，引⽤是弟弟，在实践中他们相辅相成，功能有重叠性，但是各有⾃⼰的特点，互相不可替代。</p> <br><blockquote> <br> <p>• <strong>语法概念上：</strong>引⽤是⼀个变量的取别名不开空间，指针是存储⼀个变量地址，要开空间。<br /> • 引⽤在定义时必须初始化，指针建议初始化，但是语法上不是必须的。<br /> • 引⽤在初始化时引⽤⼀个对象后，就不能再引⽤其他对象；⽽指针可以在不断地改变指向对象。<br /> • 引⽤可以直接访问指向对象，指针需要解引⽤才是访问指向对象。<br /> • sizeof中含义不同，引⽤结果为引⽤类型的⼤⼩，但指针始终是地址空间所占字节个数(32位平台下占4个字节，64位下是8byte)<br /> • 指针很容易出现空指针和野指针的问题，引⽤很少出现，引⽤使⽤起来相对更安全⼀些。</p> <br></blockquote> <br><h2> inline</h2> <br><blockquote> <br> <p>• ⽤inline修饰的函数叫做内联函数，编译时C++编译器会在调⽤的地⽅展开内联函数，这样调⽤内联函数就不需要建⽴栈帧了，就可以提⾼效率。<br /> • inline对于编译器⽽⾔只是⼀个<strong>建议</strong>，也就是说，你加了inline编译器也可以选择在调⽤的地⽅不展开，不同编译器关于inline什么情况展开各不相同，因为C++标准没有规定这个。inline适⽤于频繁调⽤的短⼩函数，对于递归函数，代码相对多⼀些的函数，加上inline也会被编译器忽略。<br /> • C语⾔实现宏函数也会在预处理时替换展开，但是宏函数实现很复杂很容易出错的，且不⽅便调试，<strong>C++设计了inline⽬的就是替代C的宏函数。</strong><br /><span style="color:#be191c;"><strong>•</strong></span> <span style="color:#be191c;"><strong>inline不建议声明和定义分离到两个⽂件，分离会导致链接错误。因为inline被展开，就没有函数地址，链接时会出现报错。</strong></span></p> <br></blockquote> <br><p>比如实现Add的宏函数，容易写错为x+y或(x)+(y)或(x+y)，这里用内联函数就方便了许多</p> <br><pre><code class="language-cpp">#include<iostream><br>using namespace std;<br><br>//#define Add(x,y) ((x)+(y))<br><br>inline int Add(int x, int y)<br>{<br>	return x + y;<br>}<br>int main()<br>{<br>	int a = 2;<br>	cout << Add(a, a) << endl;<br>	return 0;<br>}</code></pre> <br><h2>nullptr</h2> <br><pre><code class="language-cpp">void f(int x)<br>{<br>	cout << "f(int x)" << endl;<br>}<br>void f(int* ptr)<br>{<br>	cout << "f(int* ptr)" << endl;<br>}<br>//参数类型不同，构成函数重载<br>int main()<br>{<br>	f(NULL);//NULL展开为0所以调用第一个函数，但实际是想调用第二个<br>	//f((void*)NULL); 编译报错: error C2665: “f”: 2 个重载中没有⼀个可以转换所有参数类型<br>	f((int*)NULL);//调用第二个函数<br>	f(nullptr);//调用第二个函数<br><br>	return 0;<br>}</code></pre> <br><p>• C++中NULL可能被定义为字⾯常量0，或者C中被定义为⽆类型指针(void*)的常量。不论采取何种定义，在使⽤空值的指针时，都不可避免的会遇到⼀些⿇烦，本想通过f(NULL)调⽤指针版本的<br /> f(int*)函数，但是由于NULL被定义成0，调⽤了f(int x)，因此与程序的初衷相悖。f((void*)NULL);<br /> 调⽤会报错。<br /> • C++11中引⼊nullptr，nullptr是⼀个特殊的关键字，nullptr是⼀种特殊类型的字⾯量，它可以<strong>转换<br /> 成任意其他类型的指针类型。</strong>使⽤nullptr定义空指针可以避免类型转换的问题，因为nullptr只能被<br /> 隐式地转换为指针类型，⽽<strong>不能被转换为整数类型。</strong></p> <br><p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p>